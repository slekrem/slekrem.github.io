{"mappings":"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","sources":["<anon>","node_modules/@getalby/sdk/dist/index.module.js","node_modules/nostr-tools/lib/esm/index.js","node_modules/@noble/curves/secp256k1.js","node_modules/@noble/curves/src/secp256k1.ts","node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/sha256.ts","node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/_sha2.ts","node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/_assert.ts","node_modules/@noble/curves/node_modules/@noble/hashes/utils.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/utils.ts","node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/crypto.ts","node_modules/@noble/curves/abstract/modular.js","node_modules/@noble/curves/src/abstract/modular.ts","node_modules/@noble/curves/abstract/utils.js","node_modules/@noble/curves/src/abstract/utils.ts","node_modules/@noble/curves/abstract/weierstrass.js","node_modules/@noble/curves/src/abstract/weierstrass.ts","node_modules/@noble/curves/abstract/curve.js","node_modules/@noble/curves/src/abstract/curve.ts","node_modules/@noble/curves/abstract/hash-to-curve.js","node_modules/@noble/curves/src/abstract/hash-to-curve.ts","node_modules/@noble/curves/_shortw_utils.js","node_modules/@noble/curves/src/_shortw_utils.ts","node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js","node_modules/@noble/curves/node_modules/@noble/hashes/src/hmac.ts","node_modules/@noble/hashes/utils.js","node_modules/@noble/hashes/src/utils.ts","node_modules/@noble/hashes/crypto.js","node_modules/@noble/hashes/src/crypto.ts","node_modules/@noble/hashes/sha256.js","node_modules/@noble/hashes/src/sha256.ts","node_modules/@noble/hashes/_sha2.js","node_modules/@noble/hashes/src/_sha2.ts","node_modules/@noble/hashes/_assert.js","node_modules/@noble/hashes/src/_assert.ts","node_modules/@scure/base/lib/esm/index.js","node_modules/@noble/ciphers/aes.js","node_modules/@noble/ciphers/src/aes.ts","node_modules/@noble/ciphers/utils.js","node_modules/@noble/ciphers/src/utils.ts","node_modules/@noble/ciphers/_assert.js","node_modules/@noble/ciphers/src/_assert.ts","node_modules/@noble/ciphers/_polyval.js","node_modules/@noble/ciphers/src/_polyval.ts","node_modules/@noble/ciphers/chacha.js","node_modules/@noble/ciphers/src/chacha.ts","node_modules/@noble/ciphers/_poly1305.js","node_modules/@noble/ciphers/src/_poly1305.ts","node_modules/@noble/ciphers/_arx.js","node_modules/@noble/ciphers/src/_arx.ts","node_modules/@noble/hashes/hkdf.js","node_modules/@noble/hashes/src/hkdf.ts","node_modules/@noble/hashes/hmac.js","node_modules/@noble/hashes/src/hmac.ts","node_modules/@getalby/lightning-tools/dist/index.module.js","js/main.js","js/wallet-manager.js","js/price-manager.js","js/stabilization-manager.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequireed78\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequireed78\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"9BsJg\", function(module, exports) {\n\n$parcel$export(module.exports, \"nwc\", () => Ee);\n\nvar $fS6LT = parcelRequire(\"fS6LT\");\n\nvar $imRk1 = parcelRequire(\"imRk1\");\nfunction h(e, t) {\n    for(var n = 0; n < t.length; n++){\n        var r = t[n];\n        r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n    }\n}\nfunction f(e, t, n) {\n    return t && h(e.prototype, t), n && h(e, n), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction d() {\n    return d = Object.assign ? Object.assign.bind() : function(e) {\n        for(var t = 1; t < arguments.length; t++){\n            var n = arguments[t];\n            for(var r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);\n        }\n        return e;\n    }, d.apply(this, arguments);\n}\nfunction v(e, t) {\n    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, m(e, t);\n}\nfunction p(e) {\n    return p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {\n        return e.__proto__ || Object.getPrototypeOf(e);\n    }, p(e);\n}\nfunction m(e, t) {\n    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {\n        return e.__proto__ = t, e;\n    }, m(e, t);\n}\nfunction y() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n    try {\n        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;\n    } catch (e) {\n        return !1;\n    }\n}\nfunction P(e, t, n) {\n    return P = y() ? Reflect.construct.bind() : function(e, t, n) {\n        var r = [\n            null\n        ];\n        r.push.apply(r, t);\n        var o = new (Function.bind.apply(e, r));\n        return n && m(o, n.prototype), o;\n    }, P.apply(null, arguments);\n}\nfunction w(e) {\n    var t = \"function\" == typeof Map ? new Map : void 0;\n    return w = function(e) {\n        if (null === e || -1 === Function.toString.call(e).indexOf(\"[native code]\")) return e;\n        if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n        if (void 0 !== t) {\n            if (t.has(e)) return t.get(e);\n            t.set(e, n);\n        }\n        function n() {\n            return P(e, arguments, p(this).constructor);\n        }\n        return n.prototype = Object.create(e.prototype, {\n            constructor: {\n                value: n,\n                enumerable: !1,\n                writable: !0,\n                configurable: !0\n            }\n        }), m(n, e);\n    }, w(e);\n}\nfunction g(e, t) {\n    if (null == e) return {};\n    var n, r, o = {}, i = Object.keys(e);\n    for(r = 0; r < i.length; r++)t.indexOf(n = i[r]) >= 0 || (o[n] = e[n]);\n    return o;\n}\nvar b = /*#__PURE__*/ function() {\n    function e() {\n        this.events = {};\n    }\n    var t = e.prototype;\n    return t.on = function(e, t) {\n        this.events[e] || (this.events[e] = []), this.events[e].push(t);\n    }, t.off = function(e, t) {\n        this.events[e] && (this.events[e] = this.events[e].filter(function(e) {\n            return e !== t;\n        }));\n    }, t.emit = function(e, t) {\n        this.events[e] && this.events[e].forEach(function(e) {\n            return e(t);\n        });\n    }, e;\n}();\nfunction _(e) {\n    return Object.entries(e).map(function(e) {\n        var t = e[0], n = e[1];\n        return t && n ? t + \"=\" + n : \"\";\n    }).filter(function(e) {\n        return e;\n    }).join(\"&\");\n}\nfunction k(e, t) {\n    return \"Basic \" + btoa(e + \":\" + t);\n}\nvar E = {\n    __proto__: null,\n    buildQueryString: _,\n    basicAuthHeader: k\n}, T = /*#__PURE__*/ function(e) {\n    function t(t, n, r, o) {\n        var i, s = t.toString();\n        return n && (s += \" \" + n), s += \": \", s += o.message ? o.message : JSON.stringify(o), (i = e.call(this, s) || this).status = void 0, i.statusText = void 0, i.headers = void 0, i.error = void 0, i.status = t, i.statusText = n, i.headers = r, i.error = o, i;\n    }\n    return v(t, e), t;\n}(/*#__PURE__*/ w(Error)), N = {\n    __proto__: null,\n    OAuthClient: function() {},\n    AuthClient: function() {},\n    AlbyResponseError: T\n}, j = [\n    \"auth\",\n    \"endpoint\",\n    \"params\",\n    \"request_body\",\n    \"method\",\n    \"max_retries\",\n    \"base_url\",\n    \"user_agent\",\n    \"headers\"\n], q = function(e) {\n    return Promise.resolve(R(e)).then(function(e) {\n        return e.json();\n    });\n}, R = function(e) {\n    var t = e.auth, n = e.endpoint, r = e.params, o = void 0 === r ? {} : r, i = e.request_body, s = e.method, u = e.max_retries, c = e.base_url, a = void 0 === c ? O : c, l = e.user_agent, h = e.headers, f = g(e, j);\n    try {\n        var v = function(e) {\n            return Promise.resolve(S(p.toString(), d({\n                headers: d({}, m ? {\n                    \"Content-Type\": \"application/json; charset=utf-8\"\n                } : void 0, e, h, {\n                    \"User-Agent\": null != l ? l : \"@getalby/sdk\",\n                    \"X-User-Agent\": null != l ? l : \"@getalby/sdk\"\n                }),\n                method: s,\n                body: m ? JSON.stringify(i) : void 0\n            }, f), u)).then(function(e) {\n                var t = function() {\n                    if (!e.ok) return Promise.resolve(e.json()).then(function(t) {\n                        throw new T(e.status, e.statusText, e.headers, t);\n                    });\n                }();\n                return t && t.then ? t.then(function(t) {\n                    return e;\n                }) : e;\n            });\n        }, p = new URL(a + n);\n        p.search = _(o);\n        var m = \"POST\" === s && !!i;\n        return Promise.resolve(t ? Promise.resolve(t.getAuthHeader(p.href, s)).then(v) : v(void 0));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, S = function e(t, n, r) {\n    void 0 === r && (r = 0);\n    try {\n        return Promise.resolve(fetch(t, n)).then(function(o) {\n            var i, s = function() {\n                if (429 === o.status && r > 0) {\n                    var s = Number(o.headers.get(\"x-rate-limit-reset\")), u = Number(o.headers.get(\"x-rate-limit-remaining\")), c = 1e3 * s - Date.now(), a = 1e3;\n                    return 0 === u && (a = c), Promise.resolve(new Promise(function(e) {\n                        return setTimeout(e, a);\n                    })).then(function() {\n                        var o = e(t, n, r - 1);\n                        return i = 1, o;\n                    });\n                }\n            }();\n            return s && s.then ? s.then(function(e) {\n                return i ? e : o;\n            }) : i ? s : o;\n        });\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, O = \"https://api.getalby.com\", I = function(e) {\n    return e.reduce(function(e, t) {\n        return e + t.toString(16).padStart(2, \"0\");\n    }, \"\");\n}, x = [\n    \"expires_in\"\n], A = [\n    \"token\"\n];\nfunction U(e) {\n    var t = e.expires_in;\n    return d({}, g(e, x), !!t && {\n        expires_at: Date.now() + 1e3 * t\n    });\n}\nvar C = /*#__PURE__*/ function() {\n    function e(e) {\n        this.token = void 0, this.options = void 0, this.code_verifier = void 0, this.code_challenge = void 0, this._refreshAccessTokenPromise = void 0, this._tokenEvents = void 0, this._tokenEvents = new b;\n        var t = e.token, n = g(e, A);\n        this.options = d({\n            client_secret: \"\"\n        }, n), this.token = t, this._refreshAccessTokenPromise = null;\n    }\n    var t = e.prototype;\n    return t.on = function(e, t) {\n        this._tokenEvents.on(e, t);\n    }, t.refreshAccessToken = function() {\n        try {\n            var e = this;\n            return e._refreshAccessTokenPromise || (e._refreshAccessTokenPromise = new Promise(function(t, n) {\n                try {\n                    return Promise.resolve(function(r, o) {\n                        try {\n                            var i = function(n, r) {\n                                try {\n                                    var o = function() {\n                                        var n, r = null == (n = e.token) ? void 0 : n.refresh_token, o = e.options, i = o.client_id, s = o.client_secret, u = o.request_options, c = o.user_agent;\n                                        if (!i) throw new Error(\"client_id is required\");\n                                        if (!r) throw new Error(\"refresh_token is required\");\n                                        return Promise.resolve(q(d({}, u, {\n                                            endpoint: \"/oauth/token\",\n                                            params: {\n                                                client_id: i,\n                                                grant_type: \"refresh_token\",\n                                                refresh_token: r\n                                            },\n                                            user_agent: c,\n                                            method: \"POST\",\n                                            headers: d({}, null == u ? void 0 : u.headers, {\n                                                \"Content-type\": \"application/x-www-form-urlencoded\"\n                                            }, {\n                                                Authorization: k(i, s)\n                                            })\n                                        }))).then(function(n) {\n                                            var r = U(n);\n                                            e.token = r, t({\n                                                token: r\n                                            }), e._tokenEvents.emit(\"tokenRefreshed\", e.token);\n                                        });\n                                    }();\n                                } catch (e) {\n                                    return r(e);\n                                }\n                                return o && o.then ? o.then(void 0, r) : o;\n                            }(0, function(t) {\n                                console.error(t), n(t), e._tokenEvents.emit(\"tokenRefreshFailed\", t);\n                            });\n                        } catch (e) {\n                            return o(!0, e);\n                        }\n                        return i && i.then ? i.then(o.bind(null, !1), o.bind(null, !0)) : o(!1, i);\n                    }(0, function(t, n) {\n                        if (e._refreshAccessTokenPromise = null, t) throw n;\n                        return n;\n                    }));\n                } catch (e) {\n                    return Promise.reject(e);\n                }\n            })), Promise.resolve(e._refreshAccessTokenPromise);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.isAccessTokenExpired = function() {\n        var e, t, n = null == (e = this.token) ? void 0 : e.refresh_token, r = null == (t = this.token) ? void 0 : t.expires_at;\n        return !r || !!n && r <= Date.now() + 1e3;\n    }, t.requestAccessToken = function(e) {\n        try {\n            var t = this, n = t.options, r = n.client_id, o = n.client_secret, i = n.callback, s = n.request_options, u = n.user_agent, c = t.code_verifier;\n            if (!r) throw new Error(\"client_id is required\");\n            if (!o && !c) throw new Error(\"either client_secret is required, or code should be generated using a challenge\");\n            if (!i) throw new Error(\"callback is required\");\n            return Promise.resolve(q(d({}, s, {\n                endpoint: \"/oauth/token\",\n                params: {\n                    code: e,\n                    grant_type: \"authorization_code\",\n                    code_verifier: c,\n                    client_id: r,\n                    redirect_uri: i\n                },\n                user_agent: u,\n                method: \"POST\",\n                headers: d({}, null == s ? void 0 : s.headers, {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }, {\n                    Authorization: k(r, o)\n                })\n            }))).then(function(e) {\n                var n = U(e);\n                return t.token = n, {\n                    token: n\n                };\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.generateAuthURL = function(e) {\n        try {\n            var t = function() {\n                var t = n.code_challenge, o = new URL(e.authorizeUrl || \"https://getalby.com/oauth\");\n                return o.search = _(d({}, e, {\n                    client_id: i,\n                    scope: u.join(\" \"),\n                    response_type: \"code\",\n                    redirect_uri: s,\n                    code_challenge_method: r,\n                    code_challenge: t\n                })), o.toString();\n            }, n = this;\n            e || (e = {});\n            var r, o = n.options, i = o.client_id, s = o.callback, u = o.scopes;\n            if (!s) throw new Error(\"callback required\");\n            if (!u) throw new Error(\"scopes required\");\n            var c = function() {\n                if (\"S256\" === e.code_challenge_method) return Promise.resolve(n._generateS256Challenge()).then(function() {\n                    r = \"S256\";\n                });\n                \"plain\" === e.code_challenge_method && e.code_challenge && (n.code_challenge = e.code_challenge, n.code_verifier = e.code_challenge, r = \"plain\");\n            }();\n            return Promise.resolve(c && c.then ? c.then(t) : t());\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.getAuthHeader = function() {\n        try {\n            var e, t = function() {\n                return {\n                    Authorization: \"Bearer \" + n.token.access_token\n                };\n            }, n = this;\n            if (null == (e = n.token) || !e.access_token) throw new Error(\"access_token is required\");\n            var r = function() {\n                if (n.isAccessTokenExpired()) return Promise.resolve(n.refreshAccessToken()).then(function() {});\n            }();\n            return Promise.resolve(r && r.then ? r.then(t) : t());\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t._generateS256Challenge = function() {\n        try {\n            var e = this, t = crypto.getRandomValues(new Uint8Array(64));\n            return e.code_verifier = I(t), Promise.resolve(crypto.subtle.digest(\"SHA-256\", (new TextEncoder).encode(e.code_verifier))).then(function(t) {\n                var n = new Uint8Array(t);\n                e.code_challenge = btoa(String.fromCharCode.apply(String, n)).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, e;\n}(), M = /*#__PURE__*/ function() {\n    function e(e) {\n        this.bearer_token = void 0, this.bearer_token = e;\n    }\n    return e.prototype.getAuthHeader = function() {\n        return {\n            Authorization: \"Bearer \" + this.bearer_token\n        };\n    }, e;\n}(), F = {\n    __proto__: null,\n    OAuth2User: C,\n    OAuth2Bearer: M\n};\nfunction W(e) {\n    var t = {};\n    return e.recipient.customKey && e.recipient.customValue && (t[e.recipient.customKey] = e.recipient.customValue), t[7629169] = JSON.stringify(e.boostagram), {\n        destination: e.recipient.address,\n        amount: e.amount,\n        custom_records: t\n    };\n}\nvar L = /*#__PURE__*/ function() {\n    function e(e, t) {\n        this.auth = void 0, this.defaultRequestOptions = void 0, this.auth = \"string\" == typeof e ? new M(e) : e, this.defaultRequestOptions = d({}, t, {\n            user_agent: null == t ? void 0 : t.user_agent\n        });\n    }\n    var t = e.prototype;\n    return t.accountBalance = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/balance\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.signMessage = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/signatures\",\n            request_body: e,\n            method: \"POST\"\n        }));\n    }, t.accountSummary = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/user/summary\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.accountInformation = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/user/me\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.accountValue4Value = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/user/value4value\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.incomingInvoices = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/invoices/incoming\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.outgoingInvoices = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/invoices/outgoing\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.invoices = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/invoices\",\n            params: e,\n            method: \"GET\"\n        }));\n    }, t.getInvoice = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/invoices/\" + e,\n            method: \"GET\"\n        }));\n    }, t.decodeInvoice = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/decode/bolt11/\" + e,\n            method: \"GET\"\n        }));\n    }, t.createInvoice = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/invoices\",\n            request_body: e,\n            method: \"POST\"\n        }));\n    }, t.keysend = function(e, t) {\n        var n, r;\n        return Array.isArray(e) ? (n = \"/payments/keysend/multi\", r = {\n            keysends: e.map(function(e) {\n                return d({}, e, {\n                    custom_records: e.customRecords\n                });\n            })\n        }) : (n = \"/payments/keysend\", r = d({}, e, {\n            custom_records: e.customRecords\n        })), q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: n,\n            request_body: r,\n            method: \"POST\"\n        }));\n    }, t.sendPayment = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/payments/bolt11\",\n            request_body: e,\n            method: \"POST\"\n        }));\n    }, t.sendBoostagram = function(e, t) {\n        var n, r;\n        return Array.isArray(e) ? (n = \"/payments/keysend/multi\", r = {\n            keysends: e.map(function(e) {\n                return W(e);\n            })\n        }) : (n = \"/payments/keysend\", r = W(e)), q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: n,\n            request_body: r,\n            method: \"POST\"\n        }));\n    }, t.sendBoostagramToAlbyAccount = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/payments/keysend\",\n            request_body: {\n                destination: \"030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3\",\n                custom_records: {\n                    696969: e.account\n                },\n                amount: e.amount,\n                memo: e.memo\n            },\n            method: \"POST\"\n        }));\n    }, t.createWebhookEndpoint = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/webhook_endpoints\",\n            request_body: e,\n            method: \"POST\"\n        }));\n    }, t.deleteWebhookEndpoint = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/webhook_endpoints/\" + e,\n            method: \"DELETE\"\n        }));\n    }, t.getSwapInfo = function(e) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, e, {\n            endpoint: \"/swaps/info\",\n            method: \"GET\"\n        }));\n    }, t.createSwap = function(e, t) {\n        return q(d({\n            auth: this.auth\n        }, this.defaultRequestOptions, t, {\n            endpoint: \"/swaps\",\n            method: \"POST\",\n            request_body: e\n        }));\n    }, e;\n}(), K = {\n    __proto__: null,\n    auth: F,\n    types: N,\n    utils: E,\n    Client: L\n};\nif (68 !== new Uint8Array(new Uint32Array([\n    287454020\n]).buffer)[0]) throw new Error(\"Non little-endian hardware is not supported\");\nconst B = /* @__PURE__ */ Array.from({\n    length: 256\n}, (e, t)=>t.toString(16).padStart(2, \"0\"));\nfunction J(e) {\n    if (!(e instanceof Uint8Array)) throw new Error(\"Uint8Array expected\");\n    let t = \"\";\n    for(let n = 0; n < e.length; n++)t += B[e[n]];\n    return t;\n}\nfunction H(e) {\n    if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n    const t = e.length;\n    if (t % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + t);\n    const n = new Uint8Array(t / 2);\n    for(let t = 0; t < n.length; t++){\n        const r = 2 * t, o = e.slice(r, r + 2), i = Number.parseInt(o, 16);\n        if (Number.isNaN(i) || i < 0) throw new Error(\"Invalid byte sequence\");\n        n[t] = i;\n    }\n    return n;\n}\nvar z = /*#__PURE__*/ function(e) {\n    function t(t, n) {\n        var r;\n        return (r = e.call(this, t) || this).code = void 0, r.code = n, r;\n    }\n    return v(t, e), t;\n}(/*#__PURE__*/ w(Error)), D = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), G = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), V = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), Y = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(V), X = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(V), Q = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), $ = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), Z = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), ee = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z), te = /*#__PURE__*/ function(e) {\n    function t() {\n        return e.apply(this, arguments) || this;\n    }\n    return v(t, e), t;\n}(z);\nfunction ne(e, t) {\n    try {\n        var n = e();\n    } catch (e) {\n        return t(e);\n    }\n    return n && n.then ? n.then(void 0, t) : n;\n}\nfunction re(e, t, n) {\n    if (!e.s) {\n        if (n instanceof oe) {\n            if (!n.s) return void (n.o = re.bind(null, e, t));\n            1 & t && (t = n.s), n = n.v;\n        }\n        if (n && n.then) return void n.then(re.bind(null, e, t), re.bind(null, e, 2));\n        e.s = t, e.v = n;\n        var r = e.o;\n        r && r(e);\n    }\n}\nvar oe = /*#__PURE__*/ function() {\n    function e() {}\n    return e.prototype.then = function(t, n) {\n        var r = new e, o = this.s;\n        if (o) {\n            var i = 1 & o ? t : n;\n            if (i) {\n                try {\n                    re(r, 1, i(this.v));\n                } catch (e) {\n                    re(r, 2, e);\n                }\n                return r;\n            }\n            return this;\n        }\n        return this.o = function(e) {\n            try {\n                var o = e.v;\n                1 & e.s ? re(r, 1, t ? t(o) : o) : n ? re(r, 1, n(o)) : re(r, 2, o);\n            } catch (e) {\n                re(r, 2, e);\n            }\n        }, r;\n    }, e;\n}();\nfunction ie(e) {\n    return e instanceof oe && 1 & e.s;\n}\nvar se = /*#__PURE__*/ function() {\n    function c(n) {\n        this.relay = void 0, this.relayUrl = void 0, this.secret = void 0, this.lud16 = void 0, this.walletPubkey = void 0, this.options = void 0, this._encryptionType = void 0, n && n.nostrWalletConnectUrl && (n = d({}, c.parseWalletConnectUrl(n.nostrWalletConnectUrl), n)), this.options = d({}, n || {}), this.relayUrl = this.options.relayUrl, this.relay = new (0, $fS6LT.Relay)(this.relayUrl), this.options.secret && (this.secret = this.options.secret.toLowerCase().startsWith(\"nsec\") ? (0, $fS6LT.nip19).decode(this.options.secret).data : this.options.secret), this.lud16 = this.options.lud16, this.walletPubkey = this.options.walletPubkey.toLowerCase().startsWith(\"npub\") ? (0, $fS6LT.nip19).decode(this.options.walletPubkey).data : this.options.walletPubkey, void 0 === globalThis.WebSocket && console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\");\n    }\n    c.parseWalletConnectUrl = function(e) {\n        e = e.replace(\"nostrwalletconnect://\", \"http://\").replace(\"nostr+walletconnect://\", \"http://\").replace(\"nostrwalletconnect:\", \"http://\").replace(\"nostr+walletconnect:\", \"http://\");\n        var t = new URL(e), n = t.searchParams.get(\"relay\");\n        if (!n) throw new Error(\"No relay URL found in connection string\");\n        var r = {\n            walletPubkey: t.host,\n            relayUrl: n\n        }, o = t.searchParams.get(\"secret\");\n        o && (r.secret = o);\n        var i = t.searchParams.get(\"lud16\");\n        return i && (r.lud16 = i), r;\n    };\n    var a = c.prototype;\n    return a.getNostrWalletConnectUrl = function(e) {\n        void 0 === e && (e = !0);\n        var t = \"nostr+walletconnect://\" + this.walletPubkey + \"?relay=\" + this.relayUrl + \"&pubkey=\" + this.publicKey;\n        return e && (t = t + \"&secret=\" + this.secret), this.lud16 && (t = t + \"&lud16=\" + this.lud16), t;\n    }, a.getPublicKey = function() {\n        return Promise.resolve(this.publicKey);\n    }, a.signEvent = function(e) {\n        if (!this.secret) throw new Error(\"Missing secret key\");\n        return Promise.resolve((0, $fS6LT.finalizeEvent)(e, H(this.secret)));\n    }, a.getEventHash = function(e) {\n        return (0, $fS6LT.getEventHash)(e);\n    }, a.close = function() {\n        return this.relay.close();\n    }, a.encrypt = function(e, t) {\n        try {\n            var n, r = this;\n            if (!r.secret) throw new Error(\"Missing secret\");\n            var s = function() {\n                if (\"nip04\" === r.encryptionType) return Promise.resolve((0, $fS6LT.nip04).encrypt(r.secret, e, t)).then(function(e) {\n                    n = e;\n                });\n                var s = (0, $fS6LT.nip44).getConversationKey(H(r.secret), e);\n                n = (0, $fS6LT.nip44).encrypt(t, s);\n            }();\n            return Promise.resolve(s && s.then ? s.then(function() {\n                return n;\n            }) : n);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.decrypt = function(e, t) {\n        try {\n            var n, r = this;\n            if (!r.secret) throw new Error(\"Missing secret\");\n            var s = function() {\n                if (\"nip04\" === r.encryptionType) return Promise.resolve((0, $fS6LT.nip04).decrypt(r.secret, e, t)).then(function(e) {\n                    n = e;\n                });\n                var s = (0, $fS6LT.nip44).getConversationKey(H(r.secret), e);\n                n = (0, $fS6LT.nip44).decrypt(t, s);\n            }();\n            return Promise.resolve(s && s.then ? s.then(function() {\n                return n;\n            }) : n);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, c.getAuthorizationUrl = function(e, t, n) {\n        if (void 0 === t && (t = {}), e.indexOf(\"/#/\") > -1) throw new Error(\"hash router paths not supported\");\n        var r = new URL(e);\n        return t.name && r.searchParams.set(\"name\", t.name), r.searchParams.set(\"pubkey\", n), t.returnTo && r.searchParams.set(\"return_to\", t.returnTo), t.budgetRenewal && r.searchParams.set(\"budget_renewal\", t.budgetRenewal), t.expiresAt && r.searchParams.set(\"expires_at\", Math.floor(t.expiresAt.getTime() / 1e3).toString()), t.maxAmount && r.searchParams.set(\"max_amount\", t.maxAmount.toString()), t.requestMethods && r.searchParams.set(\"request_methods\", t.requestMethods.join(\" \")), t.notificationTypes && r.searchParams.set(\"notification_types\", t.notificationTypes.join(\" \")), t.isolated && r.searchParams.set(\"isolated\", \"true\"), t.metadata && r.searchParams.set(\"metadata\", JSON.stringify(t.metadata)), r;\n    }, c.fromAuthorizationUrl = function(e, t, n) {\n        void 0 === t && (t = {}), n = n || J((0, $fS6LT.generateSecretKey)()), t.name || (t.name = document.location.host);\n        var r = this.getAuthorizationUrl(e, t, (0, $fS6LT.getPublicKey)(H(n))), o = window.outerHeight / 2 + window.screenY - 300, i = window.outerWidth / 2 + window.screenX - 200;\n        return new Promise(function(e, t) {\n            var s = window.open(r.toString(), document.title + \" - Wallet Connect\", \"height=600,width=400,top=\" + o + \",left=\" + i);\n            if (s) {\n                var u = function o(i) {\n                    var u = i.data;\n                    u && \"nwc:success\" === u.type && i.origin === r.protocol + \"//\" + r.host && (u.relayUrl || t(new Error(\"no relayUrl in response\")), u.walletPubkey || t(new Error(\"no walletPubkey in response\")), e(new c({\n                        relayUrl: u.relayUrl,\n                        walletPubkey: u.walletPubkey,\n                        secret: n,\n                        lud16: u.lud16\n                    })), clearInterval(a), window.removeEventListener(\"message\", o), s && s.close());\n                }, a = setInterval(function() {\n                    s && s.closed && (clearInterval(a), window.removeEventListener(\"message\", u), t(new Error(\"Popup closed\")));\n                }, 500);\n                window.addEventListener(\"message\", u);\n            } else t(new Error(\"failed to execute window.open\"));\n        });\n    }, a.getWalletServiceInfo = function() {\n        try {\n            var e = this;\n            return Promise.resolve(e._checkConnected()).then(function() {\n                return Promise.resolve(new Promise(function(t, n) {\n                    var r = [], o = e.relay.subscribe([\n                        {\n                            kinds: [\n                                13194\n                            ],\n                            limit: 1,\n                            authors: [\n                                e.walletPubkey\n                            ]\n                        }\n                    ], {\n                        eoseTimeout: 1e4\n                    });\n                    o.onevent = function(e) {\n                        r.push(e);\n                    }, o.oneose = function() {\n                        o.close(), t(r);\n                    };\n                })).then(function(e) {\n                    var t;\n                    if (!e.length) throw new Error(\"no info event (kind 13194) returned from relay\");\n                    var n = e[0].content, r = e[0].tags.find(function(e) {\n                        return \"notifications\" === e[0];\n                    }), o = e[0].tags.find(function(e) {\n                        return \"v\" === e[0];\n                    }), i = e[0].tags.find(function(e) {\n                        return \"encryption\" === e[0];\n                    }), s = [\n                        \"nip04\"\n                    ];\n                    return o && o[1].includes(\"1.0\") && s.push(\"nip44_v2\"), i && (s = i[1].split(\" \")), {\n                        encryptions: s,\n                        capabilities: n.split(/[ |,]/g),\n                        notifications: (null == r || null == (t = r[1]) ? void 0 : t.split(\" \")) || []\n                    };\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.getInfo = function() {\n        try {\n            var e = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(e.executeNip47Request(\"get_info\", {}, function(e) {\n                    return !!e.methods;\n                }, {\n                    replyTimeout: 1e4\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request get_info\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.getBudget = function() {\n        try {\n            var e = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(e.executeNip47Request(\"get_budget\", {}, function(e) {\n                    return void 0 !== e;\n                }, {\n                    replyTimeout: 1e4\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request get_budget\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.getBalance = function() {\n        try {\n            var e = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(e.executeNip47Request(\"get_balance\", {}, function(e) {\n                    return void 0 !== e.balance;\n                }, {\n                    replyTimeout: 1e4\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request get_balance\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.payInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"pay_invoice\", e, function(e) {\n                    return !!e;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request pay_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.payKeysend = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"pay_keysend\", e, function(e) {\n                    return !!e.preimage;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request pay_keysend\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.signMessage = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"sign_message\", e, function(t) {\n                    return t.message === e.message && !!t.signature;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request sign_message\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.createConnection = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"create_connection\", e, function(e) {\n                    return !!e.wallet_pubkey;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request create_connection\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.multiPayInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeMultiNip47Request(\"multi_pay_invoice\", e, e.invoices.length, function(e) {\n                    return !!e.preimage;\n                })).then(function(e) {\n                    return {\n                        invoices: e,\n                        errors: []\n                    };\n                });\n            }, function(e) {\n                throw console.error(\"Failed to request multi_pay_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.multiPayKeysend = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeMultiNip47Request(\"multi_pay_keysend\", e, e.keysends.length, function(e) {\n                    return !!e.preimage;\n                })).then(function(e) {\n                    return {\n                        keysends: e,\n                        errors: []\n                    };\n                });\n            }, function(e) {\n                throw console.error(\"Failed to request multi_pay_keysend\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.makeInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                if (!e.amount) throw new Error(\"No amount specified\");\n                return Promise.resolve(t.executeNip47Request(\"make_invoice\", e, function(e) {\n                    return !!e.invoice;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request make_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.makeHoldInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                if (!e.amount) throw new Error(\"No amount specified\");\n                if (!e.payment_hash) throw new Error(\"No payment hash specified\");\n                return Promise.resolve(t.executeNip47Request(\"make_hold_invoice\", e, function(e) {\n                    return !!e.invoice;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request make_hold_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.settleHoldInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"settle_hold_invoice\", e, function(e) {\n                    return !!e;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request settle_hold_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.cancelHoldInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"cancel_hold_invoice\", e, function(e) {\n                    return !!e;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request cancel_hold_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.lookupInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"lookup_invoice\", e, function(e) {\n                    return !!e.invoice;\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request lookup_invoice\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.listTransactions = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(ne(function() {\n                return Promise.resolve(t.executeNip47Request(\"list_transactions\", e, function(e) {\n                    return !!e.transactions;\n                }, {\n                    replyTimeout: 1e4\n                }));\n            }, function(e) {\n                throw console.error(\"Failed to request list_transactions\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.subscribeNotifications = function(e, t) {\n        try {\n            var n, r, o, i = this, s = !0;\n            return function() {\n                try {\n                    var u = function(e, t, n) {\n                        for(var r;;){\n                            var o = e();\n                            if (ie(o) && (o = o.v), !o) return i;\n                            if (o.then) {\n                                r = 0;\n                                break;\n                            }\n                            var i = n();\n                            if (i && i.then) {\n                                if (!ie(i)) {\n                                    r = 1;\n                                    break;\n                                }\n                                i = i.s;\n                            }\n                        }\n                        var s = new oe, u = re.bind(null, s, 2);\n                        return (0 === r ? o.then(a) : 1 === r ? i.then(c) : (void 0).then(function() {\n                            (o = e()) ? o.then ? o.then(a).then(void 0, u) : a(o) : re(s, 1, i);\n                        })).then(void 0, u), s;\n                        function c(t) {\n                            i = t;\n                            do {\n                                if (!(o = e()) || ie(o) && !o.v) return void re(s, 1, i);\n                                if (o.then) return void o.then(a).then(void 0, u);\n                                ie(i = n()) && (i = i.v);\n                            }while (!i || !i.then);\n                            i.then(c).then(void 0, u);\n                        }\n                        function a(e) {\n                            e ? (i = n()) && i.then ? i.then(c).then(void 0, u) : c(i) : re(s, 1, i);\n                        }\n                    }(function() {\n                        return !!s;\n                    }, 0, function() {\n                        function u() {\n                            var e = function() {\n                                if (s) return Promise.resolve(new Promise(function(e) {\n                                    return setTimeout(e, 1e3);\n                                })).then(function() {});\n                            }();\n                            if (e && e.then) return e.then(function() {});\n                        }\n                        var c = ne(function() {\n                            return Promise.resolve(i._checkConnected()).then(function() {\n                                return Promise.resolve(i._selectEncryptionType()).then(function() {\n                                    return o = i.relay.subscribe([\n                                        {\n                                            kinds: [].concat(\"nip04\" === i.encryptionType ? [\n                                                23196\n                                            ] : [\n                                                23197\n                                            ]),\n                                            authors: [\n                                                i.walletPubkey\n                                            ],\n                                            \"#p\": [\n                                                i.publicKey\n                                            ]\n                                        }\n                                    ], {}), console.info(\"subscribed to relay\"), o.onevent = function(n) {\n                                        try {\n                                            return Promise.resolve(i.decrypt(i.walletPubkey, n.content)).then(function(n) {\n                                                var r;\n                                                try {\n                                                    r = JSON.parse(n);\n                                                } catch (e) {\n                                                    return void console.error(\"Failed to parse decrypted event content\", e);\n                                                }\n                                                r.notification ? (!t || t.indexOf(r.notification_type) > -1) && e(r) : console.error(\"No notification in response\", r);\n                                            });\n                                        } catch (e) {\n                                            return Promise.reject(e);\n                                        }\n                                    }, Promise.resolve(new Promise(function(e) {\n                                        n = function() {\n                                            e();\n                                        }, i.relay.onclose = r = function() {\n                                            console.info(\"relay disconnected\"), null == n || n();\n                                        };\n                                    })).then(function() {\n                                        void 0 !== r && (i.relay.onclose = null);\n                                    });\n                                });\n                            });\n                        }, function(e) {\n                            console.error(\"error subscribing to notifications\", e || \"unknown relay error\");\n                        });\n                        return c && c.then ? c.then(u) : u();\n                    });\n                    u && u.then && u.then(function() {});\n                } catch (e) {\n                    Promise.reject(e);\n                }\n            }(), Promise.resolve(function() {\n                var e;\n                s = !1, null == n || n(), null == (e = o) || e.close();\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.executeNip47Request = function(e, t, n, r) {\n        try {\n            var o = this;\n            return Promise.resolve(o._checkConnected()).then(function() {\n                return Promise.resolve(o._selectEncryptionType()).then(function() {\n                    return new Promise(function(i, s) {\n                        try {\n                            return Promise.resolve(o.encrypt(o.walletPubkey, JSON.stringify({\n                                method: e,\n                                params: t\n                            }))).then(function(e) {\n                                var t = {\n                                    kind: 23194,\n                                    created_at: Math.floor(Date.now() / 1e3),\n                                    tags: [\n                                        [\n                                            \"p\",\n                                            o.walletPubkey\n                                        ],\n                                        [\n                                            \"v\",\n                                            \"nip44_v2\" === o.encryptionType ? \"1.0\" : \"0.0\"\n                                        ],\n                                        [\n                                            \"encryption\",\n                                            o.encryptionType\n                                        ]\n                                    ],\n                                    content: e\n                                };\n                                return Promise.resolve(o.signEvent(t)).then(function(e) {\n                                    var t = o.relay.subscribe([\n                                        {\n                                            kinds: [\n                                                23195\n                                            ],\n                                            authors: [\n                                                o.walletPubkey\n                                            ],\n                                            \"#e\": [\n                                                e.id\n                                            ]\n                                        }\n                                    ], {}), u = setTimeout(function() {\n                                        t.close(), s(new X(\"reply timeout: event \" + e.id, \"INTERNAL\"));\n                                    }, (null == r ? void 0 : r.replyTimeout) || 6e4);\n                                    t.onevent = function(e) {\n                                        try {\n                                            return clearTimeout(u), t.close(), Promise.resolve(o.decrypt(o.walletPubkey, e.content)).then(function(e) {\n                                                var r, o, c;\n                                                try {\n                                                    r = JSON.parse(e);\n                                                } catch (e) {\n                                                    return clearTimeout(u), t.close(), void s(new $(\"failed to deserialize response\", \"INTERNAL\"));\n                                                }\n                                                r.result ? n(r.result) ? i(r.result) : (clearTimeout(u), t.close(), s(new Z(\"response from NWC failed validation: \" + JSON.stringify(r.result), \"INTERNAL\"))) : (clearTimeout(u), t.close(), s(new G((null == (o = r.error) ? void 0 : o.message) || \"unknown Error\", (null == (c = r.error) ? void 0 : c.code) || \"INTERNAL\")));\n                                            });\n                                        } catch (e) {\n                                            return Promise.reject(e);\n                                        }\n                                    };\n                                    var c = setTimeout(function() {\n                                        t.close(), s(new Y(\"publish timeout: \" + e.id, \"INTERNAL\"));\n                                    }, (null == r ? void 0 : r.publishTimeout) || 5e3), a = ne(function() {\n                                        return Promise.resolve(o.relay.publish(e)).then(function() {\n                                            clearTimeout(c);\n                                        });\n                                    }, function(e) {\n                                        clearTimeout(c), s(new Q(\"failed to publish: \" + e, \"INTERNAL\"));\n                                    });\n                                    if (a && a.then) return a.then(function() {});\n                                });\n                            });\n                        } catch (e) {\n                            Promise.reject(e);\n                        }\n                    });\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a.executeMultiNip47Request = function(e, t, n, r, o) {\n        try {\n            var i = this;\n            return Promise.resolve(i._checkConnected()).then(function() {\n                return Promise.resolve(i._selectEncryptionType()).then(function() {\n                    var s = [];\n                    return new Promise(function(u, c) {\n                        try {\n                            return Promise.resolve(i.encrypt(i.walletPubkey, JSON.stringify({\n                                method: e,\n                                params: t\n                            }))).then(function(e) {\n                                var t = {\n                                    kind: 23194,\n                                    created_at: Math.floor(Date.now() / 1e3),\n                                    tags: [\n                                        [\n                                            \"p\",\n                                            i.walletPubkey\n                                        ],\n                                        [\n                                            \"v\",\n                                            \"nip44_v2\" === i.encryptionType ? \"1.0\" : \"0.0\"\n                                        ],\n                                        [\n                                            \"encryption\",\n                                            i.encryptionType\n                                        ]\n                                    ],\n                                    content: e\n                                };\n                                return Promise.resolve(i.signEvent(t)).then(function(e) {\n                                    var t = i.relay.subscribe([\n                                        {\n                                            kinds: [\n                                                23195\n                                            ],\n                                            authors: [\n                                                i.walletPubkey\n                                            ],\n                                            \"#e\": [\n                                                e.id\n                                            ]\n                                        }\n                                    ], {}), a = setTimeout(function() {\n                                        t.close(), c(new X(\"reply timeout: event \" + e.id, \"INTERNAL\"));\n                                    }, (null == o ? void 0 : o.replyTimeout) || 6e4);\n                                    t.onevent = function(e) {\n                                        try {\n                                            return Promise.resolve(i.decrypt(i.walletPubkey, e.content)).then(function(o) {\n                                                var i;\n                                                try {\n                                                    i = JSON.parse(o);\n                                                } catch (e) {\n                                                    clearTimeout(a), t.close(), c(new $(\"failed to deserialize response\", \"INTERNAL\"));\n                                                }\n                                                if (i.result) {\n                                                    var l;\n                                                    if (!r(i.result)) return clearTimeout(a), t.close(), void c(new Z(\"Response from NWC failed validation: \" + JSON.stringify(i.result), \"INTERNAL\"));\n                                                    var h = null == (l = e.tags.find(function(e) {\n                                                        return \"d\" === e[0];\n                                                    })) ? void 0 : l[1];\n                                                    if (void 0 === h) return clearTimeout(a), t.close(), void c(new Z(\"No d tag found in response event\", \"INTERNAL\"));\n                                                    s.push(d({}, i.result, {\n                                                        dTag: h\n                                                    })), s.length === n && (clearTimeout(a), t.close(), u(s));\n                                                } else {\n                                                    var f, v;\n                                                    clearTimeout(a), t.close(), c(new ee(null == (f = i.error) ? void 0 : f.message, null == (v = i.error) ? void 0 : v.code));\n                                                }\n                                            });\n                                        } catch (e) {\n                                            return Promise.reject(e);\n                                        }\n                                    };\n                                    var l = setTimeout(function() {\n                                        t.close(), c(new Y(\"Publish timeout: \" + e.id, \"INTERNAL\"));\n                                    }, (null == o ? void 0 : o.publishTimeout) || 5e3), h = ne(function() {\n                                        return Promise.resolve(i.relay.publish(e)).then(function() {\n                                            clearTimeout(l);\n                                        });\n                                    }, function(e) {\n                                        clearTimeout(l), c(new Q(\"Failed to publish: \" + e, \"INTERNAL\"));\n                                    });\n                                    if (h && h.then) return h.then(function() {});\n                                });\n                            });\n                        } catch (e) {\n                            Promise.reject(e);\n                        }\n                    });\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a._checkConnected = function() {\n        try {\n            var e = this;\n            if (!e.secret) throw new Error(\"Missing secret key\");\n            if (!e.relayUrl) throw new Error(\"Missing relay url\");\n            return Promise.resolve(ne(function() {\n                var t = function() {\n                    if (!e.relay.connected) return Promise.resolve(e.relay.connect()).then(function() {});\n                }();\n                if (t && t.then) return t.then(function() {});\n            }, function() {\n                throw console.error(\"failed to connect to relay\", e.relayUrl), new D(\"Failed to connect to \" + e.relayUrl, \"OTHER\");\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a._selectEncryptionType = function() {\n        try {\n            var e = this;\n            return Promise.resolve(function() {\n                if (!e._encryptionType) return Promise.resolve(e.getWalletServiceInfo()).then(function(t) {\n                    var n = e._findPreferredEncryptionType(t.encryptions);\n                    if (!n) throw new te(\"no compatible encryption or version found between wallet and client\", \"UNSUPPORTED_ENCRYPTION\");\n                    \"nip04\" === n && console.warn(\"NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead.\"), e._encryptionType = n;\n                });\n            }());\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, a._findPreferredEncryptionType = function(e) {\n        return e.includes(\"nip44_v2\") ? \"nip44_v2\" : e.includes(\"nip04\") ? \"nip04\" : null;\n    }, f(c, [\n        {\n            key: \"nostrWalletConnectUrl\",\n            get: function() {\n                return this.getNostrWalletConnectUrl();\n            }\n        },\n        {\n            key: \"connected\",\n            get: function() {\n                return this.relay.connected;\n            }\n        },\n        {\n            key: \"publicKey\",\n            get: function() {\n                if (!this.secret) throw new Error(\"Missing secret key\");\n                return (0, $fS6LT.getPublicKey)(H(this.secret));\n            }\n        },\n        {\n            key: \"encryptionType\",\n            get: function() {\n                if (!this._encryptionType) throw new Error(\"Missing encryption or version\");\n                return this._encryptionType;\n            }\n        }\n    ]), c;\n}(), ue = {\n    get_info: \"getInfo\",\n    get_balance: \"getBalance\",\n    make_invoice: \"makeInvoice\",\n    pay_invoice: \"sendPayment\",\n    pay_keysend: \"payKeysend\",\n    lookup_invoice: \"lookupInvoice\",\n    list_transactions: \"listTransactions\",\n    multi_pay_invoice: \"sendMultiPayment\",\n    multi_pay_keysend: \"multiKeysend\",\n    sign_message: \"signMessage\"\n}, ce = /*#__PURE__*/ function() {\n    function e(e) {\n        this._enabled = !1, this.client = void 0, this.subscribers = void 0, this.client = (null == e ? void 0 : e.client) || new se(e), this.subscribers = {};\n    }\n    e.fromAuthorizationUrl = function(t, n, r) {\n        void 0 === n && (n = {});\n        try {\n            return Promise.resolve(se.fromAuthorizationUrl(t, n, r)).then(function(t) {\n                return new e({\n                    client: t\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    var t = e.prototype;\n    return t.on = function(e, t) {\n        this.subscribers[e] = t;\n    }, t.notify = function(e, t) {\n        var n = this.subscribers[e];\n        n && n(t);\n    }, t.getPublicKey = function() {\n        return this.client.getPublicKey();\n    }, t.signEvent = function(e) {\n        return this.client.signEvent(e);\n    }, t.enable = function() {\n        try {\n            return this._enabled = !0, Promise.resolve();\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.close = function() {\n        return this.client.close();\n    }, t.getInfo = function() {\n        try {\n            var e = this;\n            return Promise.resolve(e.checkEnabled()).then(function() {\n                var t = [\n                    \"lightning\",\n                    \"nostr\"\n                ], n = \"Alby JS SDK\";\n                return function(r, o) {\n                    try {\n                        var i = Promise.resolve(e.client.getInfo()).then(function(r) {\n                            var o = {\n                                methods: r.methods.map(function(e) {\n                                    return ue[e];\n                                }),\n                                node: {\n                                    alias: r.alias,\n                                    pubkey: r.pubkey,\n                                    color: r.color\n                                },\n                                supports: t,\n                                version: n\n                            };\n                            return e.notify(\"getInfo\", o), o;\n                        });\n                    } catch (e) {\n                        return o(e);\n                    }\n                    return i && i.then ? i.then(void 0, o) : i;\n                }(0, function(e) {\n                    return console.error(\"Using minimal getInfo\", e), {\n                        methods: [\n                            \"sendPayment\"\n                        ],\n                        node: {},\n                        supports: t,\n                        version: n\n                    };\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.getBalance = function() {\n        try {\n            var e = this;\n            return Promise.resolve(e.checkEnabled()).then(function() {\n                return Promise.resolve(e.client.getBalance()).then(function(t) {\n                    var n = {\n                        balance: Math.floor(t.balance / 1e3),\n                        currency: \"sats\"\n                    };\n                    return e.notify(\"getBalance\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.sendPayment = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.payInvoice({\n                    invoice: e\n                })).then(function(e) {\n                    var n = {\n                        preimage: e.preimage\n                    };\n                    return t.notify(\"sendPayment\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.sendPaymentAsync = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return t.client.payInvoice({\n                    invoice: e\n                }), t.notify(\"sendPaymentAsync\", {}), {};\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.keysend = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.payKeysend(le(e))).then(function(e) {\n                    var n = {\n                        preimage: e.preimage\n                    };\n                    return t.notify(\"keysend\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.signMessage = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.signMessage({\n                    message: e\n                })).then(function(e) {\n                    var n = {\n                        message: e.message,\n                        signature: e.signature\n                    };\n                    return t.notify(\"keysend\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.makeInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                var n, r = \"object\" == typeof e ? e : void 0, o = +(null != (n = null == r ? void 0 : r.amount) ? n : e);\n                if (!o) throw new Error(\"No amount specified\");\n                return Promise.resolve(t.client.makeInvoice({\n                    amount: 1e3 * o,\n                    description: null == r ? void 0 : r.defaultMemo\n                })).then(function(e) {\n                    var n = {\n                        paymentRequest: e.invoice\n                    };\n                    return t.notify(\"makeInvoice\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.lookupInvoice = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.lookupInvoice({\n                    invoice: e.paymentRequest,\n                    payment_hash: e.paymentHash\n                })).then(function(e) {\n                    var n = {\n                        preimage: e.preimage,\n                        paymentRequest: e.invoice,\n                        paid: !!e.settled_at\n                    };\n                    return t.notify(\"lookupInvoice\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.listTransactions = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.listTransactions(e)).then(function(e) {\n                    var n = {\n                        transactions: e.transactions.map(ae)\n                    };\n                    return t.notify(\"listTransactions\", n), n;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.sendMultiPayment = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.multiPayInvoice({\n                    invoices: e.map(function(e, t) {\n                        return {\n                            invoice: e,\n                            id: t.toString()\n                        };\n                    })\n                })).then(function(n) {\n                    var r = {\n                        payments: n.invoices.map(function(t) {\n                            var n = e[parseInt(t.dTag)];\n                            if (!n) throw new Error(\"Could not find paymentRequest matching response d tag\");\n                            return {\n                                paymentRequest: n,\n                                preimage: t.preimage\n                            };\n                        }),\n                        errors: []\n                    };\n                    return t.notify(\"sendMultiPayment\", r), r;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.multiKeysend = function(e) {\n        try {\n            var t = this;\n            return Promise.resolve(t.checkEnabled()).then(function() {\n                return Promise.resolve(t.client.multiPayKeysend({\n                    keysends: e.map(function(e, t) {\n                        return d({}, le(e), {\n                            id: t.toString()\n                        });\n                    })\n                })).then(function(n) {\n                    var r = {\n                        keysends: n.keysends.map(function(t) {\n                            var n = e[parseInt(t.dTag)];\n                            if (!n) throw new Error(\"Could not find keysend matching response d tag\");\n                            return {\n                                keysend: n,\n                                preimage: t.preimage\n                            };\n                        }),\n                        errors: []\n                    };\n                    return t.notify(\"multiKeysend\", r), r;\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.lnurl = function(e) {\n        throw new Error(\"Method not implemented.\");\n    }, t.request = function(e, t) {\n        throw new Error(\"Method not implemented.\");\n    }, t.verifyMessage = function(e, t) {\n        throw new Error(\"Method not implemented.\");\n    }, t.checkEnabled = function() {\n        try {\n            if (!this._enabled) throw new Error(\"please call enable() and await the promise before calling this function\");\n            return Promise.resolve();\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, f(e, [\n        {\n            key: \"options\",\n            get: function() {\n                return this.client.options;\n            }\n        }\n    ]), e;\n}();\nfunction ae(e) {\n    return d({}, e, {\n        amount: Math.floor(e.amount / 1e3),\n        fees_paid: e.fees_paid ? Math.floor(e.fees_paid / 1e3) : 0\n    });\n}\nfunction le(e) {\n    return {\n        amount: 1e3 * +e.amount,\n        pubkey: e.destination,\n        tlv_records: e.customRecords ? Object.entries(e.customRecords).map(function(e) {\n            return {\n                type: parseInt(e[0]),\n                value: I((new TextEncoder).encode(e[1]))\n            };\n        }) : []\n    };\n}\nfunction he(e, t) {\n    try {\n        var n = e();\n    } catch (e) {\n        return t(!0, e);\n    }\n    return n && n.then ? n.then(t.bind(null, !1), t.bind(null, !0)) : t(!1, n);\n}\nfunction fe(e, t) {\n    try {\n        var n = e();\n    } catch (e) {\n        return t(e);\n    }\n    return n && n.then ? n.then(void 0, t) : n;\n}\nvar de = {\n    __proto__: null,\n    NostrWebLNProvider: ce,\n    NWC: ce,\n    OauthWeblnProvider: /*#__PURE__*/ function() {\n        function e(e) {\n            this.client = void 0, this.auth = void 0, this.oauth = void 0, this.subscribers = void 0, this.isExecuting = void 0, this.auth = e.auth, this.client = new L(e.auth), this.oauth = !0, this.subscribers = {}, this.isExecuting = !1;\n        }\n        var t = e.prototype;\n        return t.on = function(e, t) {\n            this.subscribers[e] = t;\n        }, t.notify = function(e, t) {\n            var n = this.subscribers[e];\n            n && n(t);\n        }, t.enable = function() {\n            try {\n                var e, t = this;\n                return t.isExecuting ? Promise.resolve() : null != (e = t.auth.token) && e.access_token ? Promise.resolve({\n                    enabled: !0\n                }) : Promise.resolve(function() {\n                    if (\"undefined\" == typeof window || void 0 === window.document) throw new Error(\"Missing access token\");\n                    var e = he(function() {\n                        return t.isExecuting = !0, Promise.resolve(t.openAuthorization()).then(function() {});\n                    }, function(e, n) {\n                        if (t.isExecuting = !1, e) throw n;\n                        return n;\n                    });\n                    if (e && e.then) return e.then(function() {});\n                }());\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, t.sendPayment = function(e) {\n            try {\n                var t = this;\n                return t.isExecuting ? Promise.resolve() : Promise.resolve(he(function() {\n                    return fe(function() {\n                        return t.isExecuting = !0, Promise.resolve(t.client.sendPayment({\n                            invoice: e\n                        })).then(function(e) {\n                            return t.notify(\"sendPayment\", e), {\n                                preimage: e.payment_preimage\n                            };\n                        });\n                    }, function(e) {\n                        var t = \"Unknown Error\";\n                        throw e instanceof Error && (t = e.message), new Error(t);\n                    });\n                }, function(e, n) {\n                    if (t.isExecuting = !1, e) throw n;\n                    return n;\n                }));\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, t.keysend = function(e) {\n            try {\n                var t = this;\n                return t.isExecuting ? Promise.resolve() : Promise.resolve(he(function() {\n                    return fe(function() {\n                        return t.isExecuting = !0, Promise.resolve(t.client.keysend(e)).then(function(e) {\n                            return t.notify(\"keysend\", e), {\n                                preimage: e.payment_preimage\n                            };\n                        });\n                    }, function(e) {\n                        var t = \"Unknown Error\";\n                        throw e instanceof Error && (t = e.message), new Error(t);\n                    });\n                }, function(e, n) {\n                    if (t.isExecuting = !1, e) throw n;\n                    return n;\n                }));\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, t.getInfo = function() {\n            try {\n                return Promise.resolve({\n                    alias: \"Alby\"\n                });\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, t.makeInvoice = function(e) {\n            try {\n                var t = this;\n                return t.isExecuting ? Promise.resolve() : Promise.resolve(he(function() {\n                    return fe(function() {\n                        return t.isExecuting = !0, Promise.resolve(t.client.createInvoice({\n                            amount: parseInt(e.amount.toString()),\n                            description: e.defaultMemo\n                        })).then(function(e) {\n                            return t.notify(\"makeInvoice\", e), {\n                                paymentRequest: e.payment_request\n                            };\n                        });\n                    }, function(e) {\n                        var t = \"Unknown Error\";\n                        throw e instanceof Error && (t = e.message), new Error(t);\n                    });\n                }, function(e, n) {\n                    if (t.isExecuting = !1, e) throw n;\n                    return n;\n                }));\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, t.openAuthorization = function() {\n            try {\n                var e = this, t = window.outerHeight / 2 + window.screenY - 350, n = window.outerWidth / 2 + window.screenX - 300;\n                return Promise.resolve(e.auth.generateAuthURL({\n                    code_challenge_method: \"S256\"\n                })).then(function(r) {\n                    return new Promise(function(o, i) {\n                        var s = window.open(r, document.title + \" - WebLN enable\", \"height=700,width=600,top=\" + t + \",left=\" + n), u = !1;\n                        window.addEventListener(\"message\", function(t) {\n                            try {\n                                var n = t.data, r = function() {\n                                    if (n && \"alby:oauth:success\" === n.type && t.origin === document.location.protocol + \"//\" + document.location.host && !u) {\n                                        u = !0, console.info(\"Processing OAuth code response\");\n                                        var r = n.payload.code, c = fe(function() {\n                                            return Promise.resolve(e.auth.requestAccessToken(r)).then(function() {\n                                                e.client = new L(e.auth), s && s.close(), e.notify(\"enable\"), o({\n                                                    enabled: !0\n                                                });\n                                            });\n                                        }, function(e) {\n                                            console.error(e), i({\n                                                enabled: !1\n                                            });\n                                        });\n                                        if (c && c.then) return c.then(function() {});\n                                    }\n                                }();\n                                return Promise.resolve(r && r.then ? r.then(function() {}) : void 0);\n                            } catch (e) {\n                                return Promise.reject(e);\n                            }\n                        });\n                    });\n                });\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        }, e;\n    }()\n};\nfunction ve(e, t) {\n    try {\n        var n = e();\n    } catch (e) {\n        return t(e);\n    }\n    return n && n.then ? n.then(void 0, t) : n;\n}\nfunction pe(e, t, n) {\n    if (!e.s) {\n        if (n instanceof me) {\n            if (!n.s) return void (n.o = pe.bind(null, e, t));\n            1 & t && (t = n.s), n = n.v;\n        }\n        if (n && n.then) return void n.then(pe.bind(null, e, t), pe.bind(null, e, 2));\n        e.s = t, e.v = n;\n        var r = e.o;\n        r && r(e);\n    }\n}\nvar me = /*#__PURE__*/ function() {\n    function e() {}\n    return e.prototype.then = function(t, n) {\n        var r = new e, o = this.s;\n        if (o) {\n            var i = 1 & o ? t : n;\n            if (i) {\n                try {\n                    pe(r, 1, i(this.v));\n                } catch (e) {\n                    pe(r, 2, e);\n                }\n                return r;\n            }\n            return this;\n        }\n        return this.o = function(e) {\n            try {\n                var o = e.v;\n                1 & e.s ? pe(r, 1, t ? t(o) : o) : n ? pe(r, 1, n(o)) : pe(r, 2, o);\n            } catch (e) {\n                pe(r, 2, e);\n            }\n        }, r;\n    }, e;\n}();\nfunction ye(e) {\n    return e instanceof me && 1 & e.s;\n}\nvar Pe = /*#__PURE__*/ function() {\n    function t(t) {\n        if (this.options = void 0, this.appSecretKey = void 0, this.relay = void 0, this.appSecretKey = t.appSecretKey || J((0, $fS6LT.generateSecretKey)()), this.options = d({}, t, {\n            appPubkey: (0, $fS6LT.getPublicKey)(H(this.appSecretKey))\n        }), !this.options.relayUrl) throw new Error(\"Missing relay url\");\n        if (!this.options.requestMethods) throw new Error(\"Missing request methods\");\n        this.relay = new (0, $fS6LT.Relay)(this.options.relayUrl), void 0 === globalThis.WebSocket && console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\");\n    }\n    var n = t.prototype;\n    return n.getConnectionUri = function(e) {\n        void 0 === e && (e = \"\");\n        var t = new URLSearchParams(d({\n            relay: this.options.relayUrl,\n            request_methods: this.options.requestMethods.join(\" \")\n        }, this.options.name ? {\n            name: this.options.name\n        } : {}, this.options.icon ? {\n            icon: this.options.icon\n        } : {}, this.options.returnTo ? {\n            return_to: this.options.returnTo\n        } : {}, this.options.notificationTypes ? {\n            notification_types: this.options.notificationTypes.join(\" \")\n        } : {}, this.options.maxAmount ? {\n            max_amount: this.options.maxAmount.toString()\n        } : {}, this.options.budgetRenewal ? {\n            budget_renewal: this.options.budgetRenewal\n        } : {}, this.options.expiresAt ? {\n            expires_at: this.options.expiresAt.toString()\n        } : {}, this.options.isolated ? {\n            isolated: this.options.isolated.toString()\n        } : {}, this.options.metadata ? {\n            metadata: JSON.stringify(this.options.metadata)\n        } : {}));\n        return \"nostr+walletauth\" + (e ? \"+\" + e : \"\") + \"://\" + this.options.appPubkey + \"?\" + t.toString().replace(/\\+/g, \"%20\");\n    }, t.parseWalletAuthUrl = function(e) {\n        var t, n;\n        if (!e.startsWith(\"nostr+walletauth\")) throw new Error(\"Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://\");\n        var r = e.indexOf(\":\");\n        (e = e.substring(r + 1)).startsWith(\"//\") && (e = e.substring(2)), e = \"http://\" + e;\n        var o = new URL(e), i = o.host;\n        if (64 !== (null == i ? void 0 : i.length)) throw new Error(\"Incorrect app pubkey found in auth string\");\n        var s = o.searchParams.get(\"relay\");\n        if (!s) throw new Error(\"No relay URL found in auth string\");\n        var u = null == (t = o.searchParams.get(\"request_methods\")) ? void 0 : t.split(\" \");\n        if (null == u || !u.length) throw new Error(\"No request methods found in auth string\");\n        var c = null == (n = o.searchParams.get(\"notification_types\")) ? void 0 : n.split(\" \"), a = o.searchParams.get(\"max_amount\"), l = o.searchParams.get(\"expires_at\"), h = o.searchParams.get(\"metadata\");\n        return {\n            name: o.searchParams.get(\"name\") || void 0,\n            icon: o.searchParams.get(\"icon\") || void 0,\n            returnTo: o.searchParams.get(\"return_to\") || void 0,\n            relayUrl: s,\n            appPubkey: i,\n            requestMethods: u,\n            notificationTypes: c,\n            budgetRenewal: o.searchParams.get(\"budget_renewal\"),\n            expiresAt: l ? parseInt(l) : void 0,\n            maxAmount: a ? parseInt(a) : void 0,\n            isolated: \"true\" === o.searchParams.get(\"isolated\"),\n            metadata: h ? JSON.parse(h) : void 0\n        };\n    }, n.subscribe = function(e) {\n        try {\n            var t, n, r = this, o = !0;\n            return function() {\n                try {\n                    var i = function(e, t, n) {\n                        for(var r;;){\n                            var o = e();\n                            if (ye(o) && (o = o.v), !o) return i;\n                            if (o.then) {\n                                r = 0;\n                                break;\n                            }\n                            var i = n();\n                            if (i && i.then) {\n                                if (!ye(i)) {\n                                    r = 1;\n                                    break;\n                                }\n                                i = i.s;\n                            }\n                        }\n                        var s = new me, u = pe.bind(null, s, 2);\n                        return (0 === r ? o.then(a) : 1 === r ? i.then(c) : (void 0).then(function() {\n                            (o = e()) ? o.then ? o.then(a).then(void 0, u) : a(o) : pe(s, 1, i);\n                        })).then(void 0, u), s;\n                        function c(t) {\n                            i = t;\n                            do {\n                                if (!(o = e()) || ye(o) && !o.v) return void pe(s, 1, i);\n                                if (o.then) return void o.then(a).then(void 0, u);\n                                ye(i = n()) && (i = i.v);\n                            }while (!i || !i.then);\n                            i.then(c).then(void 0, u);\n                        }\n                        function a(e) {\n                            e ? (i = n()) && i.then ? i.then(c).then(void 0, u) : c(i) : pe(s, 1, i);\n                        }\n                    }(function() {\n                        return !!o;\n                    }, 0, function() {\n                        function i() {\n                            var e = function() {\n                                if (o) return Promise.resolve(new Promise(function(e) {\n                                    return setTimeout(e, 1e3);\n                                })).then(function() {});\n                            }();\n                            if (e && e.then) return e.then(function() {});\n                        }\n                        var s = ve(function() {\n                            return Promise.resolve(r._checkConnected()).then(function() {\n                                var o = r.relay.subscribe([\n                                    {\n                                        kinds: [\n                                            13194\n                                        ],\n                                        \"#p\": [\n                                            r.options.appPubkey\n                                        ]\n                                    }\n                                ], {});\n                                return console.info(\"subscribed to relay\"), o.onevent = function(t) {\n                                    try {\n                                        var n = function() {\n                                            e.onSuccess(i), o.close(), r.relay.close();\n                                        }, i = new se({\n                                            relayUrl: r.options.relayUrl,\n                                            secret: r.appSecretKey,\n                                            walletPubkey: t.pubkey\n                                        }), s = ve(function() {\n                                            return Promise.resolve(i.getInfo()).then(function(e) {\n                                                i.options.lud16 = e.lud16, i.lud16 = e.lud16;\n                                            });\n                                        }, function(e) {\n                                            console.error(\"failed to fetch get_info\", e);\n                                        });\n                                        return Promise.resolve(s && s.then ? s.then(n) : n());\n                                    } catch (e) {\n                                        return Promise.reject(e);\n                                    }\n                                }, Promise.resolve(new Promise(function(e) {\n                                    t = function() {\n                                        e();\n                                    }, r.relay.onclose = n = function() {\n                                        console.info(\"relay disconnected\"), null == t || t();\n                                    };\n                                })).then(function() {\n                                    void 0 !== n && (r.relay.onclose = null);\n                                });\n                            });\n                        }, function(e) {\n                            console.error(\"error subscribing to info event\", e || \"unknown relay error\");\n                        });\n                        return s && s.then ? s.then(i) : i();\n                    });\n                    i && i.then && i.then(function() {});\n                } catch (e) {\n                    Promise.reject(e);\n                }\n            }(), Promise.resolve({\n                unsub: function() {\n                    o = !1, null == t || t();\n                }\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, n._checkConnected = function() {\n        try {\n            var e = this;\n            if (!e.appSecretKey) throw new Error(\"Missing secret key\");\n            if (!e.options.relayUrl) throw new Error(\"Missing relay url\");\n            return Promise.resolve(ve(function() {\n                var t = function() {\n                    if (!e.relay.connected) return Promise.resolve(e.relay.connect()).then(function() {});\n                }();\n                if (t && t.then) return t.then(function() {});\n            }, function() {\n                throw console.error(\"failed to connect to relay\", e.options.relayUrl), new D(\"Failed to connect to \" + e.options.relayUrl, \"OTHER\");\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, f(t, [\n        {\n            key: \"connectionUri\",\n            get: function() {\n                return this.getConnectionUri();\n            }\n        }\n    ]), t;\n}();\nfunction we(e, t) {\n    try {\n        var n = e();\n    } catch (e) {\n        return t(e);\n    }\n    return n && n.then ? n.then(void 0, t) : n;\n}\nfunction ge(e, t, n) {\n    if (!e.s) {\n        if (n instanceof be) {\n            if (!n.s) return void (n.o = ge.bind(null, e, t));\n            1 & t && (t = n.s), n = n.v;\n        }\n        if (n && n.then) return void n.then(ge.bind(null, e, t), ge.bind(null, e, 2));\n        e.s = t, e.v = n;\n        var r = e.o;\n        r && r(e);\n    }\n}\nvar be = /*#__PURE__*/ function() {\n    function e() {}\n    return e.prototype.then = function(t, n) {\n        var r = new e, o = this.s;\n        if (o) {\n            var i = 1 & o ? t : n;\n            if (i) {\n                try {\n                    ge(r, 1, i(this.v));\n                } catch (e) {\n                    ge(r, 2, e);\n                }\n                return r;\n            }\n            return this;\n        }\n        return this.o = function(e) {\n            try {\n                var o = e.v;\n                1 & e.s ? ge(r, 1, t ? t(o) : o) : n ? ge(r, 1, n(o)) : ge(r, 2, o);\n            } catch (e) {\n                ge(r, 2, e);\n            }\n        }, r;\n    }, e;\n}();\nfunction _e(e) {\n    return e instanceof be && 1 & e.s;\n}\nvar ke = /*#__PURE__*/ function() {\n    function t(t) {\n        this.relay = void 0, this.relayUrl = void 0, this.relayUrl = t.relayUrl, this.relay = new (0, $fS6LT.Relay)(this.relayUrl), void 0 === globalThis.WebSocket && console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\");\n    }\n    var r = t.prototype;\n    return r.publishWalletServiceInfoEvent = function(e, t, n) {\n        try {\n            var r = this;\n            return Promise.resolve(we(function() {\n                return Promise.resolve(r._checkConnected()).then(function() {\n                    var o = {\n                        kind: 13194,\n                        created_at: Math.floor(Date.now() / 1e3),\n                        tags: [\n                            [\n                                \"encryption\",\n                                \"nip04 nip44_v2\"\n                            ],\n                            [\n                                \"notifications\",\n                                n.join(\" \")\n                            ]\n                        ],\n                        content: t.join(\" \")\n                    };\n                    return Promise.resolve(r.signEvent(o, e)).then(function(e) {\n                        return Promise.resolve(r.relay.publish(e)).then(function() {});\n                    });\n                });\n            }, function(e) {\n                throw console.error(\"failed to publish wallet service info event\", e), e;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, r.subscribe = function(e, t) {\n        try {\n            var n, r, o, i = this, s = !0;\n            return function() {\n                try {\n                    var u = function(e, t, n) {\n                        for(var r;;){\n                            var o = e();\n                            if (_e(o) && (o = o.v), !o) return i;\n                            if (o.then) {\n                                r = 0;\n                                break;\n                            }\n                            var i = n();\n                            if (i && i.then) {\n                                if (!_e(i)) {\n                                    r = 1;\n                                    break;\n                                }\n                                i = i.s;\n                            }\n                        }\n                        var s = new be, u = ge.bind(null, s, 2);\n                        return (0 === r ? o.then(a) : 1 === r ? i.then(c) : (void 0).then(function() {\n                            (o = e()) ? o.then ? o.then(a).then(void 0, u) : a(o) : ge(s, 1, i);\n                        })).then(void 0, u), s;\n                        function c(t) {\n                            i = t;\n                            do {\n                                if (!(o = e()) || _e(o) && !o.v) return void ge(s, 1, i);\n                                if (o.then) return void o.then(a).then(void 0, u);\n                                _e(i = n()) && (i = i.v);\n                            }while (!i || !i.then);\n                            i.then(c).then(void 0, u);\n                        }\n                        function a(e) {\n                            e ? (i = n()) && i.then ? i.then(c).then(void 0, u) : c(i) : ge(s, 1, i);\n                        }\n                    }(function() {\n                        return !!s;\n                    }, 0, function() {\n                        function u() {\n                            var e = function() {\n                                if (s) return Promise.resolve(new Promise(function(e) {\n                                    return setTimeout(e, 1e3);\n                                })).then(function() {});\n                            }();\n                            if (e && e.then) return e.then(function() {});\n                        }\n                        var c = we(function() {\n                            return console.info(\"checking connection to relay\"), Promise.resolve(i._checkConnected()).then(function() {\n                                return console.info(\"subscribing to relay\"), o = i.relay.subscribe([\n                                    {\n                                        kinds: [\n                                            23194\n                                        ],\n                                        authors: [\n                                            e.clientPubkey\n                                        ],\n                                        \"#p\": [\n                                            e.walletPubkey\n                                        ]\n                                    }\n                                ], {}), console.info(\"subscribed to relay\"), o.onevent = function(n) {\n                                    try {\n                                        var r = we(function() {\n                                            var r, o = (null == (r = n.tags.find(function(e) {\n                                                return \"encryption\" === e[0];\n                                            })) ? void 0 : r[1]) || \"nip04\";\n                                            return Promise.resolve(i.decrypt(e, n.content, o)).then(function(r) {\n                                                var s, u = JSON.parse(r);\n                                                switch(u.method){\n                                                    case \"get_info\":\n                                                        s = null == t.getInfo ? void 0 : t.getInfo();\n                                                        break;\n                                                    case \"make_invoice\":\n                                                        s = null == t.makeInvoice ? void 0 : t.makeInvoice(u.params);\n                                                        break;\n                                                    case \"pay_invoice\":\n                                                        s = null == t.payInvoice ? void 0 : t.payInvoice(u.params);\n                                                        break;\n                                                    case \"pay_keysend\":\n                                                        s = null == t.payKeysend ? void 0 : t.payKeysend(u.params);\n                                                        break;\n                                                    case \"get_balance\":\n                                                        s = null == t.getBalance ? void 0 : t.getBalance();\n                                                        break;\n                                                    case \"lookup_invoice\":\n                                                        s = null == t.lookupInvoice ? void 0 : t.lookupInvoice(u.params);\n                                                        break;\n                                                    case \"list_transactions\":\n                                                        s = null == t.listTransactions ? void 0 : t.listTransactions(u.params);\n                                                        break;\n                                                    case \"sign_message\":\n                                                        s = null == t.signMessage ? void 0 : t.signMessage(u.params);\n                                                }\n                                                return Promise.resolve(s).then(function(t) {\n                                                    t || (console.warn(\"received unsupported method\", u.method), t = {\n                                                        error: {\n                                                            code: \"NOT_IMPLEMENTED\",\n                                                            message: \"This method is not supported by the wallet service\"\n                                                        },\n                                                        result: void 0\n                                                    });\n                                                    var r = [\n                                                        [\n                                                            \"e\",\n                                                            n.id\n                                                        ]\n                                                    ], s = Math.floor(Date.now() / 1e3);\n                                                    return Promise.resolve(i.encrypt(e, JSON.stringify(d({\n                                                        result_type: u.method\n                                                    }, t)), o)).then(function(t) {\n                                                        return Promise.resolve(i.signEvent({\n                                                            kind: 23195,\n                                                            created_at: s,\n                                                            tags: r,\n                                                            content: t\n                                                        }, e.walletSecret)).then(function(e) {\n                                                            return Promise.resolve(i.relay.publish(e)).then(function() {});\n                                                        });\n                                                    });\n                                                });\n                                            });\n                                        }, function(e) {\n                                            console.error(\"Failed to parse decrypted event content\", e);\n                                        });\n                                        return Promise.resolve(r && r.then ? r.then(function() {}) : void 0);\n                                    } catch (e) {\n                                        return Promise.reject(e);\n                                    }\n                                }, Promise.resolve(new Promise(function(e) {\n                                    n = function() {\n                                        e();\n                                    }, i.relay.onclose = r = function() {\n                                        console.error(\"relay disconnected\"), null == n || n();\n                                    };\n                                })).then(function() {\n                                    void 0 !== r && (i.relay.onclose = null);\n                                });\n                            });\n                        }, function(e) {\n                            console.error(\"error subscribing to requests\", e || \"unknown relay error\");\n                        });\n                        return c && c.then ? c.then(u) : u();\n                    });\n                    u && u.then && u.then(function() {});\n                } catch (e) {\n                    Promise.reject(e);\n                }\n            }(), Promise.resolve(function() {\n                var e;\n                s = !1, null == n || n(), null == (e = o) || e.close();\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, r.signEvent = function(e, t) {\n        return Promise.resolve((0, $fS6LT.finalizeEvent)(e, H(t)));\n    }, r.close = function() {\n        return this.relay.close();\n    }, r.encrypt = function(e, t, n) {\n        try {\n            var r, s = function() {\n                if (\"nip04\" === n) return Promise.resolve((0, $fS6LT.nip04).encrypt(e.walletSecret, e.clientPubkey, t)).then(function(e) {\n                    r = e;\n                });\n                var s = (0, $fS6LT.nip44).getConversationKey(H(e.walletSecret), e.clientPubkey);\n                r = (0, $fS6LT.nip44).encrypt(t, s);\n            }();\n            return Promise.resolve(s && s.then ? s.then(function() {\n                return r;\n            }) : r);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, r.decrypt = function(e, t, n) {\n        try {\n            var r, s = function() {\n                if (\"nip04\" === n) return Promise.resolve((0, $fS6LT.nip04).decrypt(e.walletSecret, e.clientPubkey, t)).then(function(e) {\n                    r = e;\n                });\n                var s = (0, $fS6LT.nip44).getConversationKey(H(e.walletSecret), e.clientPubkey);\n                r = (0, $fS6LT.nip44).decrypt(t, s);\n            }();\n            return Promise.resolve(s && s.then ? s.then(function() {\n                return r;\n            }) : r);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, r._checkConnected = function() {\n        try {\n            var e = this;\n            if (!e.relayUrl) throw new Error(\"Missing relay url\");\n            return Promise.resolve(we(function() {\n                var t = function() {\n                    if (!e.relay.connected) return Promise.resolve(e.relay.connect()).then(function() {});\n                }();\n                if (t && t.then) return t.then(function() {});\n            }, function() {\n                throw console.error(\"failed to connect to relay\", e.relayUrl), new D(\"Failed to connect to \" + e.relayUrl, \"OTHER\");\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, f(t, [\n        {\n            key: \"connected\",\n            get: function() {\n                return this.relay.connected;\n            }\n        }\n    ]), t;\n}(), Ee = {\n    __proto__: null,\n    Nip47Error: z,\n    Nip47NetworkError: D,\n    Nip47WalletError: G,\n    Nip47TimeoutError: V,\n    Nip47PublishTimeoutError: Y,\n    Nip47ReplyTimeoutError: X,\n    Nip47PublishError: Q,\n    Nip47ResponseDecodingError: $,\n    Nip47ResponseValidationError: Z,\n    Nip47UnexpectedResponseError: ee,\n    Nip47UnsupportedEncryptionError: te,\n    NWCClient: se,\n    NWAClient: Pe,\n    NWCWalletServiceKeyPair: function(e, t) {\n        if (this.walletSecret = void 0, this.walletPubkey = void 0, this.clientPubkey = void 0, this.walletSecret = e, this.clientPubkey = t, !this.walletSecret) throw new Error(\"Missing wallet secret key\");\n        if (!this.clientPubkey) throw new Error(\"Missing client pubkey\");\n        this.walletPubkey = (0, $fS6LT.getPublicKey)(H(this.walletSecret));\n    },\n    NWCWalletService: ke\n};\nfunction Te(e, t, n) {\n    if (!e.s) {\n        if (n instanceof Ne) {\n            if (!n.s) return void (n.o = Te.bind(null, e, t));\n            1 & t && (t = n.s), n = n.v;\n        }\n        if (n && n.then) return void n.then(Te.bind(null, e, t), Te.bind(null, e, 2));\n        e.s = t, e.v = n;\n        var r = e.o;\n        r && r(e);\n    }\n}\nvar Ne = /*#__PURE__*/ function() {\n    function e() {}\n    return e.prototype.then = function(t, n) {\n        var r = new e, o = this.s;\n        if (o) {\n            var i = 1 & o ? t : n;\n            if (i) {\n                try {\n                    Te(r, 1, i(this.v));\n                } catch (e) {\n                    Te(r, 2, e);\n                }\n                return r;\n            }\n            return this;\n        }\n        return this.o = function(e) {\n            try {\n                var o = e.v;\n                1 & e.s ? Te(r, 1, t ? t(o) : o) : n ? Te(r, 1, n(o)) : Te(r, 2, o);\n            } catch (e) {\n                Te(r, 2, e);\n            }\n        }, r;\n    }, e;\n}();\nfunction je(e) {\n    return e instanceof Ne && 1 & e.s;\n}\nvar qe = /*#__PURE__*/ function() {\n    function e(e, t) {\n        this.transaction = void 0, this.invoice = void 0, this._nwcClient = void 0, this._unsubscribeFunc = void 0, this._timeoutFunc = void 0, this._timeoutId = void 0, this.transaction = t, this.invoice = new (0, $imRk1.Invoice)({\n            pr: t.invoice\n        }), this._nwcClient = e;\n    }\n    var t = e.prototype;\n    return t.onPaid = function(e) {\n        var t = this;\n        return function() {\n            try {\n                var n, r = function() {\n                    var r = function(n) {\n                        null == t._unsubscribeFunc || t._unsubscribeFunc(), e(n);\n                    }, o = function(e) {\n                        return function() {\n                            t._timeoutFunc = void 0, clearTimeout(t._timeoutId), e();\n                        };\n                    }, i = function() {\n                        if (n) return Promise.resolve(t._nwcClient.subscribeNotifications(function(e) {\n                            e.notification.payment_hash === t.transaction.payment_hash && r(e.notification);\n                        }, [\n                            \"payment_received\"\n                        ])).then(function(e) {\n                            t._unsubscribeFunc = o(e);\n                        });\n                        console.warn(\"current connection does not support notifications, falling back to polling\"), t._unsubscribeFunc = o(t._onPaidPollingFallback(r));\n                    }();\n                    if (i && i.then) return i.then(function() {});\n                }, o = function(e, r) {\n                    try {\n                        var o = Promise.resolve(t._nwcClient.getInfo()).then(function(e) {\n                            var t;\n                            n = null == (t = e.notifications) ? void 0 : t.includes(\"payment_received\");\n                        });\n                    } catch (e) {\n                        return r();\n                    }\n                    return o && o.then ? o.then(void 0, r) : o;\n                }(0, function() {\n                    console.error(\"failed to fetch info, falling back to polling\");\n                });\n                o && o.then ? o.then(r) : r();\n            } catch (e) {\n                Promise.reject(e);\n            }\n        }(), this;\n    }, t.onTimeout = function(e, t) {\n        var n = this;\n        return this._timeoutFunc = function() {\n            null == n._unsubscribeFunc || n._unsubscribeFunc(), t();\n        }, this._timeoutId = setTimeout(function() {\n            null == n._timeoutFunc || n._timeoutFunc();\n        }, 1e3 * e), this;\n    }, t.unsubscribe = function() {\n        var e;\n        null == (e = this._unsubscribeFunc) || e.call(this);\n    }, t._onPaidPollingFallback = function(e) {\n        var t = this, n = !0;\n        return function(r) {\n            try {\n                var o = function(e, t, n) {\n                    for(var r;;){\n                        var o = e();\n                        if (je(o) && (o = o.v), !o) return i;\n                        if (o.then) {\n                            r = 0;\n                            break;\n                        }\n                        var i = n();\n                        if (i && i.then) {\n                            if (!je(i)) {\n                                r = 1;\n                                break;\n                            }\n                            i = i.s;\n                        }\n                    }\n                    var s = new Ne, u = Te.bind(null, s, 2);\n                    return (0 === r ? o.then(a) : 1 === r ? i.then(c) : (void 0).then(function() {\n                        (o = e()) ? o.then ? o.then(a).then(void 0, u) : a(o) : Te(s, 1, i);\n                    })).then(void 0, u), s;\n                    function c(t) {\n                        i = t;\n                        do {\n                            if (!(o = e()) || je(o) && !o.v) return void Te(s, 1, i);\n                            if (o.then) return void o.then(a).then(void 0, u);\n                            je(i = n()) && (i = i.v);\n                        }while (!i || !i.then);\n                        i.then(c).then(void 0, u);\n                    }\n                    function a(e) {\n                        e ? (i = n()) && i.then ? i.then(c).then(void 0, u) : c(i) : Te(s, 1, i);\n                    }\n                }(function() {\n                    return !r && !!n;\n                }, 0, function() {\n                    return Promise.resolve(t._nwcClient.lookupInvoice({\n                        payment_hash: t.transaction.payment_hash\n                    })).then(function(t) {\n                        return t.settled_at && t.preimage ? (e(t), n = !1, void (r = 1)) : Promise.resolve(new Promise(function(e) {\n                            return setTimeout(e, 3e3);\n                        })).then(function() {});\n                    });\n                });\n                o && o.then && o.then(function() {});\n            } catch (e) {\n                Promise.reject(e);\n            }\n        }(), function() {\n            n = !1;\n        };\n    }, e;\n}(), Re = function(e) {\n    try {\n        return \"number\" == typeof e ? Promise.resolve({\n            satoshi: e,\n            millisat: 1e3 * e\n        }) : Promise.resolve(Promise.resolve(e.satoshi)).then(function(e) {\n            return {\n                satoshi: e,\n                millisat: 1e3 * e\n            };\n        });\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, Se = function(e) {\n    return {\n        satoshi: e\n    };\n}, Oe = /*#__PURE__*/ function() {\n    function e(e) {\n        this.nwcClient = void 0, this.nwcClient = \"string\" == typeof e ? new se({\n            nostrWalletConnectUrl: e\n        }) : e instanceof se ? e : new se(e);\n    }\n    var t = e.prototype;\n    return t.pay = function(e, t, n) {\n        try {\n            var r = function(t) {\n                function r(e) {\n                    return Promise.resolve(o.nwcClient.payInvoice(d({}, n || {}, {\n                        invoice: i,\n                        amount: null == t ? void 0 : t.millisat\n                    }))).then(function(e) {\n                        return d({}, e, {\n                            invoice: new (0, $imRk1.Invoice)({\n                                pr: i\n                            })\n                        });\n                    });\n                }\n                var s = function() {\n                    if (i.indexOf(\"@\") > -1) {\n                        if (!t) throw new Error(\"Amount must be provided when paying to a lightning address\");\n                        var r = new (0, $imRk1.LightningAddress)(e);\n                        return Promise.resolve(r.fetch()).then(function() {\n                            var e, o;\n                            return Promise.resolve(r.requestInvoice({\n                                satoshi: t.satoshi,\n                                comment: null == n || null == (e = n.metadata) ? void 0 : e.comment,\n                                payerdata: null == n || null == (o = n.metadata) ? void 0 : o.payer_data\n                            })).then(function(e) {\n                                i = e.paymentRequest;\n                            });\n                        });\n                    }\n                }();\n                return s && s.then ? s.then(r) : r();\n            }, o = this, i = e;\n            return Promise.resolve(t ? Promise.resolve(Re(t)).then(r) : r(void 0));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.requestPayment = function(e, t) {\n        try {\n            var n = this;\n            return Promise.resolve(Re(e)).then(function(e) {\n                return Promise.resolve(n.nwcClient.makeInvoice(d({}, t || {}, {\n                    amount: e.millisat\n                }))).then(function(e) {\n                    return new qe(n.nwcClient, e);\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.close = function() {\n        this.nwcClient.close();\n    }, e;\n}(), Ie = function(e, t) {\n    this.satoshi = void 0, this.satoshi = (0, $imRk1.fiat).getSatoshiValue({\n        amount: e,\n        currency: t\n    });\n}, xe = function(e) {\n    return new Ie(e, \"USD\");\n}, Ae = function(e) {\n    return new Ie(e, \"EUR\");\n}, Ue = function(e) {\n    return new Ie(e, \"JPY\");\n}, Ce = function(e) {\n    return new Ie(e, \"GBP\");\n}, Me = function(e) {\n    return new Ie(e, \"CHF\");\n};\n\n});\nparcelRegister(\"fS6LT\", function(module, exports) {\n\n$parcel$export(module.exports, \"getEventHash\", () => $b8e126da42a4b9e3$export$11a838ad4e557e0e);\n$parcel$export(module.exports, \"generateSecretKey\", () => $b8e126da42a4b9e3$export$16ca411381fc81c8);\n$parcel$export(module.exports, \"getPublicKey\", () => $b8e126da42a4b9e3$export$889def73691f9837);\n$parcel$export(module.exports, \"finalizeEvent\", () => $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20);\n$parcel$export(module.exports, \"Relay\", () => $b8e126da42a4b9e3$export$325be0d991c73dc2);\n$parcel$export(module.exports, \"nip19\", () => $b8e126da42a4b9e3$export$10660ae21dbef115);\n$parcel$export(module.exports, \"nip04\", () => $b8e126da42a4b9e3$export$4793e42c2cc9b120);\n$parcel$export(module.exports, \"nip44\", () => $b8e126da42a4b9e3$export$7f3384dd63301b54);\n\nvar $5r7db = parcelRequire(\"5r7db\");\n\nvar $3Bcdj = parcelRequire(\"3Bcdj\");\n\nvar $6XnWx = parcelRequire(\"6XnWx\");\n\nvar $4Dsex = parcelRequire(\"4Dsex\");\n\nvar $3RPiR = parcelRequire(\"3RPiR\");\n\nvar $lAjhr = parcelRequire(\"lAjhr\");\n\nvar $38xio = parcelRequire(\"38xio\");\n\nvar $aN9nT = parcelRequire(\"aN9nT\");\n\nvar $70Xw9 = parcelRequire(\"70Xw9\");\nvar $b8e126da42a4b9e3$var$__defProp = Object.defineProperty;\nvar $b8e126da42a4b9e3$var$__export = (target, all)=>{\n    for(var name in all)$b8e126da42a4b9e3$var$__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\n// core.ts\nvar $b8e126da42a4b9e3$export$31a1b605a7b8e0bf = Symbol(\"verified\");\nvar $b8e126da42a4b9e3$var$isRecord = (obj)=>obj instanceof Object;\nfunction $b8e126da42a4b9e3$export$d08d852dd562b1ce(event) {\n    if (!$b8e126da42a4b9e3$var$isRecord(event)) return false;\n    if (typeof event.kind !== \"number\") return false;\n    if (typeof event.content !== \"string\") return false;\n    if (typeof event.created_at !== \"number\") return false;\n    if (typeof event.pubkey !== \"string\") return false;\n    if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false;\n    if (!Array.isArray(event.tags)) return false;\n    for(let i2 = 0; i2 < event.tags.length; i2++){\n        let tag = event.tags[i2];\n        if (!Array.isArray(tag)) return false;\n        for(let j = 0; j < tag.length; j++){\n            if (typeof tag[j] !== \"string\") return false;\n        }\n    }\n    return true;\n}\nfunction $b8e126da42a4b9e3$export$d425309ca6befbaf(events) {\n    return events.sort((a, b)=>{\n        if (a.created_at !== b.created_at) return b.created_at - a.created_at;\n        return a.id.localeCompare(b.id);\n    });\n}\n// utils.ts\nvar $b8e126da42a4b9e3$export$eab97d15b1788b8d = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$eab97d15b1788b8d, {\n    Queue: ()=>$b8e126da42a4b9e3$var$Queue,\n    QueueNode: ()=>$b8e126da42a4b9e3$var$QueueNode,\n    binarySearch: ()=>$b8e126da42a4b9e3$var$binarySearch,\n    bytesToHex: ()=>(0, $3Bcdj.bytesToHex),\n    hexToBytes: ()=>(0, $3Bcdj.hexToBytes),\n    insertEventIntoAscendingList: ()=>$b8e126da42a4b9e3$var$insertEventIntoAscendingList,\n    insertEventIntoDescendingList: ()=>$b8e126da42a4b9e3$var$insertEventIntoDescendingList,\n    normalizeURL: ()=>$b8e126da42a4b9e3$var$normalizeURL,\n    utf8Decoder: ()=>$b8e126da42a4b9e3$var$utf8Decoder,\n    utf8Encoder: ()=>$b8e126da42a4b9e3$var$utf8Encoder\n});\nvar $b8e126da42a4b9e3$var$utf8Decoder = new TextDecoder(\"utf-8\");\nvar $b8e126da42a4b9e3$var$utf8Encoder = new TextEncoder();\nfunction $b8e126da42a4b9e3$var$normalizeURL(url) {\n    try {\n        if (url.indexOf(\"://\") === -1) url = \"wss://\" + url;\n        let p = new URL(url);\n        p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n        if (p.pathname.endsWith(\"/\")) p.pathname = p.pathname.slice(0, -1);\n        if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\") p.port = \"\";\n        p.searchParams.sort();\n        p.hash = \"\";\n        return p.toString();\n    } catch (e) {\n        throw new Error(`Invalid URL: ${url}`);\n    }\n}\nfunction $b8e126da42a4b9e3$var$insertEventIntoDescendingList(sortedArray, event) {\n    const [idx, found] = $b8e126da42a4b9e3$var$binarySearch(sortedArray, (b)=>{\n        if (event.id === b.id) return 0;\n        if (event.created_at === b.created_at) return -1;\n        return b.created_at - event.created_at;\n    });\n    if (!found) sortedArray.splice(idx, 0, event);\n    return sortedArray;\n}\nfunction $b8e126da42a4b9e3$var$insertEventIntoAscendingList(sortedArray, event) {\n    const [idx, found] = $b8e126da42a4b9e3$var$binarySearch(sortedArray, (b)=>{\n        if (event.id === b.id) return 0;\n        if (event.created_at === b.created_at) return -1;\n        return event.created_at - b.created_at;\n    });\n    if (!found) sortedArray.splice(idx, 0, event);\n    return sortedArray;\n}\nfunction $b8e126da42a4b9e3$var$binarySearch(arr, compare) {\n    let start = 0;\n    let end = arr.length - 1;\n    while(start <= end){\n        const mid = Math.floor((start + end) / 2);\n        const cmp = compare(arr[mid]);\n        if (cmp === 0) return [\n            mid,\n            true\n        ];\n        if (cmp < 0) end = mid - 1;\n        else start = mid + 1;\n    }\n    return [\n        start,\n        false\n    ];\n}\nvar $b8e126da42a4b9e3$var$QueueNode = class {\n    value;\n    next = null;\n    prev = null;\n    constructor(message){\n        this.value = message;\n    }\n};\nvar $b8e126da42a4b9e3$var$Queue = class {\n    first;\n    last;\n    constructor(){\n        this.first = null;\n        this.last = null;\n    }\n    enqueue(value) {\n        const newNode = new $b8e126da42a4b9e3$var$QueueNode(value);\n        if (!this.last) {\n            this.first = newNode;\n            this.last = newNode;\n        } else if (this.last === this.first) {\n            this.last = newNode;\n            this.last.prev = this.first;\n            this.first.next = newNode;\n        } else {\n            newNode.prev = this.last;\n            this.last.next = newNode;\n            this.last = newNode;\n        }\n        return true;\n    }\n    dequeue() {\n        if (!this.first) return null;\n        if (this.first === this.last) {\n            const target2 = this.first;\n            this.first = null;\n            this.last = null;\n            return target2.value;\n        }\n        const target = this.first;\n        this.first = target.next;\n        if (this.first) this.first.prev = null;\n        return target.value;\n    }\n};\n// pure.ts\nvar $b8e126da42a4b9e3$var$JS = class {\n    generateSecretKey() {\n        return (0, $5r7db.schnorr).utils.randomPrivateKey();\n    }\n    getPublicKey(secretKey) {\n        return (0, $3Bcdj.bytesToHex)((0, $5r7db.schnorr).getPublicKey(secretKey));\n    }\n    finalizeEvent(t, secretKey) {\n        const event = t;\n        event.pubkey = (0, $3Bcdj.bytesToHex)((0, $5r7db.schnorr).getPublicKey(secretKey));\n        event.id = $b8e126da42a4b9e3$export$11a838ad4e557e0e(event);\n        event.sig = (0, $3Bcdj.bytesToHex)((0, $5r7db.schnorr).sign($b8e126da42a4b9e3$export$11a838ad4e557e0e(event), secretKey));\n        event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] = true;\n        return event;\n    }\n    verifyEvent(event) {\n        if (typeof event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] === \"boolean\") return event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf];\n        const hash = $b8e126da42a4b9e3$export$11a838ad4e557e0e(event);\n        if (hash !== event.id) {\n            event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] = false;\n            return false;\n        }\n        try {\n            const valid = (0, $5r7db.schnorr).verify(event.sig, hash, event.pubkey);\n            event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] = valid;\n            return valid;\n        } catch (err) {\n            event[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] = false;\n            return false;\n        }\n    }\n};\nfunction $b8e126da42a4b9e3$export$d32d86987f616a9e(evt) {\n    if (!$b8e126da42a4b9e3$export$d08d852dd562b1ce(evt)) throw new Error(\"can't serialize event with wrong or missing properties\");\n    return JSON.stringify([\n        0,\n        evt.pubkey,\n        evt.created_at,\n        evt.kind,\n        evt.tags,\n        evt.content\n    ]);\n}\nfunction $b8e126da42a4b9e3$export$11a838ad4e557e0e(event) {\n    let eventHash = (0, $6XnWx.sha256)($b8e126da42a4b9e3$var$utf8Encoder.encode($b8e126da42a4b9e3$export$d32d86987f616a9e(event)));\n    return (0, $3Bcdj.bytesToHex)(eventHash);\n}\nvar $b8e126da42a4b9e3$var$i = new $b8e126da42a4b9e3$var$JS();\nvar $b8e126da42a4b9e3$export$16ca411381fc81c8 = $b8e126da42a4b9e3$var$i.generateSecretKey;\nvar $b8e126da42a4b9e3$export$889def73691f9837 = $b8e126da42a4b9e3$var$i.getPublicKey;\nvar $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20 = $b8e126da42a4b9e3$var$i.finalizeEvent;\nvar $b8e126da42a4b9e3$export$909d658b5069e986 = $b8e126da42a4b9e3$var$i.verifyEvent;\n// kinds.ts\nvar $b8e126da42a4b9e3$export$9ef7793a01f1f377 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$9ef7793a01f1f377, {\n    Application: ()=>$b8e126da42a4b9e3$var$Application,\n    BadgeAward: ()=>$b8e126da42a4b9e3$var$BadgeAward,\n    BadgeDefinition: ()=>$b8e126da42a4b9e3$var$BadgeDefinition,\n    BlockedRelaysList: ()=>$b8e126da42a4b9e3$var$BlockedRelaysList,\n    BookmarkList: ()=>$b8e126da42a4b9e3$var$BookmarkList,\n    Bookmarksets: ()=>$b8e126da42a4b9e3$var$Bookmarksets,\n    Calendar: ()=>$b8e126da42a4b9e3$var$Calendar,\n    CalendarEventRSVP: ()=>$b8e126da42a4b9e3$var$CalendarEventRSVP,\n    ChannelCreation: ()=>$b8e126da42a4b9e3$var$ChannelCreation,\n    ChannelHideMessage: ()=>$b8e126da42a4b9e3$var$ChannelHideMessage,\n    ChannelMessage: ()=>$b8e126da42a4b9e3$var$ChannelMessage,\n    ChannelMetadata: ()=>$b8e126da42a4b9e3$var$ChannelMetadata,\n    ChannelMuteUser: ()=>$b8e126da42a4b9e3$var$ChannelMuteUser,\n    ClassifiedListing: ()=>$b8e126da42a4b9e3$var$ClassifiedListing,\n    ClientAuth: ()=>$b8e126da42a4b9e3$var$ClientAuth,\n    CommunitiesList: ()=>$b8e126da42a4b9e3$var$CommunitiesList,\n    CommunityDefinition: ()=>$b8e126da42a4b9e3$var$CommunityDefinition,\n    CommunityPostApproval: ()=>$b8e126da42a4b9e3$var$CommunityPostApproval,\n    Contacts: ()=>$b8e126da42a4b9e3$var$Contacts,\n    CreateOrUpdateProduct: ()=>$b8e126da42a4b9e3$var$CreateOrUpdateProduct,\n    CreateOrUpdateStall: ()=>$b8e126da42a4b9e3$var$CreateOrUpdateStall,\n    Curationsets: ()=>$b8e126da42a4b9e3$var$Curationsets,\n    Date: ()=>$b8e126da42a4b9e3$var$Date2,\n    DirectMessageRelaysList: ()=>$b8e126da42a4b9e3$var$DirectMessageRelaysList,\n    DraftClassifiedListing: ()=>$b8e126da42a4b9e3$var$DraftClassifiedListing,\n    DraftLong: ()=>$b8e126da42a4b9e3$var$DraftLong,\n    Emojisets: ()=>$b8e126da42a4b9e3$var$Emojisets,\n    EncryptedDirectMessage: ()=>$b8e126da42a4b9e3$var$EncryptedDirectMessage,\n    EventDeletion: ()=>$b8e126da42a4b9e3$var$EventDeletion,\n    FileMetadata: ()=>$b8e126da42a4b9e3$var$FileMetadata,\n    FileServerPreference: ()=>$b8e126da42a4b9e3$var$FileServerPreference,\n    Followsets: ()=>$b8e126da42a4b9e3$var$Followsets,\n    GenericRepost: ()=>$b8e126da42a4b9e3$var$GenericRepost,\n    Genericlists: ()=>$b8e126da42a4b9e3$var$Genericlists,\n    GiftWrap: ()=>$b8e126da42a4b9e3$var$GiftWrap,\n    HTTPAuth: ()=>$b8e126da42a4b9e3$var$HTTPAuth,\n    Handlerinformation: ()=>$b8e126da42a4b9e3$var$Handlerinformation,\n    Handlerrecommendation: ()=>$b8e126da42a4b9e3$var$Handlerrecommendation,\n    Highlights: ()=>$b8e126da42a4b9e3$var$Highlights,\n    InterestsList: ()=>$b8e126da42a4b9e3$var$InterestsList,\n    Interestsets: ()=>$b8e126da42a4b9e3$var$Interestsets,\n    JobFeedback: ()=>$b8e126da42a4b9e3$var$JobFeedback,\n    JobRequest: ()=>$b8e126da42a4b9e3$var$JobRequest,\n    JobResult: ()=>$b8e126da42a4b9e3$var$JobResult,\n    Label: ()=>$b8e126da42a4b9e3$var$Label,\n    LightningPubRPC: ()=>$b8e126da42a4b9e3$var$LightningPubRPC,\n    LiveChatMessage: ()=>$b8e126da42a4b9e3$var$LiveChatMessage,\n    LiveEvent: ()=>$b8e126da42a4b9e3$var$LiveEvent,\n    LongFormArticle: ()=>$b8e126da42a4b9e3$var$LongFormArticle,\n    Metadata: ()=>$b8e126da42a4b9e3$var$Metadata,\n    Mutelist: ()=>$b8e126da42a4b9e3$var$Mutelist,\n    NWCWalletInfo: ()=>$b8e126da42a4b9e3$var$NWCWalletInfo,\n    NWCWalletRequest: ()=>$b8e126da42a4b9e3$var$NWCWalletRequest,\n    NWCWalletResponse: ()=>$b8e126da42a4b9e3$var$NWCWalletResponse,\n    NostrConnect: ()=>$b8e126da42a4b9e3$var$NostrConnect,\n    OpenTimestamps: ()=>$b8e126da42a4b9e3$var$OpenTimestamps,\n    Pinlist: ()=>$b8e126da42a4b9e3$var$Pinlist,\n    PrivateDirectMessage: ()=>$b8e126da42a4b9e3$var$PrivateDirectMessage,\n    ProblemTracker: ()=>$b8e126da42a4b9e3$var$ProblemTracker,\n    ProfileBadges: ()=>$b8e126da42a4b9e3$var$ProfileBadges,\n    PublicChatsList: ()=>$b8e126da42a4b9e3$var$PublicChatsList,\n    Reaction: ()=>$b8e126da42a4b9e3$var$Reaction,\n    RecommendRelay: ()=>$b8e126da42a4b9e3$var$RecommendRelay,\n    RelayList: ()=>$b8e126da42a4b9e3$var$RelayList,\n    Relaysets: ()=>$b8e126da42a4b9e3$var$Relaysets,\n    Report: ()=>$b8e126da42a4b9e3$var$Report,\n    Reporting: ()=>$b8e126da42a4b9e3$var$Reporting,\n    Repost: ()=>$b8e126da42a4b9e3$var$Repost,\n    Seal: ()=>$b8e126da42a4b9e3$var$Seal,\n    SearchRelaysList: ()=>$b8e126da42a4b9e3$var$SearchRelaysList,\n    ShortTextNote: ()=>$b8e126da42a4b9e3$var$ShortTextNote,\n    Time: ()=>$b8e126da42a4b9e3$var$Time,\n    UserEmojiList: ()=>$b8e126da42a4b9e3$var$UserEmojiList,\n    UserStatuses: ()=>$b8e126da42a4b9e3$var$UserStatuses,\n    Zap: ()=>$b8e126da42a4b9e3$var$Zap,\n    ZapGoal: ()=>$b8e126da42a4b9e3$var$ZapGoal,\n    ZapRequest: ()=>$b8e126da42a4b9e3$var$ZapRequest,\n    classifyKind: ()=>$b8e126da42a4b9e3$var$classifyKind,\n    isAddressableKind: ()=>$b8e126da42a4b9e3$var$isAddressableKind,\n    isEphemeralKind: ()=>$b8e126da42a4b9e3$var$isEphemeralKind,\n    isKind: ()=>$b8e126da42a4b9e3$var$isKind,\n    isRegularKind: ()=>$b8e126da42a4b9e3$var$isRegularKind,\n    isReplaceableKind: ()=>$b8e126da42a4b9e3$var$isReplaceableKind\n});\nfunction $b8e126da42a4b9e3$var$isRegularKind(kind) {\n    return 1e3 <= kind && kind < 1e4 || [\n        1,\n        2,\n        4,\n        5,\n        6,\n        7,\n        8,\n        16,\n        40,\n        41,\n        42,\n        43,\n        44\n    ].includes(kind);\n}\nfunction $b8e126da42a4b9e3$var$isReplaceableKind(kind) {\n    return [\n        0,\n        3\n    ].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction $b8e126da42a4b9e3$var$isEphemeralKind(kind) {\n    return 2e4 <= kind && kind < 3e4;\n}\nfunction $b8e126da42a4b9e3$var$isAddressableKind(kind) {\n    return 3e4 <= kind && kind < 4e4;\n}\nfunction $b8e126da42a4b9e3$var$classifyKind(kind) {\n    if ($b8e126da42a4b9e3$var$isRegularKind(kind)) return \"regular\";\n    if ($b8e126da42a4b9e3$var$isReplaceableKind(kind)) return \"replaceable\";\n    if ($b8e126da42a4b9e3$var$isEphemeralKind(kind)) return \"ephemeral\";\n    if ($b8e126da42a4b9e3$var$isAddressableKind(kind)) return \"parameterized\";\n    return \"unknown\";\n}\nfunction $b8e126da42a4b9e3$var$isKind(event, kind) {\n    const kindAsArray = kind instanceof Array ? kind : [\n        kind\n    ];\n    return $b8e126da42a4b9e3$export$d08d852dd562b1ce(event) && kindAsArray.includes(event.kind) || false;\n}\nvar $b8e126da42a4b9e3$var$Metadata = 0;\nvar $b8e126da42a4b9e3$var$ShortTextNote = 1;\nvar $b8e126da42a4b9e3$var$RecommendRelay = 2;\nvar $b8e126da42a4b9e3$var$Contacts = 3;\nvar $b8e126da42a4b9e3$var$EncryptedDirectMessage = 4;\nvar $b8e126da42a4b9e3$var$EventDeletion = 5;\nvar $b8e126da42a4b9e3$var$Repost = 6;\nvar $b8e126da42a4b9e3$var$Reaction = 7;\nvar $b8e126da42a4b9e3$var$BadgeAward = 8;\nvar $b8e126da42a4b9e3$var$Seal = 13;\nvar $b8e126da42a4b9e3$var$PrivateDirectMessage = 14;\nvar $b8e126da42a4b9e3$var$GenericRepost = 16;\nvar $b8e126da42a4b9e3$var$ChannelCreation = 40;\nvar $b8e126da42a4b9e3$var$ChannelMetadata = 41;\nvar $b8e126da42a4b9e3$var$ChannelMessage = 42;\nvar $b8e126da42a4b9e3$var$ChannelHideMessage = 43;\nvar $b8e126da42a4b9e3$var$ChannelMuteUser = 44;\nvar $b8e126da42a4b9e3$var$OpenTimestamps = 1040;\nvar $b8e126da42a4b9e3$var$GiftWrap = 1059;\nvar $b8e126da42a4b9e3$var$FileMetadata = 1063;\nvar $b8e126da42a4b9e3$var$LiveChatMessage = 1311;\nvar $b8e126da42a4b9e3$var$ProblemTracker = 1971;\nvar $b8e126da42a4b9e3$var$Report = 1984;\nvar $b8e126da42a4b9e3$var$Reporting = 1984;\nvar $b8e126da42a4b9e3$var$Label = 1985;\nvar $b8e126da42a4b9e3$var$CommunityPostApproval = 4550;\nvar $b8e126da42a4b9e3$var$JobRequest = 5999;\nvar $b8e126da42a4b9e3$var$JobResult = 6999;\nvar $b8e126da42a4b9e3$var$JobFeedback = 7e3;\nvar $b8e126da42a4b9e3$var$ZapGoal = 9041;\nvar $b8e126da42a4b9e3$var$ZapRequest = 9734;\nvar $b8e126da42a4b9e3$var$Zap = 9735;\nvar $b8e126da42a4b9e3$var$Highlights = 9802;\nvar $b8e126da42a4b9e3$var$Mutelist = 1e4;\nvar $b8e126da42a4b9e3$var$Pinlist = 10001;\nvar $b8e126da42a4b9e3$var$RelayList = 10002;\nvar $b8e126da42a4b9e3$var$BookmarkList = 10003;\nvar $b8e126da42a4b9e3$var$CommunitiesList = 10004;\nvar $b8e126da42a4b9e3$var$PublicChatsList = 10005;\nvar $b8e126da42a4b9e3$var$BlockedRelaysList = 10006;\nvar $b8e126da42a4b9e3$var$SearchRelaysList = 10007;\nvar $b8e126da42a4b9e3$var$InterestsList = 10015;\nvar $b8e126da42a4b9e3$var$UserEmojiList = 10030;\nvar $b8e126da42a4b9e3$var$DirectMessageRelaysList = 10050;\nvar $b8e126da42a4b9e3$var$FileServerPreference = 10096;\nvar $b8e126da42a4b9e3$var$NWCWalletInfo = 13194;\nvar $b8e126da42a4b9e3$var$LightningPubRPC = 21e3;\nvar $b8e126da42a4b9e3$var$ClientAuth = 22242;\nvar $b8e126da42a4b9e3$var$NWCWalletRequest = 23194;\nvar $b8e126da42a4b9e3$var$NWCWalletResponse = 23195;\nvar $b8e126da42a4b9e3$var$NostrConnect = 24133;\nvar $b8e126da42a4b9e3$var$HTTPAuth = 27235;\nvar $b8e126da42a4b9e3$var$Followsets = 3e4;\nvar $b8e126da42a4b9e3$var$Genericlists = 30001;\nvar $b8e126da42a4b9e3$var$Relaysets = 30002;\nvar $b8e126da42a4b9e3$var$Bookmarksets = 30003;\nvar $b8e126da42a4b9e3$var$Curationsets = 30004;\nvar $b8e126da42a4b9e3$var$ProfileBadges = 30008;\nvar $b8e126da42a4b9e3$var$BadgeDefinition = 30009;\nvar $b8e126da42a4b9e3$var$Interestsets = 30015;\nvar $b8e126da42a4b9e3$var$CreateOrUpdateStall = 30017;\nvar $b8e126da42a4b9e3$var$CreateOrUpdateProduct = 30018;\nvar $b8e126da42a4b9e3$var$LongFormArticle = 30023;\nvar $b8e126da42a4b9e3$var$DraftLong = 30024;\nvar $b8e126da42a4b9e3$var$Emojisets = 30030;\nvar $b8e126da42a4b9e3$var$Application = 30078;\nvar $b8e126da42a4b9e3$var$LiveEvent = 30311;\nvar $b8e126da42a4b9e3$var$UserStatuses = 30315;\nvar $b8e126da42a4b9e3$var$ClassifiedListing = 30402;\nvar $b8e126da42a4b9e3$var$DraftClassifiedListing = 30403;\nvar $b8e126da42a4b9e3$var$Date2 = 31922;\nvar $b8e126da42a4b9e3$var$Time = 31923;\nvar $b8e126da42a4b9e3$var$Calendar = 31924;\nvar $b8e126da42a4b9e3$var$CalendarEventRSVP = 31925;\nvar $b8e126da42a4b9e3$var$Handlerrecommendation = 31989;\nvar $b8e126da42a4b9e3$var$Handlerinformation = 31990;\nvar $b8e126da42a4b9e3$var$CommunityDefinition = 34550;\n// filter.ts\nfunction $b8e126da42a4b9e3$export$c6f8482e724e56c5(filter, event) {\n    if (filter.ids && filter.ids.indexOf(event.id) === -1) return false;\n    if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) return false;\n    if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) return false;\n    for(let f in filter)if (f[0] === \"#\") {\n        let tagName = f.slice(1);\n        let values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v])=>t === f.slice(1) && values.indexOf(v) !== -1)) return false;\n    }\n    if (filter.since && event.created_at < filter.since) return false;\n    if (filter.until && event.created_at > filter.until) return false;\n    return true;\n}\nfunction $b8e126da42a4b9e3$export$4bbf3f173cb9a4eb(filters, event) {\n    for(let i2 = 0; i2 < filters.length; i2++){\n        if ($b8e126da42a4b9e3$export$c6f8482e724e56c5(filters[i2], event)) return true;\n    }\n    return false;\n}\nfunction $b8e126da42a4b9e3$export$aa787302ec03bf2a(...filters) {\n    let result = {};\n    for(let i2 = 0; i2 < filters.length; i2++){\n        let filter = filters[i2];\n        Object.entries(filter).forEach(([property, values])=>{\n            if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n                result[property] = result[property] || [];\n                for(let v = 0; v < values.length; v++){\n                    let value = values[v];\n                    if (!result[property].includes(value)) result[property].push(value);\n                }\n            }\n        });\n        if (filter.limit && (!result.limit || filter.limit > result.limit)) result.limit = filter.limit;\n        if (filter.until && (!result.until || filter.until > result.until)) result.until = filter.until;\n        if (filter.since && (!result.since || filter.since < result.since)) result.since = filter.since;\n    }\n    return result;\n}\nfunction $b8e126da42a4b9e3$export$74b8728d117779ba(filter) {\n    if (filter.ids && !filter.ids.length) return 0;\n    if (filter.kinds && !filter.kinds.length) return 0;\n    if (filter.authors && !filter.authors.length) return 0;\n    for (const [key, value] of Object.entries(filter)){\n        if (key[0] === \"#\" && Array.isArray(value) && !value.length) return 0;\n    }\n    return Math.min(Math.max(0, filter.limit ?? Infinity), filter.ids?.length ?? Infinity, filter.authors?.length && filter.kinds?.every((kind)=>$b8e126da42a4b9e3$var$isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity, filter.authors?.length && filter.kinds?.every((kind)=>$b8e126da42a4b9e3$var$isAddressableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity);\n}\n// fakejson.ts\nvar $b8e126da42a4b9e3$export$7712baafc4f0e06e = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$7712baafc4f0e06e, {\n    getHex64: ()=>$b8e126da42a4b9e3$var$getHex64,\n    getInt: ()=>$b8e126da42a4b9e3$var$getInt,\n    getSubscriptionId: ()=>$b8e126da42a4b9e3$var$getSubscriptionId,\n    matchEventId: ()=>$b8e126da42a4b9e3$var$matchEventId,\n    matchEventKind: ()=>$b8e126da42a4b9e3$var$matchEventKind,\n    matchEventPubkey: ()=>$b8e126da42a4b9e3$var$matchEventPubkey\n});\nfunction $b8e126da42a4b9e3$var$getHex64(json, field) {\n    let len = field.length + 3;\n    let idx = json.indexOf(`\"${field}\":`) + len;\n    let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n    return json.slice(s, s + 64);\n}\nfunction $b8e126da42a4b9e3$var$getInt(json, field) {\n    let len = field.length;\n    let idx = json.indexOf(`\"${field}\":`) + len + 3;\n    let sliced = json.slice(idx);\n    let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n    return parseInt(sliced.slice(0, end), 10);\n}\nfunction $b8e126da42a4b9e3$var$getSubscriptionId(json) {\n    let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n    if (idx === -1) return null;\n    let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n    if (pstart === -1) return null;\n    let start = idx + 7 + 1 + pstart;\n    let pend = json.slice(start + 1, 80).indexOf(`\"`);\n    if (pend === -1) return null;\n    let end = start + 1 + pend;\n    return json.slice(start + 1, end);\n}\nfunction $b8e126da42a4b9e3$var$matchEventId(json, id) {\n    return id === $b8e126da42a4b9e3$var$getHex64(json, \"id\");\n}\nfunction $b8e126da42a4b9e3$var$matchEventPubkey(json, pubkey) {\n    return pubkey === $b8e126da42a4b9e3$var$getHex64(json, \"pubkey\");\n}\nfunction $b8e126da42a4b9e3$var$matchEventKind(json, kind) {\n    return kind === $b8e126da42a4b9e3$var$getInt(json, \"kind\");\n}\n// nip42.ts\nvar $b8e126da42a4b9e3$export$900cb248cdec72b = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$900cb248cdec72b, {\n    makeAuthEvent: ()=>$b8e126da42a4b9e3$var$makeAuthEvent\n});\nfunction $b8e126da42a4b9e3$var$makeAuthEvent(relayURL, challenge) {\n    return {\n        kind: $b8e126da42a4b9e3$var$ClientAuth,\n        created_at: Math.floor(Date.now() / 1e3),\n        tags: [\n            [\n                \"relay\",\n                relayURL\n            ],\n            [\n                \"challenge\",\n                challenge\n            ]\n        ],\n        content: \"\"\n    };\n}\n// helpers.ts\nasync function $b8e126da42a4b9e3$var$yieldThread() {\n    return new Promise((resolve)=>{\n        const ch = new MessageChannel();\n        const handler = ()=>{\n            ch.port1.removeEventListener(\"message\", handler);\n            resolve();\n        };\n        ch.port1.addEventListener(\"message\", handler);\n        ch.port2.postMessage(0);\n        ch.port1.start();\n    });\n}\nvar $b8e126da42a4b9e3$var$alwaysTrue = (t)=>{\n    t[$b8e126da42a4b9e3$export$31a1b605a7b8e0bf] = true;\n    return true;\n};\n// abstract-relay.ts\nvar $b8e126da42a4b9e3$var$SendingOnClosedConnection = class extends Error {\n    constructor(message, relay){\n        super(`Tried to send message '${message} on a closed connection to ${relay}.`);\n        this.name = \"SendingOnClosedConnection\";\n    }\n};\nvar $b8e126da42a4b9e3$var$AbstractRelay = class {\n    url;\n    _connected = false;\n    onclose = null;\n    onnotice = (msg)=>console.debug(`NOTICE from ${this.url}: ${msg}`);\n    baseEoseTimeout = 4400;\n    connectionTimeout = 4400;\n    publishTimeout = 4400;\n    openSubs = /* @__PURE__ */ new Map();\n    connectionTimeoutHandle;\n    connectionPromise;\n    openCountRequests = /* @__PURE__ */ new Map();\n    openEventPublishes = /* @__PURE__ */ new Map();\n    ws;\n    incomingMessageQueue = new $b8e126da42a4b9e3$var$Queue();\n    queueRunning = false;\n    challenge;\n    authPromise;\n    serial = 0;\n    verifyEvent;\n    _WebSocket;\n    constructor(url, opts){\n        this.url = $b8e126da42a4b9e3$var$normalizeURL(url);\n        this.verifyEvent = opts.verifyEvent;\n        this._WebSocket = opts.websocketImplementation || WebSocket;\n    }\n    static async connect(url, opts) {\n        const relay = new $b8e126da42a4b9e3$var$AbstractRelay(url, opts);\n        await relay.connect();\n        return relay;\n    }\n    closeAllSubscriptions(reason) {\n        for (let [_, sub] of this.openSubs)sub.close(reason);\n        this.openSubs.clear();\n        for (let [_, ep] of this.openEventPublishes)ep.reject(new Error(reason));\n        this.openEventPublishes.clear();\n        for (let [_, cr] of this.openCountRequests)cr.reject(new Error(reason));\n        this.openCountRequests.clear();\n    }\n    get connected() {\n        return this._connected;\n    }\n    async connect() {\n        if (this.connectionPromise) return this.connectionPromise;\n        this.challenge = void 0;\n        this.authPromise = void 0;\n        this.connectionPromise = new Promise((resolve, reject)=>{\n            this.connectionTimeoutHandle = setTimeout(()=>{\n                reject(\"connection timed out\");\n                this.connectionPromise = void 0;\n                this.onclose?.();\n                this.closeAllSubscriptions(\"relay connection timed out\");\n            }, this.connectionTimeout);\n            try {\n                this.ws = new this._WebSocket(this.url);\n            } catch (err) {\n                clearTimeout(this.connectionTimeoutHandle);\n                reject(err);\n                return;\n            }\n            this.ws.onopen = ()=>{\n                clearTimeout(this.connectionTimeoutHandle);\n                this._connected = true;\n                resolve();\n            };\n            this.ws.onerror = (ev)=>{\n                clearTimeout(this.connectionTimeoutHandle);\n                reject(ev.message || \"websocket error\");\n                if (this._connected) {\n                    this._connected = false;\n                    this.connectionPromise = void 0;\n                    this.onclose?.();\n                    this.closeAllSubscriptions(\"relay connection errored\");\n                }\n            };\n            this.ws.onclose = (ev)=>{\n                clearTimeout(this.connectionTimeoutHandle);\n                reject(ev.message || \"websocket closed\");\n                if (this._connected) {\n                    this._connected = false;\n                    this.connectionPromise = void 0;\n                    this.onclose?.();\n                    this.closeAllSubscriptions(\"relay connection closed\");\n                }\n            };\n            this.ws.onmessage = this._onmessage.bind(this);\n        });\n        return this.connectionPromise;\n    }\n    async runQueue() {\n        this.queueRunning = true;\n        while(true){\n            if (false === this.handleNext()) break;\n            await $b8e126da42a4b9e3$var$yieldThread();\n        }\n        this.queueRunning = false;\n    }\n    handleNext() {\n        const json = this.incomingMessageQueue.dequeue();\n        if (!json) return false;\n        const subid = $b8e126da42a4b9e3$var$getSubscriptionId(json);\n        if (subid) {\n            const so = this.openSubs.get(subid);\n            if (!so) return;\n            const id = $b8e126da42a4b9e3$var$getHex64(json, \"id\");\n            const alreadyHave = so.alreadyHaveEvent?.(id);\n            so.receivedEvent?.(this, id);\n            if (alreadyHave) return;\n        }\n        try {\n            let data = JSON.parse(json);\n            switch(data[0]){\n                case \"EVENT\":\n                    {\n                        const so = this.openSubs.get(data[1]);\n                        const event = data[2];\n                        if (this.verifyEvent(event) && $b8e126da42a4b9e3$export$4bbf3f173cb9a4eb(so.filters, event)) so.onevent(event);\n                        return;\n                    }\n                case \"COUNT\":\n                    {\n                        const id = data[1];\n                        const payload = data[2];\n                        const cr = this.openCountRequests.get(id);\n                        if (cr) {\n                            cr.resolve(payload.count);\n                            this.openCountRequests.delete(id);\n                        }\n                        return;\n                    }\n                case \"EOSE\":\n                    {\n                        const so = this.openSubs.get(data[1]);\n                        if (!so) return;\n                        so.receivedEose();\n                        return;\n                    }\n                case \"OK\":\n                    {\n                        const id = data[1];\n                        const ok = data[2];\n                        const reason = data[3];\n                        const ep = this.openEventPublishes.get(id);\n                        if (ep) {\n                            clearTimeout(ep.timeout);\n                            if (ok) ep.resolve(reason);\n                            else ep.reject(new Error(reason));\n                            this.openEventPublishes.delete(id);\n                        }\n                        return;\n                    }\n                case \"CLOSED\":\n                    {\n                        const id = data[1];\n                        const so = this.openSubs.get(id);\n                        if (!so) return;\n                        so.closed = true;\n                        so.close(data[2]);\n                        return;\n                    }\n                case \"NOTICE\":\n                    this.onnotice(data[1]);\n                    return;\n                case \"AUTH\":\n                    this.challenge = data[1];\n                    return;\n            }\n        } catch (err) {\n            return;\n        }\n    }\n    async send(message) {\n        if (!this.connectionPromise) throw new $b8e126da42a4b9e3$var$SendingOnClosedConnection(message, this.url);\n        this.connectionPromise.then(()=>{\n            this.ws?.send(message);\n        });\n    }\n    async auth(signAuthEvent) {\n        const challenge = this.challenge;\n        if (!challenge) throw new Error(\"can't perform auth, no challenge was received\");\n        if (this.authPromise) return this.authPromise;\n        this.authPromise = new Promise(async (resolve, reject)=>{\n            try {\n                let evt = await signAuthEvent($b8e126da42a4b9e3$var$makeAuthEvent(this.url, challenge));\n                let timeout = setTimeout(()=>{\n                    let ep = this.openEventPublishes.get(evt.id);\n                    if (ep) {\n                        ep.reject(new Error(\"auth timed out\"));\n                        this.openEventPublishes.delete(evt.id);\n                    }\n                }, this.publishTimeout);\n                this.openEventPublishes.set(evt.id, {\n                    resolve: resolve,\n                    reject: reject,\n                    timeout: timeout\n                });\n                this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n            } catch (err) {\n                console.warn(\"subscribe auth function failed:\", err);\n            }\n        });\n        return this.authPromise;\n    }\n    async publish(event) {\n        const ret = new Promise((resolve, reject)=>{\n            const timeout = setTimeout(()=>{\n                const ep = this.openEventPublishes.get(event.id);\n                if (ep) {\n                    ep.reject(new Error(\"publish timed out\"));\n                    this.openEventPublishes.delete(event.id);\n                }\n            }, this.publishTimeout);\n            this.openEventPublishes.set(event.id, {\n                resolve: resolve,\n                reject: reject,\n                timeout: timeout\n            });\n        });\n        this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n        return ret;\n    }\n    async count(filters, params) {\n        this.serial++;\n        const id = params?.id || \"count:\" + this.serial;\n        const ret = new Promise((resolve, reject)=>{\n            this.openCountRequests.set(id, {\n                resolve: resolve,\n                reject: reject\n            });\n        });\n        this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n        return ret;\n    }\n    subscribe(filters, params) {\n        const subscription = this.prepareSubscription(filters, params);\n        subscription.fire();\n        return subscription;\n    }\n    prepareSubscription(filters, params) {\n        this.serial++;\n        const id = params.id || (params.label ? params.label + \":\" : \"sub:\") + this.serial;\n        const subscription = new $b8e126da42a4b9e3$var$Subscription(this, id, filters, params);\n        this.openSubs.set(id, subscription);\n        return subscription;\n    }\n    close() {\n        this.closeAllSubscriptions(\"relay connection closed by us\");\n        this._connected = false;\n        this.ws?.close();\n    }\n    _onmessage(ev) {\n        this.incomingMessageQueue.enqueue(ev.data);\n        if (!this.queueRunning) this.runQueue();\n    }\n};\nvar $b8e126da42a4b9e3$var$Subscription = class {\n    relay;\n    id;\n    closed = false;\n    eosed = false;\n    filters;\n    alreadyHaveEvent;\n    receivedEvent;\n    onevent;\n    oneose;\n    onclose;\n    eoseTimeout;\n    eoseTimeoutHandle;\n    constructor(relay, id, filters, params){\n        this.relay = relay;\n        this.filters = filters;\n        this.id = id;\n        this.alreadyHaveEvent = params.alreadyHaveEvent;\n        this.receivedEvent = params.receivedEvent;\n        this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n        this.oneose = params.oneose;\n        this.onclose = params.onclose;\n        this.onevent = params.onevent || ((event)=>{\n            console.warn(`onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`, event);\n        });\n    }\n    fire() {\n        this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n        this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n    }\n    receivedEose() {\n        if (this.eosed) return;\n        clearTimeout(this.eoseTimeoutHandle);\n        this.eosed = true;\n        this.oneose?.();\n    }\n    close(reason = \"closed by caller\") {\n        if (!this.closed && this.relay.connected) {\n            try {\n                this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n            } catch (err) {\n                if (err instanceof $b8e126da42a4b9e3$var$SendingOnClosedConnection) ;\n                else throw err;\n            }\n            this.closed = true;\n        }\n        this.relay.openSubs.delete(this.id);\n        this.onclose?.(reason);\n    }\n};\n// relay.ts\nvar $b8e126da42a4b9e3$var$_WebSocket;\ntry {\n    $b8e126da42a4b9e3$var$_WebSocket = WebSocket;\n} catch  {}\nvar $b8e126da42a4b9e3$export$325be0d991c73dc2 = class extends $b8e126da42a4b9e3$var$AbstractRelay {\n    constructor(url){\n        super(url, {\n            verifyEvent: $b8e126da42a4b9e3$export$909d658b5069e986,\n            websocketImplementation: $b8e126da42a4b9e3$var$_WebSocket\n        });\n    }\n    static async connect(url) {\n        const relay = new $b8e126da42a4b9e3$export$325be0d991c73dc2(url);\n        await relay.connect();\n        return relay;\n    }\n};\n// abstract-pool.ts\nvar $b8e126da42a4b9e3$var$AbstractSimplePool = class {\n    relays = /* @__PURE__ */ new Map();\n    seenOn = /* @__PURE__ */ new Map();\n    trackRelays = false;\n    verifyEvent;\n    trustedRelayURLs = /* @__PURE__ */ new Set();\n    _WebSocket;\n    constructor(opts){\n        this.verifyEvent = opts.verifyEvent;\n        this._WebSocket = opts.websocketImplementation;\n    }\n    async ensureRelay(url, params) {\n        url = $b8e126da42a4b9e3$var$normalizeURL(url);\n        let relay = this.relays.get(url);\n        if (!relay) {\n            relay = new $b8e126da42a4b9e3$var$AbstractRelay(url, {\n                verifyEvent: this.trustedRelayURLs.has(url) ? $b8e126da42a4b9e3$var$alwaysTrue : this.verifyEvent,\n                websocketImplementation: this._WebSocket\n            });\n            if (params?.connectionTimeout) relay.connectionTimeout = params.connectionTimeout;\n            this.relays.set(url, relay);\n        }\n        await relay.connect();\n        return relay;\n    }\n    close(relays) {\n        relays.map($b8e126da42a4b9e3$var$normalizeURL).forEach((url)=>{\n            this.relays.get(url)?.close();\n        });\n    }\n    subscribe(relays, filter, params) {\n        params.onauth = params.onauth || params.doauth;\n        return this.subscribeMap(relays.map((url)=>({\n                url: url,\n                filter: filter\n            })), params);\n    }\n    subscribeMany(relays, filters, params) {\n        params.onauth = params.onauth || params.doauth;\n        return this.subscribeMap(relays.flatMap((url)=>filters.map((filter)=>({\n                    url: url,\n                    filter: filter\n                }))), params);\n    }\n    subscribeMap(requests, params) {\n        params.onauth = params.onauth || params.doauth;\n        if (this.trackRelays) params.receivedEvent = (relay, id)=>{\n            let set = this.seenOn.get(id);\n            if (!set) {\n                set = /* @__PURE__ */ new Set();\n                this.seenOn.set(id, set);\n            }\n            set.add(relay);\n        };\n        const _knownIds = /* @__PURE__ */ new Set();\n        const subs = [];\n        const eosesReceived = [];\n        let handleEose = (i2)=>{\n            if (eosesReceived[i2]) return;\n            eosesReceived[i2] = true;\n            if (eosesReceived.filter((a)=>a).length === requests.length) {\n                params.oneose?.();\n                handleEose = ()=>{};\n            }\n        };\n        const closesReceived = [];\n        let handleClose = (i2, reason)=>{\n            if (closesReceived[i2]) return;\n            handleEose(i2);\n            closesReceived[i2] = reason;\n            if (closesReceived.filter((a)=>a).length === requests.length) {\n                params.onclose?.(closesReceived);\n                handleClose = ()=>{};\n            }\n        };\n        const localAlreadyHaveEventHandler = (id)=>{\n            if (params.alreadyHaveEvent?.(id)) return true;\n            const have = _knownIds.has(id);\n            _knownIds.add(id);\n            return have;\n        };\n        const allOpened = Promise.all(requests.map(async ({ url: url, filter: filter }, i2)=>{\n            url = $b8e126da42a4b9e3$var$normalizeURL(url);\n            let relay;\n            try {\n                relay = await this.ensureRelay(url, {\n                    connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n                });\n            } catch (err) {\n                handleClose(i2, err?.message || String(err));\n                return;\n            }\n            let subscription = relay.subscribe([\n                filter\n            ], {\n                ...params,\n                oneose: ()=>handleEose(i2),\n                onclose: (reason)=>{\n                    if (reason.startsWith(\"auth-required: \") && params.onauth) relay.auth(params.onauth).then(()=>{\n                        relay.subscribe([\n                            filter\n                        ], {\n                            ...params,\n                            oneose: ()=>handleEose(i2),\n                            onclose: (reason2)=>{\n                                handleClose(i2, reason2);\n                            },\n                            alreadyHaveEvent: localAlreadyHaveEventHandler,\n                            eoseTimeout: params.maxWait\n                        });\n                    }).catch((err)=>{\n                        handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n                    });\n                    else handleClose(i2, reason);\n                },\n                alreadyHaveEvent: localAlreadyHaveEventHandler,\n                eoseTimeout: params.maxWait\n            });\n            subs.push(subscription);\n        }));\n        return {\n            async close (reason) {\n                await allOpened;\n                subs.forEach((sub)=>{\n                    sub.close(reason);\n                });\n            }\n        };\n    }\n    subscribeEose(relays, filter, params) {\n        params.onauth = params.onauth || params.doauth;\n        const subcloser = this.subscribe(relays, filter, {\n            ...params,\n            oneose () {\n                subcloser.close(\"closed automatically on eose\");\n            }\n        });\n        return subcloser;\n    }\n    subscribeManyEose(relays, filters, params) {\n        params.onauth = params.onauth || params.doauth;\n        const subcloser = this.subscribeMany(relays, filters, {\n            ...params,\n            oneose () {\n                subcloser.close(\"closed automatically on eose\");\n            }\n        });\n        return subcloser;\n    }\n    async querySync(relays, filter, params) {\n        return new Promise(async (resolve)=>{\n            const events = [];\n            this.subscribeEose(relays, filter, {\n                ...params,\n                onevent (event) {\n                    events.push(event);\n                },\n                onclose (_) {\n                    resolve(events);\n                }\n            });\n        });\n    }\n    async get(relays, filter, params) {\n        filter.limit = 1;\n        const events = await this.querySync(relays, filter, params);\n        events.sort((a, b)=>b.created_at - a.created_at);\n        return events[0] || null;\n    }\n    publish(relays, event, options) {\n        return relays.map($b8e126da42a4b9e3$var$normalizeURL).map(async (url, i2, arr)=>{\n            if (arr.indexOf(url) !== i2) return Promise.reject(\"duplicate url\");\n            let r = await this.ensureRelay(url);\n            return r.publish(event).catch(async (err)=>{\n                if (err instanceof Error && err.message.startsWith(\"auth-required: \") && options?.onauth) {\n                    await r.auth(options.onauth);\n                    return r.publish(event);\n                }\n                throw err;\n            }).then((reason)=>{\n                if (this.trackRelays) {\n                    let set = this.seenOn.get(event.id);\n                    if (!set) {\n                        set = /* @__PURE__ */ new Set();\n                        this.seenOn.set(event.id, set);\n                    }\n                    set.add(r);\n                }\n                return reason;\n            });\n        });\n    }\n    listConnectionStatus() {\n        const map = /* @__PURE__ */ new Map();\n        this.relays.forEach((relay, url)=>map.set(url, relay.connected));\n        return map;\n    }\n    destroy() {\n        this.relays.forEach((conn)=>conn.close());\n        this.relays = /* @__PURE__ */ new Map();\n    }\n};\n// pool.ts\nvar $b8e126da42a4b9e3$var$_WebSocket2;\ntry {\n    $b8e126da42a4b9e3$var$_WebSocket2 = WebSocket;\n} catch  {}\nvar $b8e126da42a4b9e3$export$db45add7d1880f0c = class extends $b8e126da42a4b9e3$var$AbstractSimplePool {\n    constructor(){\n        super({\n            verifyEvent: $b8e126da42a4b9e3$export$909d658b5069e986,\n            websocketImplementation: $b8e126da42a4b9e3$var$_WebSocket2\n        });\n    }\n};\n// nip19.ts\nvar $b8e126da42a4b9e3$export$10660ae21dbef115 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$10660ae21dbef115, {\n    BECH32_REGEX: ()=>$b8e126da42a4b9e3$var$BECH32_REGEX,\n    Bech32MaxSize: ()=>$b8e126da42a4b9e3$var$Bech32MaxSize,\n    NostrTypeGuard: ()=>$b8e126da42a4b9e3$var$NostrTypeGuard,\n    decode: ()=>$b8e126da42a4b9e3$var$decode,\n    decodeNostrURI: ()=>$b8e126da42a4b9e3$var$decodeNostrURI,\n    encodeBytes: ()=>$b8e126da42a4b9e3$var$encodeBytes,\n    naddrEncode: ()=>$b8e126da42a4b9e3$var$naddrEncode,\n    neventEncode: ()=>$b8e126da42a4b9e3$var$neventEncode,\n    noteEncode: ()=>$b8e126da42a4b9e3$var$noteEncode,\n    nprofileEncode: ()=>$b8e126da42a4b9e3$var$nprofileEncode,\n    npubEncode: ()=>$b8e126da42a4b9e3$var$npubEncode,\n    nsecEncode: ()=>$b8e126da42a4b9e3$var$nsecEncode\n});\nvar $b8e126da42a4b9e3$var$NostrTypeGuard = {\n    isNProfile: (value)=>/^nprofile1[a-z\\d]+$/.test(value || \"\"),\n    isNEvent: (value)=>/^nevent1[a-z\\d]+$/.test(value || \"\"),\n    isNAddr: (value)=>/^naddr1[a-z\\d]+$/.test(value || \"\"),\n    isNSec: (value)=>/^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n    isNPub: (value)=>/^npub1[a-z\\d]{58}$/.test(value || \"\"),\n    isNote: (value)=>/^note1[a-z\\d]+$/.test(value || \"\"),\n    isNcryptsec: (value)=>/^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar $b8e126da42a4b9e3$var$Bech32MaxSize = 5e3;\nvar $b8e126da42a4b9e3$var$BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction $b8e126da42a4b9e3$var$integerToUint8Array(number) {\n    const uint8Array = new Uint8Array(4);\n    uint8Array[0] = number >> 24 & 255;\n    uint8Array[1] = number >> 16 & 255;\n    uint8Array[2] = number >> 8 & 255;\n    uint8Array[3] = number & 255;\n    return uint8Array;\n}\nfunction $b8e126da42a4b9e3$var$decodeNostrURI(nip19code) {\n    try {\n        if (nip19code.startsWith(\"nostr:\")) nip19code = nip19code.substring(6);\n        return $b8e126da42a4b9e3$var$decode(nip19code);\n    } catch (_err) {\n        return {\n            type: \"invalid\",\n            data: null\n        };\n    }\n}\nfunction $b8e126da42a4b9e3$var$decode(code) {\n    let { prefix: prefix, words: words } = (0, $4Dsex.bech32).decode(code, $b8e126da42a4b9e3$var$Bech32MaxSize);\n    let data = new Uint8Array((0, $4Dsex.bech32).fromWords(words));\n    switch(prefix){\n        case \"nprofile\":\n            {\n                let tlv = $b8e126da42a4b9e3$var$parseTLV(data);\n                if (!tlv[0]?.[0]) throw new Error(\"missing TLV 0 for nprofile\");\n                if (tlv[0][0].length !== 32) throw new Error(\"TLV 0 should be 32 bytes\");\n                return {\n                    type: \"nprofile\",\n                    data: {\n                        pubkey: (0, $3Bcdj.bytesToHex)(tlv[0][0]),\n                        relays: tlv[1] ? tlv[1].map((d)=>$b8e126da42a4b9e3$var$utf8Decoder.decode(d)) : []\n                    }\n                };\n            }\n        case \"nevent\":\n            {\n                let tlv = $b8e126da42a4b9e3$var$parseTLV(data);\n                if (!tlv[0]?.[0]) throw new Error(\"missing TLV 0 for nevent\");\n                if (tlv[0][0].length !== 32) throw new Error(\"TLV 0 should be 32 bytes\");\n                if (tlv[2] && tlv[2][0].length !== 32) throw new Error(\"TLV 2 should be 32 bytes\");\n                if (tlv[3] && tlv[3][0].length !== 4) throw new Error(\"TLV 3 should be 4 bytes\");\n                return {\n                    type: \"nevent\",\n                    data: {\n                        id: (0, $3Bcdj.bytesToHex)(tlv[0][0]),\n                        relays: tlv[1] ? tlv[1].map((d)=>$b8e126da42a4b9e3$var$utf8Decoder.decode(d)) : [],\n                        author: tlv[2]?.[0] ? (0, $3Bcdj.bytesToHex)(tlv[2][0]) : void 0,\n                        kind: tlv[3]?.[0] ? parseInt((0, $3Bcdj.bytesToHex)(tlv[3][0]), 16) : void 0\n                    }\n                };\n            }\n        case \"naddr\":\n            {\n                let tlv = $b8e126da42a4b9e3$var$parseTLV(data);\n                if (!tlv[0]?.[0]) throw new Error(\"missing TLV 0 for naddr\");\n                if (!tlv[2]?.[0]) throw new Error(\"missing TLV 2 for naddr\");\n                if (tlv[2][0].length !== 32) throw new Error(\"TLV 2 should be 32 bytes\");\n                if (!tlv[3]?.[0]) throw new Error(\"missing TLV 3 for naddr\");\n                if (tlv[3][0].length !== 4) throw new Error(\"TLV 3 should be 4 bytes\");\n                return {\n                    type: \"naddr\",\n                    data: {\n                        identifier: $b8e126da42a4b9e3$var$utf8Decoder.decode(tlv[0][0]),\n                        pubkey: (0, $3Bcdj.bytesToHex)(tlv[2][0]),\n                        kind: parseInt((0, $3Bcdj.bytesToHex)(tlv[3][0]), 16),\n                        relays: tlv[1] ? tlv[1].map((d)=>$b8e126da42a4b9e3$var$utf8Decoder.decode(d)) : []\n                    }\n                };\n            }\n        case \"nsec\":\n            return {\n                type: prefix,\n                data: data\n            };\n        case \"npub\":\n        case \"note\":\n            return {\n                type: prefix,\n                data: (0, $3Bcdj.bytesToHex)(data)\n            };\n        default:\n            throw new Error(`unknown prefix ${prefix}`);\n    }\n}\nfunction $b8e126da42a4b9e3$var$parseTLV(data) {\n    let result = {};\n    let rest = data;\n    while(rest.length > 0){\n        let t = rest[0];\n        let l = rest[1];\n        let v = rest.slice(2, 2 + l);\n        rest = rest.slice(2 + l);\n        if (v.length < l) throw new Error(`not enough data to read on TLV ${t}`);\n        result[t] = result[t] || [];\n        result[t].push(v);\n    }\n    return result;\n}\nfunction $b8e126da42a4b9e3$var$nsecEncode(key) {\n    return $b8e126da42a4b9e3$var$encodeBytes(\"nsec\", key);\n}\nfunction $b8e126da42a4b9e3$var$npubEncode(hex) {\n    return $b8e126da42a4b9e3$var$encodeBytes(\"npub\", (0, $3Bcdj.hexToBytes)(hex));\n}\nfunction $b8e126da42a4b9e3$var$noteEncode(hex) {\n    return $b8e126da42a4b9e3$var$encodeBytes(\"note\", (0, $3Bcdj.hexToBytes)(hex));\n}\nfunction $b8e126da42a4b9e3$var$encodeBech32(prefix, data) {\n    let words = (0, $4Dsex.bech32).toWords(data);\n    return (0, $4Dsex.bech32).encode(prefix, words, $b8e126da42a4b9e3$var$Bech32MaxSize);\n}\nfunction $b8e126da42a4b9e3$var$encodeBytes(prefix, bytes) {\n    return $b8e126da42a4b9e3$var$encodeBech32(prefix, bytes);\n}\nfunction $b8e126da42a4b9e3$var$nprofileEncode(profile) {\n    let data = $b8e126da42a4b9e3$var$encodeTLV({\n        0: [\n            (0, $3Bcdj.hexToBytes)(profile.pubkey)\n        ],\n        1: (profile.relays || []).map((url)=>$b8e126da42a4b9e3$var$utf8Encoder.encode(url))\n    });\n    return $b8e126da42a4b9e3$var$encodeBech32(\"nprofile\", data);\n}\nfunction $b8e126da42a4b9e3$var$neventEncode(event) {\n    let kindArray;\n    if (event.kind !== void 0) kindArray = $b8e126da42a4b9e3$var$integerToUint8Array(event.kind);\n    let data = $b8e126da42a4b9e3$var$encodeTLV({\n        0: [\n            (0, $3Bcdj.hexToBytes)(event.id)\n        ],\n        1: (event.relays || []).map((url)=>$b8e126da42a4b9e3$var$utf8Encoder.encode(url)),\n        2: event.author ? [\n            (0, $3Bcdj.hexToBytes)(event.author)\n        ] : [],\n        3: kindArray ? [\n            new Uint8Array(kindArray)\n        ] : []\n    });\n    return $b8e126da42a4b9e3$var$encodeBech32(\"nevent\", data);\n}\nfunction $b8e126da42a4b9e3$var$naddrEncode(addr) {\n    let kind = new ArrayBuffer(4);\n    new DataView(kind).setUint32(0, addr.kind, false);\n    let data = $b8e126da42a4b9e3$var$encodeTLV({\n        0: [\n            $b8e126da42a4b9e3$var$utf8Encoder.encode(addr.identifier)\n        ],\n        1: (addr.relays || []).map((url)=>$b8e126da42a4b9e3$var$utf8Encoder.encode(url)),\n        2: [\n            (0, $3Bcdj.hexToBytes)(addr.pubkey)\n        ],\n        3: [\n            new Uint8Array(kind)\n        ]\n    });\n    return $b8e126da42a4b9e3$var$encodeBech32(\"naddr\", data);\n}\nfunction $b8e126da42a4b9e3$var$encodeTLV(tlv) {\n    let entries = [];\n    Object.entries(tlv).reverse().forEach(([t, vs])=>{\n        vs.forEach((v)=>{\n            let entry = new Uint8Array(v.length + 2);\n            entry.set([\n                parseInt(t)\n            ], 0);\n            entry.set([\n                v.length\n            ], 1);\n            entry.set(v, 2);\n            entries.push(entry);\n        });\n    });\n    return (0, $3Bcdj.concatBytes)(...entries);\n}\n// references.ts\nvar $b8e126da42a4b9e3$var$mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction $b8e126da42a4b9e3$export$2b054a310b694903(evt) {\n    let references = [];\n    for (let ref of evt.content.matchAll($b8e126da42a4b9e3$var$mentionRegex)){\n        if (ref[2]) try {\n            let { type: type, data: data } = $b8e126da42a4b9e3$var$decode(ref[1]);\n            switch(type){\n                case \"npub\":\n                    references.push({\n                        text: ref[0],\n                        profile: {\n                            pubkey: data,\n                            relays: []\n                        }\n                    });\n                    break;\n                case \"nprofile\":\n                    references.push({\n                        text: ref[0],\n                        profile: data\n                    });\n                    break;\n                case \"note\":\n                    references.push({\n                        text: ref[0],\n                        event: {\n                            id: data,\n                            relays: []\n                        }\n                    });\n                    break;\n                case \"nevent\":\n                    references.push({\n                        text: ref[0],\n                        event: data\n                    });\n                    break;\n                case \"naddr\":\n                    references.push({\n                        text: ref[0],\n                        address: data\n                    });\n                    break;\n            }\n        } catch (err) {}\n        else if (ref[3]) {\n            let idx = parseInt(ref[3], 10);\n            let tag = evt.tags[idx];\n            if (!tag) continue;\n            switch(tag[0]){\n                case \"p\":\n                    references.push({\n                        text: ref[0],\n                        profile: {\n                            pubkey: tag[1],\n                            relays: tag[2] ? [\n                                tag[2]\n                            ] : []\n                        }\n                    });\n                    break;\n                case \"e\":\n                    references.push({\n                        text: ref[0],\n                        event: {\n                            id: tag[1],\n                            relays: tag[2] ? [\n                                tag[2]\n                            ] : []\n                        }\n                    });\n                    break;\n                case \"a\":\n                    try {\n                        let [kind, pubkey, identifier] = tag[1].split(\":\");\n                        references.push({\n                            text: ref[0],\n                            address: {\n                                identifier: identifier,\n                                pubkey: pubkey,\n                                kind: parseInt(kind, 10),\n                                relays: tag[2] ? [\n                                    tag[2]\n                                ] : []\n                            }\n                        });\n                    } catch (err) {}\n                    break;\n            }\n        }\n    }\n    return references;\n}\n// nip04.ts\nvar $b8e126da42a4b9e3$export$4793e42c2cc9b120 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$4793e42c2cc9b120, {\n    decrypt: ()=>$b8e126da42a4b9e3$var$decrypt,\n    encrypt: ()=>$b8e126da42a4b9e3$var$encrypt\n});\nfunction $b8e126da42a4b9e3$var$encrypt(secretKey, pubkey, text) {\n    const privkey = secretKey instanceof Uint8Array ? (0, $3Bcdj.bytesToHex)(secretKey) : secretKey;\n    const key = (0, $5r7db.secp256k1).getSharedSecret(privkey, \"02\" + pubkey);\n    const normalizedKey = $b8e126da42a4b9e3$var$getNormalizedX(key);\n    let iv = Uint8Array.from((0, $3Bcdj.randomBytes)(16));\n    let plaintext = $b8e126da42a4b9e3$var$utf8Encoder.encode(text);\n    let ciphertext = (0, $3RPiR.cbc)(normalizedKey, iv).encrypt(plaintext);\n    let ctb64 = (0, $4Dsex.base64).encode(new Uint8Array(ciphertext));\n    let ivb64 = (0, $4Dsex.base64).encode(new Uint8Array(iv.buffer));\n    return `${ctb64}?iv=${ivb64}`;\n}\nfunction $b8e126da42a4b9e3$var$decrypt(secretKey, pubkey, data) {\n    const privkey = secretKey instanceof Uint8Array ? (0, $3Bcdj.bytesToHex)(secretKey) : secretKey;\n    let [ctb64, ivb64] = data.split(\"?iv=\");\n    let key = (0, $5r7db.secp256k1).getSharedSecret(privkey, \"02\" + pubkey);\n    let normalizedKey = $b8e126da42a4b9e3$var$getNormalizedX(key);\n    let iv = (0, $4Dsex.base64).decode(ivb64);\n    let ciphertext = (0, $4Dsex.base64).decode(ctb64);\n    let plaintext = (0, $3RPiR.cbc)(normalizedKey, iv).decrypt(ciphertext);\n    return $b8e126da42a4b9e3$var$utf8Decoder.decode(plaintext);\n}\nfunction $b8e126da42a4b9e3$var$getNormalizedX(key) {\n    return key.slice(1, 33);\n}\n// nip05.ts\nvar $b8e126da42a4b9e3$export$a60e5b740ad8d13e = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$a60e5b740ad8d13e, {\n    NIP05_REGEX: ()=>$b8e126da42a4b9e3$var$NIP05_REGEX,\n    isNip05: ()=>$b8e126da42a4b9e3$var$isNip05,\n    isValid: ()=>$b8e126da42a4b9e3$var$isValid,\n    queryProfile: ()=>$b8e126da42a4b9e3$var$queryProfile,\n    searchDomain: ()=>$b8e126da42a4b9e3$var$searchDomain,\n    useFetchImplementation: ()=>$b8e126da42a4b9e3$var$useFetchImplementation\n});\nvar $b8e126da42a4b9e3$var$NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar $b8e126da42a4b9e3$var$isNip05 = (value)=>$b8e126da42a4b9e3$var$NIP05_REGEX.test(value || \"\");\nvar $b8e126da42a4b9e3$var$_fetch;\ntry {\n    $b8e126da42a4b9e3$var$_fetch = fetch;\n} catch (_) {}\nfunction $b8e126da42a4b9e3$var$useFetchImplementation(fetchImplementation) {\n    $b8e126da42a4b9e3$var$_fetch = fetchImplementation;\n}\nasync function $b8e126da42a4b9e3$var$searchDomain(domain, query = \"\") {\n    try {\n        const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n        const res = await $b8e126da42a4b9e3$var$_fetch(url, {\n            redirect: \"manual\"\n        });\n        if (res.status !== 200) throw Error(\"Wrong response code\");\n        const json = await res.json();\n        return json.names;\n    } catch (_) {\n        return {};\n    }\n}\nasync function $b8e126da42a4b9e3$var$queryProfile(fullname) {\n    const match = fullname.match($b8e126da42a4b9e3$var$NIP05_REGEX);\n    if (!match) return null;\n    const [, name = \"_\", domain] = match;\n    try {\n        const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n        const res = await $b8e126da42a4b9e3$var$_fetch(url, {\n            redirect: \"manual\"\n        });\n        if (res.status !== 200) throw Error(\"Wrong response code\");\n        const json = await res.json();\n        const pubkey = json.names[name];\n        return pubkey ? {\n            pubkey: pubkey,\n            relays: json.relays?.[pubkey]\n        } : null;\n    } catch (_e) {\n        return null;\n    }\n}\nasync function $b8e126da42a4b9e3$var$isValid(pubkey, nip05) {\n    const res = await $b8e126da42a4b9e3$var$queryProfile(nip05);\n    return res ? res.pubkey === pubkey : false;\n}\n// nip10.ts\nvar $b8e126da42a4b9e3$export$ce5090ce1281ef76 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$ce5090ce1281ef76, {\n    parse: ()=>$b8e126da42a4b9e3$var$parse\n});\nfunction $b8e126da42a4b9e3$var$parse(event) {\n    const result = {\n        reply: void 0,\n        root: void 0,\n        mentions: [],\n        profiles: [],\n        quotes: []\n    };\n    let maybeParent;\n    let maybeRoot;\n    for(let i2 = event.tags.length - 1; i2 >= 0; i2--){\n        const tag = event.tags[i2];\n        if (tag[0] === \"e\" && tag[1]) {\n            const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n            const eventPointer = {\n                id: eTagEventId,\n                relays: eTagRelayUrl ? [\n                    eTagRelayUrl\n                ] : [],\n                author: eTagAuthor\n            };\n            if (eTagMarker === \"root\") {\n                result.root = eventPointer;\n                continue;\n            }\n            if (eTagMarker === \"reply\") {\n                result.reply = eventPointer;\n                continue;\n            }\n            if (eTagMarker === \"mention\") {\n                result.mentions.push(eventPointer);\n                continue;\n            }\n            if (!maybeParent) maybeParent = eventPointer;\n            else maybeRoot = eventPointer;\n            result.mentions.push(eventPointer);\n            continue;\n        }\n        if (tag[0] === \"q\" && tag[1]) {\n            const [_, eTagEventId, eTagRelayUrl] = tag;\n            result.quotes.push({\n                id: eTagEventId,\n                relays: eTagRelayUrl ? [\n                    eTagRelayUrl\n                ] : []\n            });\n        }\n        if (tag[0] === \"p\" && tag[1]) {\n            result.profiles.push({\n                pubkey: tag[1],\n                relays: tag[2] ? [\n                    tag[2]\n                ] : []\n            });\n            continue;\n        }\n    }\n    if (!result.root) result.root = maybeRoot || maybeParent || result.reply;\n    if (!result.reply) result.reply = maybeParent || result.root;\n    [\n        result.reply,\n        result.root\n    ].forEach((ref)=>{\n        if (!ref) return;\n        let idx = result.mentions.indexOf(ref);\n        if (idx !== -1) result.mentions.splice(idx, 1);\n        if (ref.author) {\n            let author = result.profiles.find((p)=>p.pubkey === ref.author);\n            if (author && author.relays) {\n                if (!ref.relays) ref.relays = [];\n                author.relays.forEach((url)=>{\n                    if (ref.relays?.indexOf(url) === -1) ref.relays.push(url);\n                });\n                author.relays = ref.relays;\n            }\n        }\n    });\n    result.mentions.forEach((ref)=>{\n        if (ref.author) {\n            let author = result.profiles.find((p)=>p.pubkey === ref.author);\n            if (author && author.relays) {\n                if (!ref.relays) ref.relays = [];\n                author.relays.forEach((url)=>{\n                    if (ref.relays.indexOf(url) === -1) ref.relays.push(url);\n                });\n                author.relays = ref.relays;\n            }\n        }\n    });\n    return result;\n}\n// nip11.ts\nvar $b8e126da42a4b9e3$export$86cbe01fda153e74 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$86cbe01fda153e74, {\n    fetchRelayInformation: ()=>$b8e126da42a4b9e3$var$fetchRelayInformation,\n    useFetchImplementation: ()=>$b8e126da42a4b9e3$var$useFetchImplementation2\n});\nvar $b8e126da42a4b9e3$var$_fetch2;\ntry {\n    $b8e126da42a4b9e3$var$_fetch2 = fetch;\n} catch  {}\nfunction $b8e126da42a4b9e3$var$useFetchImplementation2(fetchImplementation) {\n    $b8e126da42a4b9e3$var$_fetch2 = fetchImplementation;\n}\nasync function $b8e126da42a4b9e3$var$fetchRelayInformation(url) {\n    return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n        headers: {\n            Accept: \"application/nostr+json\"\n        }\n    })).json();\n}\n// nip13.ts\nvar $b8e126da42a4b9e3$export$215f75f26b6c95fe = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$215f75f26b6c95fe, {\n    fastEventHash: ()=>$b8e126da42a4b9e3$var$fastEventHash,\n    getPow: ()=>$b8e126da42a4b9e3$var$getPow,\n    minePow: ()=>$b8e126da42a4b9e3$var$minePow\n});\nfunction $b8e126da42a4b9e3$var$getPow(hex) {\n    let count = 0;\n    for(let i2 = 0; i2 < 64; i2 += 8){\n        const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n        if (nibble === 0) count += 32;\n        else {\n            count += Math.clz32(nibble);\n            break;\n        }\n    }\n    return count;\n}\nfunction $b8e126da42a4b9e3$var$minePow(unsigned, difficulty) {\n    let count = 0;\n    const event = unsigned;\n    const tag = [\n        \"nonce\",\n        count.toString(),\n        difficulty.toString()\n    ];\n    event.tags.push(tag);\n    while(true){\n        const now2 = Math.floor(new Date().getTime() / 1e3);\n        if (now2 !== event.created_at) {\n            count = 0;\n            event.created_at = now2;\n        }\n        tag[1] = (++count).toString();\n        event.id = $b8e126da42a4b9e3$var$fastEventHash(event);\n        if ($b8e126da42a4b9e3$var$getPow(event.id) >= difficulty) break;\n    }\n    return event;\n}\nfunction $b8e126da42a4b9e3$var$fastEventHash(evt) {\n    return (0, $3Bcdj.bytesToHex)((0, $6XnWx.sha256)($b8e126da42a4b9e3$var$utf8Encoder.encode(JSON.stringify([\n        0,\n        evt.pubkey,\n        evt.created_at,\n        evt.kind,\n        evt.tags,\n        evt.content\n    ]))));\n}\n// nip17.ts\nvar $b8e126da42a4b9e3$export$b2365d93b6f57df6 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$b2365d93b6f57df6, {\n    unwrapEvent: ()=>$b8e126da42a4b9e3$var$unwrapEvent2,\n    unwrapManyEvents: ()=>$b8e126da42a4b9e3$var$unwrapManyEvents2,\n    wrapEvent: ()=>$b8e126da42a4b9e3$var$wrapEvent2,\n    wrapManyEvents: ()=>$b8e126da42a4b9e3$var$wrapManyEvents2\n});\n// nip59.ts\nvar $b8e126da42a4b9e3$export$c928dafb9718f202 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$c928dafb9718f202, {\n    createRumor: ()=>$b8e126da42a4b9e3$var$createRumor,\n    createSeal: ()=>$b8e126da42a4b9e3$var$createSeal,\n    createWrap: ()=>$b8e126da42a4b9e3$var$createWrap,\n    unwrapEvent: ()=>$b8e126da42a4b9e3$var$unwrapEvent,\n    unwrapManyEvents: ()=>$b8e126da42a4b9e3$var$unwrapManyEvents,\n    wrapEvent: ()=>$b8e126da42a4b9e3$var$wrapEvent,\n    wrapManyEvents: ()=>$b8e126da42a4b9e3$var$wrapManyEvents\n});\n// nip44.ts\nvar $b8e126da42a4b9e3$export$7f3384dd63301b54 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$7f3384dd63301b54, {\n    decrypt: ()=>$b8e126da42a4b9e3$var$decrypt2,\n    encrypt: ()=>$b8e126da42a4b9e3$var$encrypt2,\n    getConversationKey: ()=>$b8e126da42a4b9e3$var$getConversationKey,\n    v2: ()=>$b8e126da42a4b9e3$var$v2\n});\nvar $b8e126da42a4b9e3$var$minPlaintextSize = 1;\nvar $b8e126da42a4b9e3$var$maxPlaintextSize = 65535;\nfunction $b8e126da42a4b9e3$var$getConversationKey(privkeyA, pubkeyB) {\n    const sharedX = (0, $5r7db.secp256k1).getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n    return (0, $aN9nT.extract)((0, $6XnWx.sha256), sharedX, \"nip44-v2\");\n}\nfunction $b8e126da42a4b9e3$var$getMessageKeys(conversationKey, nonce) {\n    const keys = (0, $aN9nT.expand)((0, $6XnWx.sha256), conversationKey, nonce, 76);\n    return {\n        chacha_key: keys.subarray(0, 32),\n        chacha_nonce: keys.subarray(32, 44),\n        hmac_key: keys.subarray(44, 76)\n    };\n}\nfunction $b8e126da42a4b9e3$var$calcPaddedLen(len) {\n    if (!Number.isSafeInteger(len) || len < 1) throw new Error(\"expected positive integer\");\n    if (len <= 32) return 32;\n    const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n    const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n    return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction $b8e126da42a4b9e3$var$writeU16BE(num) {\n    if (!Number.isSafeInteger(num) || num < $b8e126da42a4b9e3$var$minPlaintextSize || num > $b8e126da42a4b9e3$var$maxPlaintextSize) throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n    const arr = new Uint8Array(2);\n    new DataView(arr.buffer).setUint16(0, num, false);\n    return arr;\n}\nfunction $b8e126da42a4b9e3$var$pad(plaintext) {\n    const unpadded = $b8e126da42a4b9e3$var$utf8Encoder.encode(plaintext);\n    const unpaddedLen = unpadded.length;\n    const prefix = $b8e126da42a4b9e3$var$writeU16BE(unpaddedLen);\n    const suffix = new Uint8Array($b8e126da42a4b9e3$var$calcPaddedLen(unpaddedLen) - unpaddedLen);\n    return (0, $3Bcdj.concatBytes)(prefix, unpadded, suffix);\n}\nfunction $b8e126da42a4b9e3$var$unpad(padded) {\n    const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n    const unpadded = padded.subarray(2, 2 + unpaddedLen);\n    if (unpaddedLen < $b8e126da42a4b9e3$var$minPlaintextSize || unpaddedLen > $b8e126da42a4b9e3$var$maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + $b8e126da42a4b9e3$var$calcPaddedLen(unpaddedLen)) throw new Error(\"invalid padding\");\n    return $b8e126da42a4b9e3$var$utf8Decoder.decode(unpadded);\n}\nfunction $b8e126da42a4b9e3$var$hmacAad(key, message, aad) {\n    if (aad.length !== 32) throw new Error(\"AAD associated data must be 32 bytes\");\n    const combined = (0, $3Bcdj.concatBytes)(aad, message);\n    return (0, $70Xw9.hmac)((0, $6XnWx.sha256), key, combined);\n}\nfunction $b8e126da42a4b9e3$var$decodePayload(payload) {\n    if (typeof payload !== \"string\") throw new Error(\"payload must be a valid string\");\n    const plen = payload.length;\n    if (plen < 132 || plen > 87472) throw new Error(\"invalid payload length: \" + plen);\n    if (payload[0] === \"#\") throw new Error(\"unknown encryption version\");\n    let data;\n    try {\n        data = (0, $4Dsex.base64).decode(payload);\n    } catch (error) {\n        throw new Error(\"invalid base64: \" + error.message);\n    }\n    const dlen = data.length;\n    if (dlen < 99 || dlen > 65603) throw new Error(\"invalid data length: \" + dlen);\n    const vers = data[0];\n    if (vers !== 2) throw new Error(\"unknown encryption version \" + vers);\n    return {\n        nonce: data.subarray(1, 33),\n        ciphertext: data.subarray(33, -32),\n        mac: data.subarray(-32)\n    };\n}\nfunction $b8e126da42a4b9e3$var$encrypt2(plaintext, conversationKey, nonce = (0, $3Bcdj.randomBytes)(32)) {\n    const { chacha_key: chacha_key, chacha_nonce: chacha_nonce, hmac_key: hmac_key } = $b8e126da42a4b9e3$var$getMessageKeys(conversationKey, nonce);\n    const padded = $b8e126da42a4b9e3$var$pad(plaintext);\n    const ciphertext = (0, $lAjhr.chacha20)(chacha_key, chacha_nonce, padded);\n    const mac = $b8e126da42a4b9e3$var$hmacAad(hmac_key, ciphertext, nonce);\n    return (0, $4Dsex.base64).encode((0, $3Bcdj.concatBytes)(new Uint8Array([\n        2\n    ]), nonce, ciphertext, mac));\n}\nfunction $b8e126da42a4b9e3$var$decrypt2(payload, conversationKey) {\n    const { nonce: nonce, ciphertext: ciphertext, mac: mac } = $b8e126da42a4b9e3$var$decodePayload(payload);\n    const { chacha_key: chacha_key, chacha_nonce: chacha_nonce, hmac_key: hmac_key } = $b8e126da42a4b9e3$var$getMessageKeys(conversationKey, nonce);\n    const calculatedMac = $b8e126da42a4b9e3$var$hmacAad(hmac_key, ciphertext, nonce);\n    if (!(0, $38xio.equalBytes)(calculatedMac, mac)) throw new Error(\"invalid MAC\");\n    const padded = (0, $lAjhr.chacha20)(chacha_key, chacha_nonce, ciphertext);\n    return $b8e126da42a4b9e3$var$unpad(padded);\n}\nvar $b8e126da42a4b9e3$var$v2 = {\n    utils: {\n        getConversationKey: $b8e126da42a4b9e3$var$getConversationKey,\n        calcPaddedLen: $b8e126da42a4b9e3$var$calcPaddedLen\n    },\n    encrypt: $b8e126da42a4b9e3$var$encrypt2,\n    decrypt: $b8e126da42a4b9e3$var$decrypt2\n};\n// nip59.ts\nvar $b8e126da42a4b9e3$var$TWO_DAYS = 172800;\nvar $b8e126da42a4b9e3$var$now = ()=>Math.round(Date.now() / 1e3);\nvar $b8e126da42a4b9e3$var$randomNow = ()=>Math.round($b8e126da42a4b9e3$var$now() - Math.random() * $b8e126da42a4b9e3$var$TWO_DAYS);\nvar $b8e126da42a4b9e3$var$nip44ConversationKey = (privateKey, publicKey)=>$b8e126da42a4b9e3$var$getConversationKey(privateKey, publicKey);\nvar $b8e126da42a4b9e3$var$nip44Encrypt = (data, privateKey, publicKey)=>$b8e126da42a4b9e3$var$encrypt2(JSON.stringify(data), $b8e126da42a4b9e3$var$nip44ConversationKey(privateKey, publicKey));\nvar $b8e126da42a4b9e3$var$nip44Decrypt = (data, privateKey)=>JSON.parse($b8e126da42a4b9e3$var$decrypt2(data.content, $b8e126da42a4b9e3$var$nip44ConversationKey(privateKey, data.pubkey)));\nfunction $b8e126da42a4b9e3$var$createRumor(event, privateKey) {\n    const rumor = {\n        created_at: $b8e126da42a4b9e3$var$now(),\n        content: \"\",\n        tags: [],\n        ...event,\n        pubkey: $b8e126da42a4b9e3$export$889def73691f9837(privateKey)\n    };\n    rumor.id = $b8e126da42a4b9e3$export$11a838ad4e557e0e(rumor);\n    return rumor;\n}\nfunction $b8e126da42a4b9e3$var$createSeal(rumor, privateKey, recipientPublicKey) {\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$Seal,\n        content: $b8e126da42a4b9e3$var$nip44Encrypt(rumor, privateKey, recipientPublicKey),\n        created_at: $b8e126da42a4b9e3$var$randomNow(),\n        tags: []\n    }, privateKey);\n}\nfunction $b8e126da42a4b9e3$var$createWrap(seal, recipientPublicKey) {\n    const randomKey = $b8e126da42a4b9e3$export$16ca411381fc81c8();\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$GiftWrap,\n        content: $b8e126da42a4b9e3$var$nip44Encrypt(seal, randomKey, recipientPublicKey),\n        created_at: $b8e126da42a4b9e3$var$randomNow(),\n        tags: [\n            [\n                \"p\",\n                recipientPublicKey\n            ]\n        ]\n    }, randomKey);\n}\nfunction $b8e126da42a4b9e3$var$wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n    const rumor = $b8e126da42a4b9e3$var$createRumor(event, senderPrivateKey);\n    const seal = $b8e126da42a4b9e3$var$createSeal(rumor, senderPrivateKey, recipientPublicKey);\n    return $b8e126da42a4b9e3$var$createWrap(seal, recipientPublicKey);\n}\nfunction $b8e126da42a4b9e3$var$wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n    if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) throw new Error(\"At least one recipient is required.\");\n    const senderPublicKey = $b8e126da42a4b9e3$export$889def73691f9837(senderPrivateKey);\n    const wrappeds = [\n        $b8e126da42a4b9e3$var$wrapEvent(event, senderPrivateKey, senderPublicKey)\n    ];\n    recipientsPublicKeys.forEach((recipientPublicKey)=>{\n        wrappeds.push($b8e126da42a4b9e3$var$wrapEvent(event, senderPrivateKey, recipientPublicKey));\n    });\n    return wrappeds;\n}\nfunction $b8e126da42a4b9e3$var$unwrapEvent(wrap, recipientPrivateKey) {\n    const unwrappedSeal = $b8e126da42a4b9e3$var$nip44Decrypt(wrap, recipientPrivateKey);\n    return $b8e126da42a4b9e3$var$nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction $b8e126da42a4b9e3$var$unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n    let unwrappedEvents = [];\n    wrappedEvents.forEach((e)=>{\n        unwrappedEvents.push($b8e126da42a4b9e3$var$unwrapEvent(e, recipientPrivateKey));\n    });\n    unwrappedEvents.sort((a, b)=>a.created_at - b.created_at);\n    return unwrappedEvents;\n}\n// nip17.ts\nfunction $b8e126da42a4b9e3$var$createEvent(recipients, message, conversationTitle, replyTo) {\n    const baseEvent = {\n        created_at: Math.ceil(Date.now() / 1e3),\n        kind: $b8e126da42a4b9e3$var$PrivateDirectMessage,\n        tags: [],\n        content: message\n    };\n    const recipientsArray = Array.isArray(recipients) ? recipients : [\n        recipients\n    ];\n    recipientsArray.forEach(({ publicKey: publicKey, relayUrl: relayUrl })=>{\n        baseEvent.tags.push(relayUrl ? [\n            \"p\",\n            publicKey,\n            relayUrl\n        ] : [\n            \"p\",\n            publicKey\n        ]);\n    });\n    if (replyTo) baseEvent.tags.push([\n        \"e\",\n        replyTo.eventId,\n        replyTo.relayUrl || \"\",\n        \"reply\"\n    ]);\n    if (conversationTitle) baseEvent.tags.push([\n        \"subject\",\n        conversationTitle\n    ]);\n    return baseEvent;\n}\nfunction $b8e126da42a4b9e3$var$wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {\n    const event = $b8e126da42a4b9e3$var$createEvent(recipient, message, conversationTitle, replyTo);\n    return $b8e126da42a4b9e3$var$wrapEvent(event, senderPrivateKey, recipient.publicKey);\n}\nfunction $b8e126da42a4b9e3$var$wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {\n    if (!recipients || recipients.length === 0) throw new Error(\"At least one recipient is required.\");\n    const senderPublicKey = $b8e126da42a4b9e3$export$889def73691f9837(senderPrivateKey);\n    return [\n        {\n            publicKey: senderPublicKey\n        },\n        ...recipients\n    ].map((recipient)=>$b8e126da42a4b9e3$var$wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo));\n}\nvar $b8e126da42a4b9e3$var$unwrapEvent2 = $b8e126da42a4b9e3$var$unwrapEvent;\nvar $b8e126da42a4b9e3$var$unwrapManyEvents2 = $b8e126da42a4b9e3$var$unwrapManyEvents;\n// nip18.ts\nvar $b8e126da42a4b9e3$export$4ea8e35b5adc7369 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$4ea8e35b5adc7369, {\n    finishRepostEvent: ()=>$b8e126da42a4b9e3$var$finishRepostEvent,\n    getRepostedEvent: ()=>$b8e126da42a4b9e3$var$getRepostedEvent,\n    getRepostedEventPointer: ()=>$b8e126da42a4b9e3$var$getRepostedEventPointer\n});\nfunction $b8e126da42a4b9e3$var$finishRepostEvent(t, reposted, relayUrl, privateKey) {\n    let kind;\n    const tags = [\n        ...t.tags ?? [],\n        [\n            \"e\",\n            reposted.id,\n            relayUrl\n        ],\n        [\n            \"p\",\n            reposted.pubkey\n        ]\n    ];\n    if (reposted.kind === $b8e126da42a4b9e3$var$ShortTextNote) kind = $b8e126da42a4b9e3$var$Repost;\n    else {\n        kind = $b8e126da42a4b9e3$var$GenericRepost;\n        tags.push([\n            \"k\",\n            String(reposted.kind)\n        ]);\n    }\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: kind,\n        tags: tags,\n        content: t.content === \"\" || reposted.tags?.find((tag)=>tag[0] === \"-\") ? \"\" : JSON.stringify(reposted),\n        created_at: t.created_at\n    }, privateKey);\n}\nfunction $b8e126da42a4b9e3$var$getRepostedEventPointer(event) {\n    if (![\n        $b8e126da42a4b9e3$var$Repost,\n        $b8e126da42a4b9e3$var$GenericRepost\n    ].includes(event.kind)) return void 0;\n    let lastETag;\n    let lastPTag;\n    for(let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--){\n        const tag = event.tags[i2];\n        if (tag.length >= 2) {\n            if (tag[0] === \"e\" && lastETag === void 0) lastETag = tag;\n            else if (tag[0] === \"p\" && lastPTag === void 0) lastPTag = tag;\n        }\n    }\n    if (lastETag === void 0) return void 0;\n    return {\n        id: lastETag[1],\n        relays: [\n            lastETag[2],\n            lastPTag?.[2]\n        ].filter((x)=>typeof x === \"string\"),\n        author: lastPTag?.[1]\n    };\n}\nfunction $b8e126da42a4b9e3$var$getRepostedEvent(event, { skipVerification: skipVerification } = {}) {\n    const pointer = $b8e126da42a4b9e3$var$getRepostedEventPointer(event);\n    if (pointer === void 0 || event.content === \"\") return void 0;\n    let repostedEvent;\n    try {\n        repostedEvent = JSON.parse(event.content);\n    } catch (error) {\n        return void 0;\n    }\n    if (repostedEvent.id !== pointer.id) return void 0;\n    if (!skipVerification && !$b8e126da42a4b9e3$export$909d658b5069e986(repostedEvent)) return void 0;\n    return repostedEvent;\n}\n// nip21.ts\nvar $b8e126da42a4b9e3$export$60e8a8091cb0f224 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$60e8a8091cb0f224, {\n    NOSTR_URI_REGEX: ()=>$b8e126da42a4b9e3$var$NOSTR_URI_REGEX,\n    parse: ()=>$b8e126da42a4b9e3$var$parse2,\n    test: ()=>$b8e126da42a4b9e3$var$test\n});\nvar $b8e126da42a4b9e3$var$NOSTR_URI_REGEX = new RegExp(`nostr:(${$b8e126da42a4b9e3$var$BECH32_REGEX.source})`);\nfunction $b8e126da42a4b9e3$var$test(value) {\n    return typeof value === \"string\" && new RegExp(`^${$b8e126da42a4b9e3$var$NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction $b8e126da42a4b9e3$var$parse2(uri) {\n    const match = uri.match(new RegExp(`^${$b8e126da42a4b9e3$var$NOSTR_URI_REGEX.source}$`));\n    if (!match) throw new Error(`Invalid Nostr URI: ${uri}`);\n    return {\n        uri: match[0],\n        value: match[1],\n        decoded: $b8e126da42a4b9e3$var$decode(match[1])\n    };\n}\n// nip25.ts\nvar $b8e126da42a4b9e3$export$b1c1f2c9e30679b1 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$b1c1f2c9e30679b1, {\n    finishReactionEvent: ()=>$b8e126da42a4b9e3$var$finishReactionEvent,\n    getReactedEventPointer: ()=>$b8e126da42a4b9e3$var$getReactedEventPointer\n});\nfunction $b8e126da42a4b9e3$var$finishReactionEvent(t, reacted, privateKey) {\n    const inheritedTags = reacted.tags.filter((tag)=>tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        ...t,\n        kind: $b8e126da42a4b9e3$var$Reaction,\n        tags: [\n            ...t.tags ?? [],\n            ...inheritedTags,\n            [\n                \"e\",\n                reacted.id\n            ],\n            [\n                \"p\",\n                reacted.pubkey\n            ]\n        ],\n        content: t.content ?? \"+\"\n    }, privateKey);\n}\nfunction $b8e126da42a4b9e3$var$getReactedEventPointer(event) {\n    if (event.kind !== $b8e126da42a4b9e3$var$Reaction) return void 0;\n    let lastETag;\n    let lastPTag;\n    for(let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--){\n        const tag = event.tags[i2];\n        if (tag.length >= 2) {\n            if (tag[0] === \"e\" && lastETag === void 0) lastETag = tag;\n            else if (tag[0] === \"p\" && lastPTag === void 0) lastPTag = tag;\n        }\n    }\n    if (lastETag === void 0 || lastPTag === void 0) return void 0;\n    return {\n        id: lastETag[1],\n        relays: [\n            lastETag[2],\n            lastPTag[2]\n        ].filter((x)=>x !== void 0),\n        author: lastPTag[1]\n    };\n}\n// nip27.ts\nvar $b8e126da42a4b9e3$export$9ccc31c93a561269 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$9ccc31c93a561269, {\n    parse: ()=>$b8e126da42a4b9e3$var$parse3\n});\nvar $b8e126da42a4b9e3$var$noCharacter = /\\W/m;\nvar $b8e126da42a4b9e3$var$noURLCharacter = /\\W |\\W$|$|,| /m;\nfunction* $b8e126da42a4b9e3$var$parse3(content) {\n    const max = content.length;\n    let prevIndex = 0;\n    let index = 0;\n    while(index < max){\n        let u = content.indexOf(\":\", index);\n        if (u === -1) break;\n        if (content.substring(u - 5, u) === \"nostr\") {\n            const m = content.substring(u + 60).match($b8e126da42a4b9e3$var$noCharacter);\n            const end = m ? u + 60 + m.index : max;\n            try {\n                let pointer;\n                let { data: data, type: type } = $b8e126da42a4b9e3$var$decode(content.substring(u + 1, end));\n                switch(type){\n                    case \"npub\":\n                        pointer = {\n                            pubkey: data\n                        };\n                        break;\n                    case \"nsec\":\n                    case \"note\":\n                        index = end + 1;\n                        continue;\n                    default:\n                        pointer = data;\n                }\n                if (prevIndex !== u - 5) yield {\n                    type: \"text\",\n                    text: content.substring(prevIndex, u - 5)\n                };\n                yield {\n                    type: \"reference\",\n                    pointer: pointer\n                };\n                index = end;\n                prevIndex = index;\n                continue;\n            } catch (_err) {\n                index = u + 1;\n                continue;\n            }\n        } else if (content.substring(u - 5, u) === \"https\" || content.substring(u - 4, u) === \"http\") {\n            const m = content.substring(u + 4).match($b8e126da42a4b9e3$var$noURLCharacter);\n            const end = m ? u + 4 + m.index : max;\n            const prefixLen = content[u - 1] === \"s\" ? 5 : 4;\n            try {\n                let url = new URL(content.substring(u - prefixLen, end));\n                if (url.hostname.indexOf(\".\") === -1) throw new Error(\"invalid url\");\n                if (prevIndex !== u - prefixLen) yield {\n                    type: \"text\",\n                    text: content.substring(prevIndex, u - prefixLen)\n                };\n                if (url.pathname.endsWith(\".png\") || url.pathname.endsWith(\".jpg\") || url.pathname.endsWith(\".jpeg\") || url.pathname.endsWith(\".gif\") || url.pathname.endsWith(\".webp\")) {\n                    yield {\n                        type: \"image\",\n                        url: url.toString()\n                    };\n                    index = end;\n                    prevIndex = index;\n                    continue;\n                }\n                if (url.pathname.endsWith(\".mp4\") || url.pathname.endsWith(\".avi\") || url.pathname.endsWith(\".webm\") || url.pathname.endsWith(\".mkv\")) {\n                    yield {\n                        type: \"video\",\n                        url: url.toString()\n                    };\n                    index = end;\n                    prevIndex = index;\n                    continue;\n                }\n                if (url.pathname.endsWith(\".mp3\") || url.pathname.endsWith(\".aac\") || url.pathname.endsWith(\".ogg\") || url.pathname.endsWith(\".opus\")) {\n                    yield {\n                        type: \"audio\",\n                        url: url.toString()\n                    };\n                    index = end;\n                    prevIndex = index;\n                    continue;\n                }\n                yield {\n                    type: \"url\",\n                    url: url.toString()\n                };\n                index = end;\n                prevIndex = index;\n                continue;\n            } catch (_err) {\n                index = end + 1;\n                continue;\n            }\n        } else if (content.substring(u - 3, u) === \"wss\" || content.substring(u - 2, u) === \"ws\") {\n            const m = content.substring(u + 4).match($b8e126da42a4b9e3$var$noURLCharacter);\n            const end = m ? u + 4 + m.index : max;\n            const prefixLen = content[u - 1] === \"s\" ? 3 : 2;\n            try {\n                let url = new URL(content.substring(u - prefixLen, end));\n                if (url.hostname.indexOf(\".\") === -1) throw new Error(\"invalid ws url\");\n                if (prevIndex !== u - prefixLen) yield {\n                    type: \"text\",\n                    text: content.substring(prevIndex, u - prefixLen)\n                };\n                yield {\n                    type: \"relay\",\n                    url: url.toString()\n                };\n                index = end;\n                prevIndex = index;\n                continue;\n            } catch (_err) {\n                index = end + 1;\n                continue;\n            }\n        } else {\n            index = u + 1;\n            continue;\n        }\n    }\n    if (prevIndex !== max) yield {\n        type: \"text\",\n        text: content.substring(prevIndex)\n    };\n}\n// nip28.ts\nvar $b8e126da42a4b9e3$export$7071f77a07a6a6f4 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$7071f77a07a6a6f4, {\n    channelCreateEvent: ()=>$b8e126da42a4b9e3$var$channelCreateEvent,\n    channelHideMessageEvent: ()=>$b8e126da42a4b9e3$var$channelHideMessageEvent,\n    channelMessageEvent: ()=>$b8e126da42a4b9e3$var$channelMessageEvent,\n    channelMetadataEvent: ()=>$b8e126da42a4b9e3$var$channelMetadataEvent,\n    channelMuteUserEvent: ()=>$b8e126da42a4b9e3$var$channelMuteUserEvent\n});\nvar $b8e126da42a4b9e3$var$channelCreateEvent = (t, privateKey)=>{\n    let content;\n    if (typeof t.content === \"object\") content = JSON.stringify(t.content);\n    else if (typeof t.content === \"string\") content = t.content;\n    else return void 0;\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$ChannelCreation,\n        tags: [\n            ...t.tags ?? []\n        ],\n        content: content,\n        created_at: t.created_at\n    }, privateKey);\n};\nvar $b8e126da42a4b9e3$var$channelMetadataEvent = (t, privateKey)=>{\n    let content;\n    if (typeof t.content === \"object\") content = JSON.stringify(t.content);\n    else if (typeof t.content === \"string\") content = t.content;\n    else return void 0;\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$ChannelMetadata,\n        tags: [\n            [\n                \"e\",\n                t.channel_create_event_id\n            ],\n            ...t.tags ?? []\n        ],\n        content: content,\n        created_at: t.created_at\n    }, privateKey);\n};\nvar $b8e126da42a4b9e3$var$channelMessageEvent = (t, privateKey)=>{\n    const tags = [\n        [\n            \"e\",\n            t.channel_create_event_id,\n            t.relay_url,\n            \"root\"\n        ]\n    ];\n    if (t.reply_to_channel_message_event_id) tags.push([\n        \"e\",\n        t.reply_to_channel_message_event_id,\n        t.relay_url,\n        \"reply\"\n    ]);\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$ChannelMessage,\n        tags: [\n            ...tags,\n            ...t.tags ?? []\n        ],\n        content: t.content,\n        created_at: t.created_at\n    }, privateKey);\n};\nvar $b8e126da42a4b9e3$var$channelHideMessageEvent = (t, privateKey)=>{\n    let content;\n    if (typeof t.content === \"object\") content = JSON.stringify(t.content);\n    else if (typeof t.content === \"string\") content = t.content;\n    else return void 0;\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$ChannelHideMessage,\n        tags: [\n            [\n                \"e\",\n                t.channel_message_event_id\n            ],\n            ...t.tags ?? []\n        ],\n        content: content,\n        created_at: t.created_at\n    }, privateKey);\n};\nvar $b8e126da42a4b9e3$var$channelMuteUserEvent = (t, privateKey)=>{\n    let content;\n    if (typeof t.content === \"object\") content = JSON.stringify(t.content);\n    else if (typeof t.content === \"string\") content = t.content;\n    else return void 0;\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20({\n        kind: $b8e126da42a4b9e3$var$ChannelMuteUser,\n        tags: [\n            [\n                \"p\",\n                t.pubkey_to_mute\n            ],\n            ...t.tags ?? []\n        ],\n        content: content,\n        created_at: t.created_at\n    }, privateKey);\n};\n// nip30.ts\nvar $b8e126da42a4b9e3$export$66c1afb78a5c4d11 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$66c1afb78a5c4d11, {\n    EMOJI_SHORTCODE_REGEX: ()=>$b8e126da42a4b9e3$var$EMOJI_SHORTCODE_REGEX,\n    matchAll: ()=>$b8e126da42a4b9e3$var$matchAll,\n    regex: ()=>$b8e126da42a4b9e3$var$regex,\n    replaceAll: ()=>$b8e126da42a4b9e3$var$replaceAll\n});\nvar $b8e126da42a4b9e3$var$EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar $b8e126da42a4b9e3$var$regex = ()=>new RegExp(`\\\\B${$b8e126da42a4b9e3$var$EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* $b8e126da42a4b9e3$var$matchAll(content) {\n    const matches = content.matchAll($b8e126da42a4b9e3$var$regex());\n    for (const match of matches)try {\n        const [shortcode, name] = match;\n        yield {\n            shortcode: shortcode,\n            name: name,\n            start: match.index,\n            end: match.index + shortcode.length\n        };\n    } catch (_e) {}\n}\nfunction $b8e126da42a4b9e3$var$replaceAll(content, replacer) {\n    return content.replaceAll($b8e126da42a4b9e3$var$regex(), (shortcode, name)=>{\n        return replacer({\n            shortcode: shortcode,\n            name: name\n        });\n    });\n}\n// nip39.ts\nvar $b8e126da42a4b9e3$export$13ad325f8a2de8f7 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$13ad325f8a2de8f7, {\n    useFetchImplementation: ()=>$b8e126da42a4b9e3$var$useFetchImplementation3,\n    validateGithub: ()=>$b8e126da42a4b9e3$var$validateGithub\n});\nvar $b8e126da42a4b9e3$var$_fetch3;\ntry {\n    $b8e126da42a4b9e3$var$_fetch3 = fetch;\n} catch  {}\nfunction $b8e126da42a4b9e3$var$useFetchImplementation3(fetchImplementation) {\n    $b8e126da42a4b9e3$var$_fetch3 = fetchImplementation;\n}\nasync function $b8e126da42a4b9e3$var$validateGithub(pubkey, username, proof) {\n    try {\n        let res = await (await $b8e126da42a4b9e3$var$_fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n        return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n    } catch (_) {\n        return false;\n    }\n}\n// nip47.ts\nvar $b8e126da42a4b9e3$export$ae4a1ae308afd39c = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$ae4a1ae308afd39c, {\n    makeNwcRequestEvent: ()=>$b8e126da42a4b9e3$var$makeNwcRequestEvent,\n    parseConnectionString: ()=>$b8e126da42a4b9e3$var$parseConnectionString\n});\nfunction $b8e126da42a4b9e3$var$parseConnectionString(connectionString) {\n    const { pathname: pathname, searchParams: searchParams } = new URL(connectionString);\n    const pubkey = pathname;\n    const relay = searchParams.get(\"relay\");\n    const secret = searchParams.get(\"secret\");\n    if (!pubkey || !relay || !secret) throw new Error(\"invalid connection string\");\n    return {\n        pubkey: pubkey,\n        relay: relay,\n        secret: secret\n    };\n}\nasync function $b8e126da42a4b9e3$var$makeNwcRequestEvent(pubkey, secretKey, invoice) {\n    const content = {\n        method: \"pay_invoice\",\n        params: {\n            invoice: invoice\n        }\n    };\n    const encryptedContent = $b8e126da42a4b9e3$var$encrypt(secretKey, pubkey, JSON.stringify(content));\n    const eventTemplate = {\n        kind: $b8e126da42a4b9e3$var$NWCWalletRequest,\n        created_at: Math.round(Date.now() / 1e3),\n        content: encryptedContent,\n        tags: [\n            [\n                \"p\",\n                pubkey\n            ]\n        ]\n    };\n    return $b8e126da42a4b9e3$export$bc33d3bdc1ddcd20(eventTemplate, secretKey);\n}\n// nip54.ts\nvar $b8e126da42a4b9e3$export$bfde88566f6f2a51 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$bfde88566f6f2a51, {\n    normalizeIdentifier: ()=>$b8e126da42a4b9e3$var$normalizeIdentifier\n});\nfunction $b8e126da42a4b9e3$var$normalizeIdentifier(name) {\n    name = name.trim().toLowerCase();\n    name = name.normalize(\"NFKC\");\n    return Array.from(name).map((char)=>{\n        if (/\\p{Letter}/u.test(char) || /\\p{Number}/u.test(char)) return char;\n        return \"-\";\n    }).join(\"\");\n}\n// nip57.ts\nvar $b8e126da42a4b9e3$export$14e0982e3a536e29 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$14e0982e3a536e29, {\n    getSatoshisAmountFromBolt11: ()=>$b8e126da42a4b9e3$var$getSatoshisAmountFromBolt11,\n    getZapEndpoint: ()=>$b8e126da42a4b9e3$var$getZapEndpoint,\n    makeZapReceipt: ()=>$b8e126da42a4b9e3$var$makeZapReceipt,\n    makeZapRequest: ()=>$b8e126da42a4b9e3$var$makeZapRequest,\n    useFetchImplementation: ()=>$b8e126da42a4b9e3$var$useFetchImplementation4,\n    validateZapRequest: ()=>$b8e126da42a4b9e3$var$validateZapRequest\n});\nvar $b8e126da42a4b9e3$var$_fetch4;\ntry {\n    $b8e126da42a4b9e3$var$_fetch4 = fetch;\n} catch  {}\nfunction $b8e126da42a4b9e3$var$useFetchImplementation4(fetchImplementation) {\n    $b8e126da42a4b9e3$var$_fetch4 = fetchImplementation;\n}\nasync function $b8e126da42a4b9e3$var$getZapEndpoint(metadata) {\n    try {\n        let lnurl = \"\";\n        let { lud06: lud06, lud16: lud16 } = JSON.parse(metadata.content);\n        if (lud06) {\n            let { words: words } = (0, $4Dsex.bech32).decode(lud06, 1e3);\n            let data = (0, $4Dsex.bech32).fromWords(words);\n            lnurl = $b8e126da42a4b9e3$var$utf8Decoder.decode(data);\n        } else if (lud16) {\n            let [name, domain] = lud16.split(\"@\");\n            lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n        } else return null;\n        let res = await $b8e126da42a4b9e3$var$_fetch4(lnurl);\n        let body = await res.json();\n        if (body.allowsNostr && body.nostrPubkey) return body.callback;\n    } catch (err) {}\n    return null;\n}\nfunction $b8e126da42a4b9e3$var$makeZapRequest({ profile: profile, event: event, amount: amount, relays: relays, comment: comment = \"\" }) {\n    if (!amount) throw new Error(\"amount not given\");\n    if (!profile) throw new Error(\"profile not given\");\n    let zr = {\n        kind: 9734,\n        created_at: Math.round(Date.now() / 1e3),\n        content: comment,\n        tags: [\n            [\n                \"p\",\n                profile\n            ],\n            [\n                \"amount\",\n                amount.toString()\n            ],\n            [\n                \"relays\",\n                ...relays\n            ]\n        ]\n    };\n    if (event && typeof event === \"string\") zr.tags.push([\n        \"e\",\n        event\n    ]);\n    if (event && typeof event === \"object\") {\n        if ($b8e126da42a4b9e3$var$isReplaceableKind(event.kind)) {\n            const a = [\n                \"a\",\n                `${event.kind}:${event.pubkey}:`\n            ];\n            zr.tags.push(a);\n        } else if ($b8e126da42a4b9e3$var$isAddressableKind(event.kind)) {\n            let d = event.tags.find(([t, v])=>t === \"d\" && v);\n            if (!d) throw new Error(\"d tag not found or is empty\");\n            const a = [\n                \"a\",\n                `${event.kind}:${event.pubkey}:${d[1]}`\n            ];\n            zr.tags.push(a);\n        }\n    }\n    return zr;\n}\nfunction $b8e126da42a4b9e3$var$validateZapRequest(zapRequestString) {\n    let zapRequest;\n    try {\n        zapRequest = JSON.parse(zapRequestString);\n    } catch (err) {\n        return \"Invalid zap request JSON.\";\n    }\n    if (!$b8e126da42a4b9e3$export$d08d852dd562b1ce(zapRequest)) return \"Zap request is not a valid Nostr event.\";\n    if (!$b8e126da42a4b9e3$export$909d658b5069e986(zapRequest)) return \"Invalid signature on zap request.\";\n    let p = zapRequest.tags.find(([t, v])=>t === \"p\" && v);\n    if (!p) return \"Zap request doesn't have a 'p' tag.\";\n    if (!p[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'p' tag is not valid hex.\";\n    let e = zapRequest.tags.find(([t, v])=>t === \"e\" && v);\n    if (e && !e[1].match(/^[a-f0-9]{64}$/)) return \"Zap request 'e' tag is not valid hex.\";\n    let relays = zapRequest.tags.find(([t, v])=>t === \"relays\" && v);\n    if (!relays) return \"Zap request doesn't have a 'relays' tag.\";\n    return null;\n}\nfunction $b8e126da42a4b9e3$var$makeZapReceipt({ zapRequest: zapRequest, preimage: preimage, bolt11: bolt11, paidAt: paidAt }) {\n    let zr = JSON.parse(zapRequest);\n    let tagsFromZapRequest = zr.tags.filter(([t])=>t === \"e\" || t === \"p\" || t === \"a\");\n    let zap = {\n        kind: 9735,\n        created_at: Math.round(paidAt.getTime() / 1e3),\n        content: \"\",\n        tags: [\n            ...tagsFromZapRequest,\n            [\n                \"P\",\n                zr.pubkey\n            ],\n            [\n                \"bolt11\",\n                bolt11\n            ],\n            [\n                \"description\",\n                zapRequest\n            ]\n        ]\n    };\n    if (preimage) zap.tags.push([\n        \"preimage\",\n        preimage\n    ]);\n    return zap;\n}\nfunction $b8e126da42a4b9e3$var$getSatoshisAmountFromBolt11(bolt11) {\n    if (bolt11.length < 50) return 0;\n    bolt11 = bolt11.substring(0, 50);\n    const idx = bolt11.lastIndexOf(\"1\");\n    if (idx === -1) return 0;\n    const hrp = bolt11.substring(0, idx);\n    if (!hrp.startsWith(\"lnbc\")) return 0;\n    const amount = hrp.substring(4);\n    if (amount.length < 1) return 0;\n    const char = amount[amount.length - 1];\n    const digit = char.charCodeAt(0) - \"0\".charCodeAt(0);\n    const isDigit = digit >= 0 && digit <= 9;\n    let cutPoint = amount.length - 1;\n    if (isDigit) cutPoint++;\n    if (cutPoint < 1) return 0;\n    const num = parseInt(amount.substring(0, cutPoint));\n    switch(char){\n        case \"m\":\n            return num * 1e5;\n        case \"u\":\n            return num * 100;\n        case \"n\":\n            return num / 10;\n        case \"p\":\n            return num / 1e4;\n        default:\n            return num * 1e8;\n    }\n}\n// nip98.ts\nvar $b8e126da42a4b9e3$export$dbfcdd2f6b6e41d9 = {};\n$b8e126da42a4b9e3$var$__export($b8e126da42a4b9e3$export$dbfcdd2f6b6e41d9, {\n    getToken: ()=>$b8e126da42a4b9e3$var$getToken,\n    hashPayload: ()=>$b8e126da42a4b9e3$var$hashPayload,\n    unpackEventFromToken: ()=>$b8e126da42a4b9e3$var$unpackEventFromToken,\n    validateEvent: ()=>$b8e126da42a4b9e3$var$validateEvent2,\n    validateEventKind: ()=>$b8e126da42a4b9e3$var$validateEventKind,\n    validateEventMethodTag: ()=>$b8e126da42a4b9e3$var$validateEventMethodTag,\n    validateEventPayloadTag: ()=>$b8e126da42a4b9e3$var$validateEventPayloadTag,\n    validateEventTimestamp: ()=>$b8e126da42a4b9e3$var$validateEventTimestamp,\n    validateEventUrlTag: ()=>$b8e126da42a4b9e3$var$validateEventUrlTag,\n    validateToken: ()=>$b8e126da42a4b9e3$var$validateToken\n});\nvar $b8e126da42a4b9e3$var$_authorizationScheme = \"Nostr \";\nasync function $b8e126da42a4b9e3$var$getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n    const event = {\n        kind: $b8e126da42a4b9e3$var$HTTPAuth,\n        tags: [\n            [\n                \"u\",\n                loginUrl\n            ],\n            [\n                \"method\",\n                httpMethod\n            ]\n        ],\n        created_at: Math.round(new Date().getTime() / 1e3),\n        content: \"\"\n    };\n    if (payload) event.tags.push([\n        \"payload\",\n        $b8e126da42a4b9e3$var$hashPayload(payload)\n    ]);\n    const signedEvent = await sign(event);\n    const authorizationScheme = includeAuthorizationScheme ? $b8e126da42a4b9e3$var$_authorizationScheme : \"\";\n    return authorizationScheme + (0, $4Dsex.base64).encode($b8e126da42a4b9e3$var$utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function $b8e126da42a4b9e3$var$validateToken(token, url, method) {\n    const event = await $b8e126da42a4b9e3$var$unpackEventFromToken(token).catch((error)=>{\n        throw error;\n    });\n    const valid = await $b8e126da42a4b9e3$var$validateEvent2(event, url, method).catch((error)=>{\n        throw error;\n    });\n    return valid;\n}\nasync function $b8e126da42a4b9e3$var$unpackEventFromToken(token) {\n    if (!token) throw new Error(\"Missing token\");\n    token = token.replace($b8e126da42a4b9e3$var$_authorizationScheme, \"\");\n    const eventB64 = $b8e126da42a4b9e3$var$utf8Decoder.decode((0, $4Dsex.base64).decode(token));\n    if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) throw new Error(\"Invalid token\");\n    const event = JSON.parse(eventB64);\n    return event;\n}\nfunction $b8e126da42a4b9e3$var$validateEventTimestamp(event) {\n    if (!event.created_at) return false;\n    return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction $b8e126da42a4b9e3$var$validateEventKind(event) {\n    return event.kind === $b8e126da42a4b9e3$var$HTTPAuth;\n}\nfunction $b8e126da42a4b9e3$var$validateEventUrlTag(event, url) {\n    const urlTag = event.tags.find((t)=>t[0] === \"u\");\n    if (!urlTag) return false;\n    return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction $b8e126da42a4b9e3$var$validateEventMethodTag(event, method) {\n    const methodTag = event.tags.find((t)=>t[0] === \"method\");\n    if (!methodTag) return false;\n    return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction $b8e126da42a4b9e3$var$hashPayload(payload) {\n    const hash = (0, $6XnWx.sha256)($b8e126da42a4b9e3$var$utf8Encoder.encode(JSON.stringify(payload)));\n    return (0, $3Bcdj.bytesToHex)(hash);\n}\nfunction $b8e126da42a4b9e3$var$validateEventPayloadTag(event, payload) {\n    const payloadTag = event.tags.find((t)=>t[0] === \"payload\");\n    if (!payloadTag) return false;\n    const payloadHash = $b8e126da42a4b9e3$var$hashPayload(payload);\n    return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function $b8e126da42a4b9e3$var$validateEvent2(event, url, method, body) {\n    if (!$b8e126da42a4b9e3$export$909d658b5069e986(event)) throw new Error(\"Invalid nostr event, signature invalid\");\n    if (!$b8e126da42a4b9e3$var$validateEventKind(event)) throw new Error(\"Invalid nostr event, kind invalid\");\n    if (!$b8e126da42a4b9e3$var$validateEventTimestamp(event)) throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n    if (!$b8e126da42a4b9e3$var$validateEventUrlTag(event, url)) throw new Error(\"Invalid nostr event, url tag invalid\");\n    if (!$b8e126da42a4b9e3$var$validateEventMethodTag(event, method)) throw new Error(\"Invalid nostr event, method tag invalid\");\n    if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n        if (!$b8e126da42a4b9e3$var$validateEventPayloadTag(event, body)) throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n    return true;\n}\n\n});\nparcelRegister(\"5r7db\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.encodeToCurve = module.exports.hashToCurve = module.exports.schnorr = module.exports.secp256k1 = void 0;\n\nvar $jYfwB = parcelRequire(\"jYfwB\");\n\nvar $9BbKC = parcelRequire(\"9BbKC\");\n\nvar $2D9sF = parcelRequire(\"2D9sF\");\n\nvar $gNPqy = parcelRequire(\"gNPqy\");\n\nvar $esaJO = parcelRequire(\"esaJO\");\n\nvar $rkPJ6 = parcelRequire(\"rkPJ6\");\n\nvar $7OcHe = parcelRequire(\"7OcHe\");\nconst $3f551179096121b9$var$secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst $3f551179096121b9$var$secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst $3f551179096121b9$var$_1n = BigInt(1);\nconst $3f551179096121b9$var$_2n = BigInt(2);\nconst $3f551179096121b9$var$divNearest = (a, b)=>(a + b / $3f551179096121b9$var$_2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function $3f551179096121b9$var$sqrtMod(y) {\n    const P = $3f551179096121b9$var$secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, $2D9sF.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, $2D9sF.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, $2D9sF.pow2)(b9, $3f551179096121b9$var$_2n, P) * b2 % P;\n    const b22 = (0, $2D9sF.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, $2D9sF.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, $2D9sF.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, $2D9sF.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, $2D9sF.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, $2D9sF.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, $2D9sF.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, $2D9sF.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, $2D9sF.pow2)(t2, $3f551179096121b9$var$_2n, P);\n    if (!$3f551179096121b9$var$Fp.eql($3f551179096121b9$var$Fp.sqr(root), y)) throw new Error('Cannot find square root');\n    return root;\n}\nconst $3f551179096121b9$var$Fp = (0, $2D9sF.Field)($3f551179096121b9$var$secp256k1P, undefined, undefined, {\n    sqrt: $3f551179096121b9$var$sqrtMod\n});\nmodule.exports.secp256k1 = (0, $7OcHe.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp: $3f551179096121b9$var$Fp,\n    n: $3f551179096121b9$var$secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k)=>{\n            const n = $3f551179096121b9$var$secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -$3f551179096121b9$var$_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = $3f551179096121b9$var$divNearest(b2 * k, n);\n            const c2 = $3f551179096121b9$var$divNearest(-b1 * k, n);\n            let k1 = (0, $2D9sF.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, $2D9sF.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            return {\n                k1neg: k1neg,\n                k1: k1,\n                k2neg: k2neg,\n                k2: k2\n            };\n        }\n    }\n}, $jYfwB.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst $3f551179096121b9$var$_0n = BigInt(0);\nconst $3f551179096121b9$var$fe = (x)=>typeof x === 'bigint' && $3f551179096121b9$var$_0n < x && x < $3f551179096121b9$var$secp256k1P;\nconst $3f551179096121b9$var$ge = (x)=>typeof x === 'bigint' && $3f551179096121b9$var$_0n < x && x < $3f551179096121b9$var$secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const $3f551179096121b9$var$TAGGED_HASH_PREFIXES = {};\nfunction $3f551179096121b9$var$taggedHash(tag, ...messages) {\n    let tagP = $3f551179096121b9$var$TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, $jYfwB.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, $esaJO.concatBytes)(tagH, tagH);\n        $3f551179096121b9$var$TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, $jYfwB.sha256)((0, $esaJO.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst $3f551179096121b9$var$pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst $3f551179096121b9$var$numTo32b = (n)=>(0, $esaJO.numberToBytesBE)(n, 32);\nconst $3f551179096121b9$var$modP = (x)=>(0, $2D9sF.mod)(x, $3f551179096121b9$var$secp256k1P);\nconst $3f551179096121b9$var$modN = (x)=>(0, $2D9sF.mod)(x, $3f551179096121b9$var$secp256k1N);\nconst $3f551179096121b9$var$Point = module.exports.secp256k1.ProjectivePoint;\nconst $3f551179096121b9$var$GmulAdd = (Q, a, b)=>$3f551179096121b9$var$Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction $3f551179096121b9$var$schnorrGetExtPubKey(priv) {\n    let d_ = module.exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = $3f551179096121b9$var$Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : $3f551179096121b9$var$modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: $3f551179096121b9$var$pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function $3f551179096121b9$var$lift_x(x) {\n    if (!$3f551179096121b9$var$fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = $3f551179096121b9$var$modP(x * x);\n    const c = $3f551179096121b9$var$modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = $3f551179096121b9$var$sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % $3f551179096121b9$var$_2n !== $3f551179096121b9$var$_0n) y = $3f551179096121b9$var$modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new $3f551179096121b9$var$Point(x, y, $3f551179096121b9$var$_1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function $3f551179096121b9$var$challenge(...args) {\n    return $3f551179096121b9$var$modN((0, $esaJO.bytesToNumberBE)($3f551179096121b9$var$taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function $3f551179096121b9$var$schnorrGetPublicKey(privateKey) {\n    return $3f551179096121b9$var$schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function $3f551179096121b9$var$schnorrSign(message, privateKey, auxRand = (0, $9BbKC.randomBytes)(32)) {\n    const m = (0, $esaJO.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = $3f551179096121b9$var$schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, $esaJO.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = $3f551179096121b9$var$numTo32b(d ^ (0, $esaJO.bytesToNumberBE)($3f551179096121b9$var$taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = $3f551179096121b9$var$taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = $3f551179096121b9$var$modN((0, $esaJO.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === $3f551179096121b9$var$_0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = $3f551179096121b9$var$schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = $3f551179096121b9$var$challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set($3f551179096121b9$var$numTo32b($3f551179096121b9$var$modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!$3f551179096121b9$var$schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function $3f551179096121b9$var$schnorrVerify(signature, message, publicKey) {\n    const sig = (0, $esaJO.ensureBytes)('signature', signature, 64);\n    const m = (0, $esaJO.ensureBytes)('message', message);\n    const pub = (0, $esaJO.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = $3f551179096121b9$var$lift_x((0, $esaJO.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, $esaJO.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!$3f551179096121b9$var$fe(r)) return false;\n        const s = (0, $esaJO.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!$3f551179096121b9$var$ge(s)) return false;\n        const e = $3f551179096121b9$var$challenge($3f551179096121b9$var$numTo32b(r), $3f551179096121b9$var$pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = $3f551179096121b9$var$GmulAdd(P, s, $3f551179096121b9$var$modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    } catch (error) {\n        return false;\n    }\n}\nmodule.exports.schnorr = (()=>({\n        getPublicKey: $3f551179096121b9$var$schnorrGetPublicKey,\n        sign: $3f551179096121b9$var$schnorrSign,\n        verify: $3f551179096121b9$var$schnorrVerify,\n        utils: {\n            randomPrivateKey: module.exports.secp256k1.utils.randomPrivateKey,\n            lift_x: $3f551179096121b9$var$lift_x,\n            pointToBytes: $3f551179096121b9$var$pointToBytes,\n            numberToBytesBE: $esaJO.numberToBytesBE,\n            bytesToNumberBE: $esaJO.bytesToNumberBE,\n            taggedHash: $3f551179096121b9$var$taggedHash,\n            mod: $2D9sF.mod\n        }\n    }))();\nconst $3f551179096121b9$var$isoMap = /* @__PURE__ */ (()=>(0, $rkPJ6.isogenyMap)($3f551179096121b9$var$Fp, [\n        // xNum\n        [\n            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'\n        ],\n        // xDen\n        [\n            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n            '0x0000000000000000000000000000000000000000000000000000000000000001'\n        ],\n        // yNum\n        [\n            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'\n        ],\n        // yDen\n        [\n            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n            '0x0000000000000000000000000000000000000000000000000000000000000001'\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst $3f551179096121b9$var$mapSWU = /* @__PURE__ */ (()=>(0, $gNPqy.mapToCurveSimpleSWU)($3f551179096121b9$var$Fp, {\n        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n        B: BigInt('1771'),\n        Z: $3f551179096121b9$var$Fp.create(BigInt('-11'))\n    }))();\nconst $3f551179096121b9$var$htf = /* @__PURE__ */ (()=>(0, $rkPJ6.createHasher)(module.exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x: x, y: y } = $3f551179096121b9$var$mapSWU($3f551179096121b9$var$Fp.create(scalars[0]));\n        return $3f551179096121b9$var$isoMap(x, y);\n    }, {\n        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n        p: $3f551179096121b9$var$Fp.ORDER,\n        m: 1,\n        k: 128,\n        expand: 'xmd',\n        hash: $jYfwB.sha256\n    }))();\nmodule.exports.hashToCurve = (()=>$3f551179096121b9$var$htf.hashToCurve)();\nmodule.exports.encodeToCurve = (()=>$3f551179096121b9$var$htf.encodeToCurve)();\n\n});\nparcelRegister(\"jYfwB\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.sha224 = module.exports.sha256 = void 0;\n\nvar $fwPy5 = parcelRequire(\"fwPy5\");\n\nvar $9BbKC = parcelRequire(\"9BbKC\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst $e89fa9d0527b0915$var$Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst $e89fa9d0527b0915$var$Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst $e89fa9d0527b0915$var$SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst $e89fa9d0527b0915$var$IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst $e89fa9d0527b0915$var$SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass $e89fa9d0527b0915$var$SHA256 extends $fwPy5.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = $e89fa9d0527b0915$var$IV[0] | 0;\n        this.B = $e89fa9d0527b0915$var$IV[1] | 0;\n        this.C = $e89fa9d0527b0915$var$IV[2] | 0;\n        this.D = $e89fa9d0527b0915$var$IV[3] | 0;\n        this.E = $e89fa9d0527b0915$var$IV[4] | 0;\n        this.F = $e89fa9d0527b0915$var$IV[5] | 0;\n        this.G = $e89fa9d0527b0915$var$IV[6] | 0;\n        this.H = $e89fa9d0527b0915$var$IV[7] | 0;\n    }\n    get() {\n        const { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)$e89fa9d0527b0915$var$SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = $e89fa9d0527b0915$var$SHA256_W[i - 15];\n            const W2 = $e89fa9d0527b0915$var$SHA256_W[i - 2];\n            const s0 = (0, $9BbKC.rotr)(W15, 7) ^ (0, $9BbKC.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, $9BbKC.rotr)(W2, 17) ^ (0, $9BbKC.rotr)(W2, 19) ^ W2 >>> 10;\n            $e89fa9d0527b0915$var$SHA256_W[i] = s1 + $e89fa9d0527b0915$var$SHA256_W[i - 7] + s0 + $e89fa9d0527b0915$var$SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, $9BbKC.rotr)(E, 6) ^ (0, $9BbKC.rotr)(E, 11) ^ (0, $9BbKC.rotr)(E, 25);\n            const T1 = H + sigma1 + $e89fa9d0527b0915$var$Chi(E, F, G) + $e89fa9d0527b0915$var$SHA256_K[i] + $e89fa9d0527b0915$var$SHA256_W[i] | 0;\n            const sigma0 = (0, $9BbKC.rotr)(A, 2) ^ (0, $9BbKC.rotr)(A, 13) ^ (0, $9BbKC.rotr)(A, 22);\n            const T2 = sigma0 + $e89fa9d0527b0915$var$Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        $e89fa9d0527b0915$var$SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass $e89fa9d0527b0915$var$SHA224 extends $e89fa9d0527b0915$var$SHA256 {\n    constructor(){\n        super();\n        this.A = -1056596264;\n        this.B = 914150663;\n        this.C = 812702999;\n        this.D = -150054599;\n        this.E = -4191439;\n        this.F = 1750603025;\n        this.G = 1694076839;\n        this.H = -1090891868;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ module.exports.sha256 = (0, $9BbKC.wrapConstructor)(()=>new $e89fa9d0527b0915$var$SHA256());\nmodule.exports.sha224 = (0, $9BbKC.wrapConstructor)(()=>new $e89fa9d0527b0915$var$SHA224());\n\n});\nparcelRegister(\"fwPy5\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.SHA2 = void 0;\n\nvar $dAIf1 = parcelRequire(\"dAIf1\");\n\nvar $9BbKC = parcelRequire(\"9BbKC\");\n// Polyfill for Safari 14\nfunction $b4e1d4aa1af05b71$var$setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass $b4e1d4aa1af05b71$var$SHA2 extends $9BbKC.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, $9BbKC.createView)(this.buffer);\n    }\n    update(data) {\n        (0, $dAIf1.exists)(this);\n        const { view: view, buffer: buffer, blockLen: blockLen } = this;\n        data = (0, $9BbKC.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, $9BbKC.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, $dAIf1.exists)(this);\n        (0, $dAIf1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer: buffer, view: view, blockLen: blockLen, isLE: isLE } = this;\n        let { pos: pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        $b4e1d4aa1af05b71$var$setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, $9BbKC.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer: buffer, outputLen: outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen: blockLen, buffer: buffer, length: length, finished: finished, destroyed: destroyed, pos: pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nmodule.exports.SHA2 = $b4e1d4aa1af05b71$var$SHA2;\n\n});\nparcelRegister(\"dAIf1\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.output = module.exports.exists = module.exports.hash = module.exports.bytes = module.exports.bool = module.exports.number = void 0;\nfunction $9e50f49469d56a92$var$number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nmodule.exports.number = $9e50f49469d56a92$var$number;\nfunction $9e50f49469d56a92$var$bool(b) {\n    if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\nmodule.exports.bool = $9e50f49469d56a92$var$bool;\nfunction $9e50f49469d56a92$var$bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nmodule.exports.bytes = $9e50f49469d56a92$var$bytes;\nfunction $9e50f49469d56a92$var$hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    $9e50f49469d56a92$var$number(hash.outputLen);\n    $9e50f49469d56a92$var$number(hash.blockLen);\n}\nmodule.exports.hash = $9e50f49469d56a92$var$hash;\nfunction $9e50f49469d56a92$var$exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nmodule.exports.exists = $9e50f49469d56a92$var$exists;\nfunction $9e50f49469d56a92$var$output(out, instance) {\n    $9e50f49469d56a92$var$bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n}\nmodule.exports.output = $9e50f49469d56a92$var$output;\nconst $9e50f49469d56a92$var$assert = {\n    number: $9e50f49469d56a92$var$number,\n    bool: $9e50f49469d56a92$var$bool,\n    bytes: $9e50f49469d56a92$var$bytes,\n    hash: $9e50f49469d56a92$var$hash,\n    exists: $9e50f49469d56a92$var$exists,\n    output: $9e50f49469d56a92$var$output\n};\nmodule.exports.default = $9e50f49469d56a92$var$assert;\n\n});\n\nparcelRegister(\"9BbKC\", function(module, exports) {\n\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.randomBytes = module.exports.wrapXOFConstructorWithOpts = module.exports.wrapConstructorWithOpts = module.exports.wrapConstructor = module.exports.checkOpts = module.exports.Hash = module.exports.concatBytes = module.exports.toBytes = module.exports.utf8ToBytes = module.exports.asyncLoop = module.exports.nextTick = module.exports.hexToBytes = module.exports.bytesToHex = module.exports.isLE = module.exports.rotr = module.exports.createView = module.exports.u32 = module.exports.u8 = void 0;\n\nvar $gEhde = parcelRequire(\"gEhde\");\nconst $6fd0af385bc5ccc9$var$u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst $6fd0af385bc5ccc9$var$u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.u8 = $6fd0af385bc5ccc9$var$u8;\nconst $6fd0af385bc5ccc9$var$u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nmodule.exports.u32 = $6fd0af385bc5ccc9$var$u32;\n// Cast array to view\nconst $6fd0af385bc5ccc9$var$createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.createView = $6fd0af385bc5ccc9$var$createView;\n// The rotate right (circular right shift) operation for uint32\nconst $6fd0af385bc5ccc9$var$rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nmodule.exports.rotr = $6fd0af385bc5ccc9$var$rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nmodule.exports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!module.exports.isLE) throw new Error('Non little-endian hardware is not supported');\nconst $6fd0af385bc5ccc9$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $6fd0af385bc5ccc9$var$bytesToHex(bytes) {\n    if (!$6fd0af385bc5ccc9$var$u8a(bytes)) throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $6fd0af385bc5ccc9$var$hexes[bytes[i]];\n    return hex;\n}\nmodule.exports.bytesToHex = $6fd0af385bc5ccc9$var$bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $6fd0af385bc5ccc9$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nmodule.exports.hexToBytes = $6fd0af385bc5ccc9$var$hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst $6fd0af385bc5ccc9$var$nextTick = async ()=>{};\nmodule.exports.nextTick = $6fd0af385bc5ccc9$var$nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function $6fd0af385bc5ccc9$var$asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, module.exports.nextTick)();\n        ts += diff;\n    }\n}\nmodule.exports.asyncLoop = $6fd0af385bc5ccc9$var$asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $6fd0af385bc5ccc9$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nmodule.exports.utf8ToBytes = $6fd0af385bc5ccc9$var$utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function $6fd0af385bc5ccc9$var$toBytes(data) {\n    if (typeof data === 'string') data = $6fd0af385bc5ccc9$var$utf8ToBytes(data);\n    if (!$6fd0af385bc5ccc9$var$u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nmodule.exports.toBytes = $6fd0af385bc5ccc9$var$toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function $6fd0af385bc5ccc9$var$concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!$6fd0af385bc5ccc9$var$u8a(a)) throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nmodule.exports.concatBytes = $6fd0af385bc5ccc9$var$concatBytes;\n// For runtime check if class implements interface\nclass $6fd0af385bc5ccc9$var$Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nmodule.exports.Hash = $6fd0af385bc5ccc9$var$Hash;\nconst $6fd0af385bc5ccc9$var$toStr = {}.toString;\nfunction $6fd0af385bc5ccc9$var$checkOpts(defaults, opts) {\n    if (opts !== undefined && $6fd0af385bc5ccc9$var$toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nmodule.exports.checkOpts = $6fd0af385bc5ccc9$var$checkOpts;\nfunction $6fd0af385bc5ccc9$var$wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update($6fd0af385bc5ccc9$var$toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nmodule.exports.wrapConstructor = $6fd0af385bc5ccc9$var$wrapConstructor;\nfunction $6fd0af385bc5ccc9$var$wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($6fd0af385bc5ccc9$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nmodule.exports.wrapConstructorWithOpts = $6fd0af385bc5ccc9$var$wrapConstructorWithOpts;\nfunction $6fd0af385bc5ccc9$var$wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($6fd0af385bc5ccc9$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nmodule.exports.wrapXOFConstructorWithOpts = $6fd0af385bc5ccc9$var$wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function $6fd0af385bc5ccc9$var$randomBytes(bytesLength = 32) {\n    if ($gEhde.crypto && typeof $gEhde.crypto.getRandomValues === 'function') return $gEhde.crypto.getRandomValues(new Uint8Array(bytesLength));\n    throw new Error('crypto.getRandomValues must be defined');\n}\nmodule.exports.randomBytes = $6fd0af385bc5ccc9$var$randomBytes;\n\n});\nparcelRegister(\"gEhde\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.crypto = void 0;\nmodule.exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n});\n\n\n\n\nparcelRegister(\"2D9sF\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.mapHashToField = module.exports.getMinHashLength = module.exports.getFieldBytesLength = module.exports.hashToPrivateScalar = module.exports.FpSqrtEven = module.exports.FpSqrtOdd = module.exports.Field = module.exports.nLength = module.exports.FpIsSquare = module.exports.FpDiv = module.exports.FpInvertBatch = module.exports.FpPow = module.exports.validateField = module.exports.isNegativeLE = module.exports.FpSqrt = module.exports.tonelliShanks = module.exports.invert = module.exports.pow2 = module.exports.pow = module.exports.mod = void 0;\n\nvar $esaJO = parcelRequire(\"esaJO\");\n// prettier-ignore\nconst $1ea6901afdde618b$var$_0n = BigInt(0), $1ea6901afdde618b$var$_1n = BigInt(1), $1ea6901afdde618b$var$_2n = BigInt(2), $1ea6901afdde618b$var$_3n = BigInt(3);\n// prettier-ignore\nconst $1ea6901afdde618b$var$_4n = BigInt(4), $1ea6901afdde618b$var$_5n = BigInt(5), $1ea6901afdde618b$var$_8n = BigInt(8);\n// prettier-ignore\nconst $1ea6901afdde618b$var$_9n = BigInt(9), $1ea6901afdde618b$var$_16n = BigInt(16);\n// Calculates a modulo b\nfunction $1ea6901afdde618b$var$mod(a, b) {\n    const result = a % b;\n    return result >= $1ea6901afdde618b$var$_0n ? result : b + result;\n}\nmodule.exports.mod = $1ea6901afdde618b$var$mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction $1ea6901afdde618b$var$pow(num, power, modulo) {\n    if (modulo <= $1ea6901afdde618b$var$_0n || power < $1ea6901afdde618b$var$_0n) throw new Error('Expected power/modulo > 0');\n    if (modulo === $1ea6901afdde618b$var$_1n) return $1ea6901afdde618b$var$_0n;\n    let res = $1ea6901afdde618b$var$_1n;\n    while(power > $1ea6901afdde618b$var$_0n){\n        if (power & $1ea6901afdde618b$var$_1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= $1ea6901afdde618b$var$_1n;\n    }\n    return res;\n}\nmodule.exports.pow = $1ea6901afdde618b$var$pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction $1ea6901afdde618b$var$pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > $1ea6901afdde618b$var$_0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nmodule.exports.pow2 = $1ea6901afdde618b$var$pow2;\n// Inverses number over modulo\nfunction $1ea6901afdde618b$var$invert(number, modulo) {\n    if (number === $1ea6901afdde618b$var$_0n || modulo <= $1ea6901afdde618b$var$_0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = $1ea6901afdde618b$var$mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = $1ea6901afdde618b$var$_0n, y = $1ea6901afdde618b$var$_1n, u = $1ea6901afdde618b$var$_1n, v = $1ea6901afdde618b$var$_0n;\n    while(a !== $1ea6901afdde618b$var$_0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== $1ea6901afdde618b$var$_1n) throw new Error('invert: does not exist');\n    return $1ea6901afdde618b$var$mod(x, modulo);\n}\nmodule.exports.invert = $1ea6901afdde618b$var$invert;\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function $1ea6901afdde618b$var$tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - $1ea6901afdde618b$var$_1n) / $1ea6901afdde618b$var$_2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - $1ea6901afdde618b$var$_1n, S = 0; Q % $1ea6901afdde618b$var$_2n === $1ea6901afdde618b$var$_0n; Q /= $1ea6901afdde618b$var$_2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for(Z = $1ea6901afdde618b$var$_2n; Z < P && $1ea6901afdde618b$var$pow(Z, legendreC, P) !== P - $1ea6901afdde618b$var$_1n; Z++);\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + $1ea6901afdde618b$var$_1n) / $1ea6901afdde618b$var$_4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + $1ea6901afdde618b$var$_1n) / $1ea6901afdde618b$var$_2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, $1ea6901afdde618b$var$_1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nmodule.exports.tonelliShanks = $1ea6901afdde618b$var$tonelliShanks;\nfunction $1ea6901afdde618b$var$FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % $1ea6901afdde618b$var$_4n === $1ea6901afdde618b$var$_3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + $1ea6901afdde618b$var$_1n) / $1ea6901afdde618b$var$_4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % $1ea6901afdde618b$var$_8n === $1ea6901afdde618b$var$_5n) {\n        const c1 = (P - $1ea6901afdde618b$var$_5n) / $1ea6901afdde618b$var$_8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, $1ea6901afdde618b$var$_2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, $1ea6901afdde618b$var$_2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    $1ea6901afdde618b$var$_9n;\n    // Other cases: Tonelli-Shanks algorithm\n    return $1ea6901afdde618b$var$tonelliShanks(P);\n}\nmodule.exports.FpSqrt = $1ea6901afdde618b$var$FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst $1ea6901afdde618b$var$isNegativeLE = (num, modulo)=>($1ea6901afdde618b$var$mod(num, modulo) & $1ea6901afdde618b$var$_1n) === $1ea6901afdde618b$var$_1n;\nmodule.exports.isNegativeLE = $1ea6901afdde618b$var$isNegativeLE;\n// prettier-ignore\nconst $1ea6901afdde618b$var$FIELD_FIELDS = [\n    'create',\n    'isValid',\n    'is0',\n    'neg',\n    'inv',\n    'sqrt',\n    'sqr',\n    'eql',\n    'add',\n    'sub',\n    'mul',\n    'pow',\n    'div',\n    'addN',\n    'subN',\n    'mulN',\n    'sqrN'\n];\nfunction $1ea6901afdde618b$var$validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger'\n    };\n    const opts = $1ea6901afdde618b$var$FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, $esaJO.validateObject)(field, opts);\n}\nmodule.exports.validateField = $1ea6901afdde618b$var$validateField;\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function $1ea6901afdde618b$var$FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < $1ea6901afdde618b$var$_0n) throw new Error('Expected power > 0');\n    if (power === $1ea6901afdde618b$var$_0n) return f.ONE;\n    if (power === $1ea6901afdde618b$var$_1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > $1ea6901afdde618b$var$_0n){\n        if (power & $1ea6901afdde618b$var$_1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= $1ea6901afdde618b$var$_1n;\n    }\n    return p;\n}\nmodule.exports.FpPow = $1ea6901afdde618b$var$FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function $1ea6901afdde618b$var$FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nmodule.exports.FpInvertBatch = $1ea6901afdde618b$var$FpInvertBatch;\nfunction $1ea6901afdde618b$var$FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? $1ea6901afdde618b$var$invert(rhs, f.ORDER) : f.inv(rhs));\n}\nmodule.exports.FpDiv = $1ea6901afdde618b$var$FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction $1ea6901afdde618b$var$FpIsSquare(f) {\n    const legendreConst = (f.ORDER - $1ea6901afdde618b$var$_1n) / $1ea6901afdde618b$var$_2n; // Integer arithmetic\n    return (x)=>{\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nmodule.exports.FpIsSquare = $1ea6901afdde618b$var$FpIsSquare;\n// CURVE.n lengths\nfunction $1ea6901afdde618b$var$nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength: nByteLength\n    };\n}\nmodule.exports.nLength = $1ea6901afdde618b$var$nLength;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function $1ea6901afdde618b$var$Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= $1ea6901afdde618b$var$_0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = $1ea6901afdde618b$var$nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = $1ea6901afdde618b$var$FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER: ORDER,\n        BITS: BITS,\n        BYTES: BYTES,\n        MASK: (0, $esaJO.bitMask)(BITS),\n        ZERO: $1ea6901afdde618b$var$_0n,\n        ONE: $1ea6901afdde618b$var$_1n,\n        create: (num)=>$1ea6901afdde618b$var$mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== 'bigint') throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return $1ea6901afdde618b$var$_0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === $1ea6901afdde618b$var$_0n,\n        isOdd: (num)=>(num & $1ea6901afdde618b$var$_1n) === $1ea6901afdde618b$var$_1n,\n        neg: (num)=>$1ea6901afdde618b$var$mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>$1ea6901afdde618b$var$mod(num * num, ORDER),\n        add: (lhs, rhs)=>$1ea6901afdde618b$var$mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>$1ea6901afdde618b$var$mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>$1ea6901afdde618b$var$mod(lhs * rhs, ORDER),\n        pow: (num, power)=>$1ea6901afdde618b$var$FpPow(f, num, power),\n        div: (lhs, rhs)=>$1ea6901afdde618b$var$mod(lhs * $1ea6901afdde618b$var$invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>$1ea6901afdde618b$var$invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),\n        invertBatch: (lst)=>$1ea6901afdde618b$var$FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0, $esaJO.numberToBytesLE)(num, BYTES) : (0, $esaJO.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, $esaJO.bytesToNumberLE)(bytes) : (0, $esaJO.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\nmodule.exports.Field = $1ea6901afdde618b$var$Field;\nfunction $1ea6901afdde618b$var$FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nmodule.exports.FpSqrtOdd = $1ea6901afdde618b$var$FpSqrtOdd;\nfunction $1ea6901afdde618b$var$FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nmodule.exports.FpSqrtEven = $1ea6901afdde618b$var$FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function $1ea6901afdde618b$var$hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, $esaJO.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = $1ea6901afdde618b$var$nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, $esaJO.bytesToNumberLE)(hash) : (0, $esaJO.bytesToNumberBE)(hash);\n    return $1ea6901afdde618b$var$mod(num, groupOrder - $1ea6901afdde618b$var$_1n) + $1ea6901afdde618b$var$_1n;\n}\nmodule.exports.hashToPrivateScalar = $1ea6901afdde618b$var$hashToPrivateScalar;\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function $1ea6901afdde618b$var$getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\nmodule.exports.getFieldBytesLength = $1ea6901afdde618b$var$getFieldBytesLength;\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function $1ea6901afdde618b$var$getMinHashLength(fieldOrder) {\n    const length = $1ea6901afdde618b$var$getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\nmodule.exports.getMinHashLength = $1ea6901afdde618b$var$getMinHashLength;\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function $1ea6901afdde618b$var$mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = $1ea6901afdde618b$var$getFieldBytesLength(fieldOrder);\n    const minLen = $1ea6901afdde618b$var$getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, $esaJO.bytesToNumberBE)(key) : (0, $esaJO.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = $1ea6901afdde618b$var$mod(num, fieldOrder - $1ea6901afdde618b$var$_1n) + $1ea6901afdde618b$var$_1n;\n    return isLE ? (0, $esaJO.numberToBytesLE)(reduced, fieldLen) : (0, $esaJO.numberToBytesBE)(reduced, fieldLen);\n}\nmodule.exports.mapHashToField = $1ea6901afdde618b$var$mapHashToField;\n\n});\nparcelRegister(\"esaJO\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.validateObject = module.exports.createHmacDrbg = module.exports.bitMask = module.exports.bitSet = module.exports.bitGet = module.exports.bitLen = module.exports.utf8ToBytes = module.exports.equalBytes = module.exports.concatBytes = module.exports.ensureBytes = module.exports.numberToVarBytesBE = module.exports.numberToBytesLE = module.exports.numberToBytesBE = module.exports.bytesToNumberLE = module.exports.bytesToNumberBE = module.exports.hexToBytes = module.exports.hexToNumber = module.exports.numberToHexUnpadded = module.exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst $a85c028f110aa8ce$var$_0n = BigInt(0);\nconst $a85c028f110aa8ce$var$_1n = BigInt(1);\nconst $a85c028f110aa8ce$var$_2n = BigInt(2);\nconst $a85c028f110aa8ce$var$u8a = (a)=>a instanceof Uint8Array;\nconst $a85c028f110aa8ce$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $a85c028f110aa8ce$var$bytesToHex(bytes) {\n    if (!$a85c028f110aa8ce$var$u8a(bytes)) throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $a85c028f110aa8ce$var$hexes[bytes[i]];\n    return hex;\n}\nmodule.exports.bytesToHex = $a85c028f110aa8ce$var$bytesToHex;\nfunction $a85c028f110aa8ce$var$numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nmodule.exports.numberToHexUnpadded = $a85c028f110aa8ce$var$numberToHexUnpadded;\nfunction $a85c028f110aa8ce$var$hexToNumber(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nmodule.exports.hexToNumber = $a85c028f110aa8ce$var$hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $a85c028f110aa8ce$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nmodule.exports.hexToBytes = $a85c028f110aa8ce$var$hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction $a85c028f110aa8ce$var$bytesToNumberBE(bytes) {\n    return $a85c028f110aa8ce$var$hexToNumber($a85c028f110aa8ce$var$bytesToHex(bytes));\n}\nmodule.exports.bytesToNumberBE = $a85c028f110aa8ce$var$bytesToNumberBE;\nfunction $a85c028f110aa8ce$var$bytesToNumberLE(bytes) {\n    if (!$a85c028f110aa8ce$var$u8a(bytes)) throw new Error('Uint8Array expected');\n    return $a85c028f110aa8ce$var$hexToNumber($a85c028f110aa8ce$var$bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nmodule.exports.bytesToNumberLE = $a85c028f110aa8ce$var$bytesToNumberLE;\nfunction $a85c028f110aa8ce$var$numberToBytesBE(n, len) {\n    return $a85c028f110aa8ce$var$hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nmodule.exports.numberToBytesBE = $a85c028f110aa8ce$var$numberToBytesBE;\nfunction $a85c028f110aa8ce$var$numberToBytesLE(n, len) {\n    return $a85c028f110aa8ce$var$numberToBytesBE(n, len).reverse();\n}\nmodule.exports.numberToBytesLE = $a85c028f110aa8ce$var$numberToBytesLE;\n// Unpadded, rarely used\nfunction $a85c028f110aa8ce$var$numberToVarBytesBE(n) {\n    return $a85c028f110aa8ce$var$hexToBytes($a85c028f110aa8ce$var$numberToHexUnpadded(n));\n}\nmodule.exports.numberToVarBytesBE = $a85c028f110aa8ce$var$numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function $a85c028f110aa8ce$var$ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') try {\n        res = $a85c028f110aa8ce$var$hexToBytes(hex);\n    } catch (e) {\n        throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n    else if ($a85c028f110aa8ce$var$u8a(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n    else throw new Error(`${title} must be hex string or Uint8Array`);\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nmodule.exports.ensureBytes = $a85c028f110aa8ce$var$ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function $a85c028f110aa8ce$var$concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!$a85c028f110aa8ce$var$u8a(a)) throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nmodule.exports.concatBytes = $a85c028f110aa8ce$var$concatBytes;\nfunction $a85c028f110aa8ce$var$equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length) return false;\n    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;\n    return true;\n}\nmodule.exports.equalBytes = $a85c028f110aa8ce$var$equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $a85c028f110aa8ce$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nmodule.exports.utf8ToBytes = $a85c028f110aa8ce$var$utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */ function $a85c028f110aa8ce$var$bitLen(n) {\n    let len;\n    for(len = 0; n > $a85c028f110aa8ce$var$_0n; n >>= $a85c028f110aa8ce$var$_1n, len += 1);\n    return len;\n}\nmodule.exports.bitLen = $a85c028f110aa8ce$var$bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function $a85c028f110aa8ce$var$bitGet(n, pos) {\n    return n >> BigInt(pos) & $a85c028f110aa8ce$var$_1n;\n}\nmodule.exports.bitGet = $a85c028f110aa8ce$var$bitGet;\n/**\n * Sets single bit at position.\n */ const $a85c028f110aa8ce$var$bitSet = (n, pos, value)=>{\n    return n | (value ? $a85c028f110aa8ce$var$_1n : $a85c028f110aa8ce$var$_0n) << BigInt(pos);\n};\nmodule.exports.bitSet = $a85c028f110aa8ce$var$bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const $a85c028f110aa8ce$var$bitMask = (n)=>($a85c028f110aa8ce$var$_2n << BigInt(n - 1)) - $a85c028f110aa8ce$var$_1n;\nmodule.exports.bitMask = $a85c028f110aa8ce$var$bitMask;\n// DRBG\nconst $a85c028f110aa8ce$var$u8n = (data)=>new Uint8Array(data); // creates Uint8Array\nconst $a85c028f110aa8ce$var$u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function $a85c028f110aa8ce$var$createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = $a85c028f110aa8ce$var$u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = $a85c028f110aa8ce$var$u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = $a85c028f110aa8ce$var$u8n())=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h($a85c028f110aa8ce$var$u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h($a85c028f110aa8ce$var$u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return $a85c028f110aa8ce$var$concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nmodule.exports.createHmacDrbg = $a85c028f110aa8ce$var$createHmacDrbg;\n// Validating curves and fields\nconst $a85c028f110aa8ce$var$validatorFns = {\n    bigint: (val)=>typeof val === 'bigint',\n    function: (val)=>typeof val === 'function',\n    boolean: (val)=>typeof val === 'boolean',\n    string: (val)=>typeof val === 'string',\n    stringOrUint8Array: (val)=>typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction $a85c028f110aa8ce$var$validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = $a85c028f110aa8ce$var$validatorFns[type];\n        if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\nmodule.exports.validateObject = $a85c028f110aa8ce$var$validateObject; // validate type tests\n // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n // // Should fail type-check\n // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n});\n\n\nparcelRegister(\"gNPqy\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.mapToCurveSimpleSWU = module.exports.SWUFpSqrtRatio = module.exports.weierstrass = module.exports.weierstrassPoints = module.exports.DER = void 0;\n\nvar $2D9sF = parcelRequire(\"2D9sF\");\n\nvar $esaJO = parcelRequire(\"esaJO\");\n\nvar $esaJO = parcelRequire(\"esaJO\");\n\nvar $lkFCe = parcelRequire(\"lkFCe\");\nfunction $c3b91d553ab14e64$var$validatePointOpts(curve) {\n    const opts = (0, $lkFCe.validateBasic)(curve);\n    $esaJO.validateObject(opts, {\n        a: 'field',\n        b: 'field'\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function'\n    });\n    const { endo: endo, Fp: Fp, a: a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: $c3b91d553ab14e64$var$b2n, hexToBytes: $c3b91d553ab14e64$var$h2b } = $esaJO;\nmodule.exports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = ''){\n            super(m);\n        }\n    },\n    _parseInt (data) {\n        const { Err: E } = module.exports.DER;\n        if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 128) throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');\n        return {\n            d: $c3b91d553ab14e64$var$b2n(res),\n            l: data.subarray(len + 2)\n        }; // d is data, l is left\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E } = module.exports.DER;\n        const data = typeof hex === 'string' ? $c3b91d553ab14e64$var$h2b(hex) : hex;\n        if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n        if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = module.exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = module.exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n        return {\n            r: r,\n            s: s\n        };\n    },\n    hexFromSig (sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? '00' + s : s;\n        const h = (num)=>{\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst $c3b91d553ab14e64$var$_0n = BigInt(0), $c3b91d553ab14e64$var$_1n = BigInt(1), $c3b91d553ab14e64$var$_2n = BigInt(2), $c3b91d553ab14e64$var$_3n = BigInt(3), $c3b91d553ab14e64$var$_4n = BigInt(4);\nfunction $c3b91d553ab14e64$var$weierstrassPoints(opts) {\n    const CURVE = $c3b91d553ab14e64$var$validatePointOpts(opts);\n    const { Fp: Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return $esaJO.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x: x,\n            y: y\n        };\n    });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const { a: a, b: b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && $c3b91d553ab14e64$var$_0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength: nByteLength, wrapPrivateKey: wrapPrivateKey, n: n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array) key = $esaJO.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num = typeof key === 'bigint' ? key : $esaJO.bytesToNumberBE((0, $esaJO.ensureBytes)('private key', key, nByteLength));\n        } catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey) num = $2D9sF.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error('x required');\n            if (py == null || !Fp.isValid(py)) throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x: x, y: y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n            if (p instanceof Point) throw new Error('projective point not allowed');\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, $esaJO.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x: x, y: y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y: y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a: a, b: b } = CURVE;\n            const b3 = Fp.mul(b, $c3b91d553ab14e64$var$_3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, $c3b91d553ab14e64$var$_3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{\n                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));\n                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === $c3b91d553ab14e64$var$_0n) return I;\n            assertGE(n); // Will throw on 0\n            if (n === $c3b91d553ab14e64$var$_1n) return this;\n            const { endo: endo } = CURVE;\n            if (!endo) return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > $c3b91d553ab14e64$var$_0n || k2 > $c3b91d553ab14e64$var$_0n){\n                if (k1 & $c3b91d553ab14e64$var$_1n) k1p = k1p.add(d);\n                if (k2 & $c3b91d553ab14e64$var$_1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= $c3b91d553ab14e64$var$_1n;\n                k2 >>= $c3b91d553ab14e64$var$_1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo: endo } = CURVE;\n            if (endo) {\n                const { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p: p, f: f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === $c3b91d553ab14e64$var$_0n || a === $c3b91d553ab14e64$var$_1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0) return {\n                x: Fp.ZERO,\n                y: Fp.ZERO\n            };\n            if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n            return {\n                x: ax,\n                y: ay\n            };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree: isTorsionFree } = CURVE;\n            if (cofactor === $c3b91d553ab14e64$var$_1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor: clearCofactor } = CURVE;\n            if (cofactor === $c3b91d553ab14e64$var$_1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return $esaJO.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, $lkFCe.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE: CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        weierstrassEquation: weierstrassEquation,\n        isWithinCurveOrder: isWithinCurveOrder\n    };\n}\nmodule.exports.weierstrassPoints = $c3b91d553ab14e64$var$weierstrassPoints;\nfunction $c3b91d553ab14e64$var$validateOpts(curve) {\n    const opts = (0, $lkFCe.validateBasic)(curve);\n    $esaJO.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function'\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean'\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\nfunction $c3b91d553ab14e64$var$weierstrass(curveDef) {\n    const CURVE = $c3b91d553ab14e64$var$validateOpts(curveDef);\n    const { Fp: Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return $c3b91d553ab14e64$var$_0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return $2D9sF.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return $2D9sF.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar: normPrivateKeyToScalar, weierstrassEquation: weierstrassEquation, isWithinCurveOrder: isWithinCurveOrder } = $c3b91d553ab14e64$var$weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = $esaJO.concatBytes;\n            if (isCompressed) return cat(Uint8Array.from([\n                point.hasEvenY() ? 0x02 : 0x03\n            ]), x);\n            else return cat(Uint8Array.from([\n                0x04\n            ]), x, Fp.toBytes(a.y));\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = $esaJO.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & $c3b91d553ab14e64$var$_1n) === $c3b91d553ab14e64$var$_1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x: x,\n                    y: y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x: x,\n                    y: y\n                };\n            } else throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n        }\n    });\n    const numToNByteStr = (num)=>$esaJO.bytesToHex($esaJO.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> $c3b91d553ab14e64$var$_1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>$esaJO.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, $esaJO.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r: r, s: s } = module.exports.DER.toSig((0, $esaJO.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r: r, s: s, recovery: rec } = this;\n            const h = bits2int_modN((0, $esaJO.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return $esaJO.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return module.exports.DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return $esaJO.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = $2D9sF.getMinHashLength(CURVE.n);\n            return $2D9sF.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA)) throw new Error('first arg must be private key');\n        if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = $esaJO.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = $esaJO.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        if (typeof num !== 'bigint') throw new Error('bigint expected');\n        if (!($c3b91d553ab14e64$var$_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return $esaJO.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            'recovered',\n            'canonical'\n        ].some((k)=>k in opts)) throw new Error('sign() legacy options not supported');\n        const { hash: hash, randomBytes: randomBytes } = CURVE;\n        let { lowS: lowS, prehash: prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, $esaJO.ensureBytes)('msgHash', msgHash);\n        if (prehash) msgHash = (0, $esaJO.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, $esaJO.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = $esaJO.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === $c3b91d553ab14e64$var$_0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === $c3b91d553ab14e64$var$_0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & $c3b91d553ab14e64$var$_1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed: seed,\n            k2sig: k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed: seed, k2sig: k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = $esaJO.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, $esaJO.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, $esaJO.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n        const { lowS: lowS, prehash: prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n            // Since DER can also be 2*nByteLength bytes, we check for it first.\n            try {\n                _sig = Signature.fromDER(sg);\n            } catch (derError) {\n                if (!(derError instanceof module.exports.DER.Err)) throw derError;\n                _sig = Signature.fromCompact(sg);\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r: r, s: s } = sg;\n                _sig = new Signature(r, s);\n            } else throw new Error('PARSE');\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            if (error.message === 'PARSE') throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r: r, s: s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE: CURVE,\n        getPublicKey: getPublicKey,\n        getSharedSecret: getSharedSecret,\n        sign: sign,\n        verify: verify,\n        ProjectivePoint: Point,\n        Signature: Signature,\n        utils: utils\n    };\n}\nmodule.exports.weierstrass = $c3b91d553ab14e64$var$weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function $c3b91d553ab14e64$var$SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = $c3b91d553ab14e64$var$_0n;\n    for(let o = q - $c3b91d553ab14e64$var$_1n; o % $c3b91d553ab14e64$var$_2n === $c3b91d553ab14e64$var$_0n; o /= $c3b91d553ab14e64$var$_2n)l += $c3b91d553ab14e64$var$_1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = $c3b91d553ab14e64$var$_2n << c1 - $c3b91d553ab14e64$var$_1n - $c3b91d553ab14e64$var$_1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * $c3b91d553ab14e64$var$_2n;\n    const c2 = (q - $c3b91d553ab14e64$var$_1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - $c3b91d553ab14e64$var$_1n) / $c3b91d553ab14e64$var$_2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - $c3b91d553ab14e64$var$_1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + $c3b91d553ab14e64$var$_1n) / $c3b91d553ab14e64$var$_2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > $c3b91d553ab14e64$var$_1n; i--){\n            let tv5 = i - $c3b91d553ab14e64$var$_2n; // 18.    tv5 = i - 2\n            tv5 = $c3b91d553ab14e64$var$_2n << tv5 - $c3b91d553ab14e64$var$_1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % $c3b91d553ab14e64$var$_4n === $c3b91d553ab14e64$var$_3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - $c3b91d553ab14e64$var$_3n) / $c3b91d553ab14e64$var$_4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nmodule.exports.SWUFpSqrtRatio = $c3b91d553ab14e64$var$SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function $c3b91d553ab14e64$var$mapToCurveSimpleSWU(Fp, opts) {\n    $2D9sF.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = $c3b91d553ab14e64$var$SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid: isValid, value: value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\nmodule.exports.mapToCurveSimpleSWU = $c3b91d553ab14e64$var$mapToCurveSimpleSWU;\n\n});\nparcelRegister(\"lkFCe\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.validateBasic = exports.wNAF = void 0;\n\nvar $2D9sF = parcelRequire(\"2D9sF\");\n\nvar $esaJO = parcelRequire(\"esaJO\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item)=>{\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W)=>{\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return {\n            windows: windows,\n            windowSize: windowSize\n        };\n    };\n    return {\n        constTimeNegate: constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) // The most important part for const-time getPublicKey\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                else p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p: p,\n                f: f\n            };\n        },\n        wNAFCached (P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) precomputesMap.set(P, transform(comp));\n            }\n            return this.wNAF(W, comp, n);\n        }\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, $2D9sF.validateField)(curve.Fp);\n    (0, $esaJO.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field'\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger'\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, $2D9sF.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        p: curve.Fp.ORDER\n    });\n}\nexports.validateBasic = validateBasic;\n\n});\n\n\nparcelRegister(\"rkPJ6\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.createHasher = module.exports.isogenyMap = module.exports.hash_to_field = module.exports.expand_message_xof = module.exports.expand_message_xmd = void 0;\n\nvar $2D9sF = parcelRequire(\"2D9sF\");\n\nvar $esaJO = parcelRequire(\"esaJO\");\nfunction $0522aeca5769187c$var$validateDST(dst) {\n    if (dst instanceof Uint8Array) return dst;\n    if (typeof dst === 'string') return (0, $esaJO.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst $0522aeca5769187c$var$os2ip = $esaJO.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction $0522aeca5769187c$var$i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    const res = Array.from({\n        length: length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction $0522aeca5769187c$var$strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];\n    return arr;\n}\nfunction $0522aeca5769187c$var$isBytes(item) {\n    if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\nfunction $0522aeca5769187c$var$isNum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction $0522aeca5769187c$var$expand_message_xmd(msg, DST, lenInBytes, H) {\n    $0522aeca5769187c$var$isBytes(msg);\n    $0522aeca5769187c$var$isBytes(DST);\n    $0522aeca5769187c$var$isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0, $esaJO.concatBytes)((0, $esaJO.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255) throw new Error('Invalid xmd length');\n    const DST_prime = (0, $esaJO.concatBytes)(DST, $0522aeca5769187c$var$i2osp(DST.length, 1));\n    const Z_pad = $0522aeca5769187c$var$i2osp(0, r_in_bytes);\n    const l_i_b_str = $0522aeca5769187c$var$i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, $esaJO.concatBytes)(Z_pad, msg, l_i_b_str, $0522aeca5769187c$var$i2osp(0, 1), DST_prime));\n    b[0] = H((0, $esaJO.concatBytes)(b_0, $0522aeca5769187c$var$i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            $0522aeca5769187c$var$strxor(b_0, b[i - 1]),\n            $0522aeca5769187c$var$i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, $esaJO.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, $esaJO.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nmodule.exports.expand_message_xmd = $0522aeca5769187c$var$expand_message_xmd;\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction $0522aeca5769187c$var$expand_message_xof(msg, DST, lenInBytes, k, H) {\n    $0522aeca5769187c$var$isBytes(msg);\n    $0522aeca5769187c$var$isBytes(DST);\n    $0522aeca5769187c$var$isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen: dkLen\n        }).update((0, $esaJO.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update($0522aeca5769187c$var$i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update($0522aeca5769187c$var$i2osp(DST.length, 1)).digest();\n}\nmodule.exports.expand_message_xof = $0522aeca5769187c$var$expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function $0522aeca5769187c$var$hash_to_field(msg, count, options) {\n    (0, $esaJO.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash'\n    });\n    const { p: p, k: k, m: m, hash: hash, expand: expand, DST: _DST } = options;\n    $0522aeca5769187c$var$isBytes(msg);\n    $0522aeca5769187c$var$isNum(count);\n    const DST = $0522aeca5769187c$var$validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') prb = $0522aeca5769187c$var$expand_message_xmd(msg, DST, len_in_bytes, hash);\n    else if (expand === 'xof') prb = $0522aeca5769187c$var$expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    else if (expand === '_internal_pass') // for internal tests only\n    prb = msg;\n    else throw new Error('expand must be \"xmd\" or \"xof\"');\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, $2D9sF.mod)($0522aeca5769187c$var$os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nmodule.exports.hash_to_field = $0522aeca5769187c$var$hash_to_field;\nfunction $0522aeca5769187c$var$isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x: x,\n            y: y\n        };\n    };\n}\nmodule.exports.isogenyMap = $0522aeca5769187c$var$isogenyMap;\nfunction $0522aeca5769187c$var$createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = $0522aeca5769187c$var$hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = $0522aeca5769187c$var$hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n}\nmodule.exports.createHasher = $0522aeca5769187c$var$createHasher;\n\n});\n\nparcelRegister(\"7OcHe\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.createCurve = module.exports.getHash = void 0;\n\nvar $1EIgu = parcelRequire(\"1EIgu\");\n\nvar $9BbKC = parcelRequire(\"9BbKC\");\n\nvar $gNPqy = parcelRequire(\"gNPqy\");\n// connects noble-curves to noble-hashes\nfunction $5af70d1c5fca3e4e$var$getHash(hash) {\n    return {\n        hash: hash,\n        hmac: (key, ...msgs)=>(0, $1EIgu.hmac)(hash, key, (0, $9BbKC.concatBytes)(...msgs)),\n        randomBytes: $9BbKC.randomBytes\n    };\n}\nmodule.exports.getHash = $5af70d1c5fca3e4e$var$getHash;\nfunction $5af70d1c5fca3e4e$var$createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, $gNPqy.weierstrass)({\n            ...curveDef,\n            ...$5af70d1c5fca3e4e$var$getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create: create\n    });\n}\nmodule.exports.createCurve = $5af70d1c5fca3e4e$var$createCurve;\n\n});\nparcelRegister(\"1EIgu\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.hmac = module.exports.HMAC = void 0;\n\nvar $dAIf1 = parcelRequire(\"dAIf1\");\n\nvar $9BbKC = parcelRequire(\"9BbKC\");\n// HMAC (RFC 2104)\nclass $134bdcf9c481be10$var$HMAC extends $9BbKC.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, $dAIf1.hash)(hash);\n        const key = (0, $9BbKC.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, $dAIf1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, $dAIf1.exists)(this);\n        (0, $dAIf1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash: oHash, iHash: iHash, finished: finished, destroyed: destroyed, blockLen: blockLen, outputLen: outputLen } = this;\n        to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nmodule.exports.HMAC = $134bdcf9c481be10$var$HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const $134bdcf9c481be10$var$hmac = (hash, key, message)=>new $134bdcf9c481be10$var$HMAC(hash, key).update(message).digest();\nmodule.exports.hmac = $134bdcf9c481be10$var$hmac;\nmodule.exports.hmac.create = (hash, key)=>new $134bdcf9c481be10$var$HMAC(hash, key);\n\n});\n\n\n\nparcelRegister(\"3Bcdj\", function(module, exports) {\n\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.randomBytes = module.exports.wrapXOFConstructorWithOpts = module.exports.wrapConstructorWithOpts = module.exports.wrapConstructor = module.exports.checkOpts = module.exports.Hash = module.exports.concatBytes = module.exports.toBytes = module.exports.utf8ToBytes = module.exports.asyncLoop = module.exports.nextTick = module.exports.hexToBytes = module.exports.bytesToHex = module.exports.isLE = module.exports.rotr = module.exports.createView = module.exports.u32 = module.exports.u8 = void 0;\n\nvar $dUxV2 = parcelRequire(\"dUxV2\");\nconst $29ee4d3171d9809b$var$u8a = (a)=>a instanceof Uint8Array;\n// Cast array to different type\nconst $29ee4d3171d9809b$var$u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.u8 = $29ee4d3171d9809b$var$u8;\nconst $29ee4d3171d9809b$var$u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nmodule.exports.u32 = $29ee4d3171d9809b$var$u32;\n// Cast array to view\nconst $29ee4d3171d9809b$var$createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.createView = $29ee4d3171d9809b$var$createView;\n// The rotate right (circular right shift) operation for uint32\nconst $29ee4d3171d9809b$var$rotr = (word, shift)=>word << 32 - shift | word >>> shift;\nmodule.exports.rotr = $29ee4d3171d9809b$var$rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nmodule.exports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!module.exports.isLE) throw new Error('Non little-endian hardware is not supported');\nconst $29ee4d3171d9809b$var$hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $29ee4d3171d9809b$var$bytesToHex(bytes) {\n    if (!$29ee4d3171d9809b$var$u8a(bytes)) throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $29ee4d3171d9809b$var$hexes[bytes[i]];\n    return hex;\n}\nmodule.exports.bytesToHex = $29ee4d3171d9809b$var$bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $29ee4d3171d9809b$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nmodule.exports.hexToBytes = $29ee4d3171d9809b$var$hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst $29ee4d3171d9809b$var$nextTick = async ()=>{};\nmodule.exports.nextTick = $29ee4d3171d9809b$var$nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function $29ee4d3171d9809b$var$asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, module.exports.nextTick)();\n        ts += diff;\n    }\n}\nmodule.exports.asyncLoop = $29ee4d3171d9809b$var$asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $29ee4d3171d9809b$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nmodule.exports.utf8ToBytes = $29ee4d3171d9809b$var$utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function $29ee4d3171d9809b$var$toBytes(data) {\n    if (typeof data === 'string') data = $29ee4d3171d9809b$var$utf8ToBytes(data);\n    if (!$29ee4d3171d9809b$var$u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nmodule.exports.toBytes = $29ee4d3171d9809b$var$toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function $29ee4d3171d9809b$var$concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a)=>{\n        if (!$29ee4d3171d9809b$var$u8a(a)) throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nmodule.exports.concatBytes = $29ee4d3171d9809b$var$concatBytes;\n// For runtime check if class implements interface\nclass $29ee4d3171d9809b$var$Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nmodule.exports.Hash = $29ee4d3171d9809b$var$Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst $29ee4d3171d9809b$var$isPlainObject = (obj)=>Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction $29ee4d3171d9809b$var$checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !$29ee4d3171d9809b$var$isPlainObject(opts))) throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nmodule.exports.checkOpts = $29ee4d3171d9809b$var$checkOpts;\nfunction $29ee4d3171d9809b$var$wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nmodule.exports.wrapConstructor = $29ee4d3171d9809b$var$wrapConstructor;\nfunction $29ee4d3171d9809b$var$wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nmodule.exports.wrapConstructorWithOpts = $29ee4d3171d9809b$var$wrapConstructorWithOpts;\nfunction $29ee4d3171d9809b$var$wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update($29ee4d3171d9809b$var$toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nmodule.exports.wrapXOFConstructorWithOpts = $29ee4d3171d9809b$var$wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function $29ee4d3171d9809b$var$randomBytes(bytesLength = 32) {\n    if ($dUxV2.crypto && typeof $dUxV2.crypto.getRandomValues === 'function') return $dUxV2.crypto.getRandomValues(new Uint8Array(bytesLength));\n    throw new Error('crypto.getRandomValues must be defined');\n}\nmodule.exports.randomBytes = $29ee4d3171d9809b$var$randomBytes;\n\n});\nparcelRegister(\"dUxV2\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.crypto = void 0;\nmodule.exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n\n});\n\n\nparcelRegister(\"6XnWx\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.sha224 = module.exports.sha256 = void 0;\n\nvar $g9W9K = parcelRequire(\"g9W9K\");\n\nvar $3Bcdj = parcelRequire(\"3Bcdj\");\n// Choice: a ? b : c\nconst $510ad3657d73a9d2$var$Chi = (a, b, c)=>a & b ^ ~a & c;\n// Majority function, true if any two inpust is true\nconst $510ad3657d73a9d2$var$Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst $510ad3657d73a9d2$var$SHA256_K = new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst $510ad3657d73a9d2$var$IV = new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst $510ad3657d73a9d2$var$SHA256_W = new Uint32Array(64);\nclass $510ad3657d73a9d2$var$SHA256 extends $g9W9K.SHA2 {\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = $510ad3657d73a9d2$var$IV[0] | 0;\n        this.B = $510ad3657d73a9d2$var$IV[1] | 0;\n        this.C = $510ad3657d73a9d2$var$IV[2] | 0;\n        this.D = $510ad3657d73a9d2$var$IV[3] | 0;\n        this.E = $510ad3657d73a9d2$var$IV[4] | 0;\n        this.F = $510ad3657d73a9d2$var$IV[5] | 0;\n        this.G = $510ad3657d73a9d2$var$IV[6] | 0;\n        this.H = $510ad3657d73a9d2$var$IV[7] | 0;\n    }\n    get() {\n        const { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)$510ad3657d73a9d2$var$SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = $510ad3657d73a9d2$var$SHA256_W[i - 15];\n            const W2 = $510ad3657d73a9d2$var$SHA256_W[i - 2];\n            const s0 = (0, $3Bcdj.rotr)(W15, 7) ^ (0, $3Bcdj.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, $3Bcdj.rotr)(W2, 17) ^ (0, $3Bcdj.rotr)(W2, 19) ^ W2 >>> 10;\n            $510ad3657d73a9d2$var$SHA256_W[i] = s1 + $510ad3657d73a9d2$var$SHA256_W[i - 7] + s0 + $510ad3657d73a9d2$var$SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A: A, B: B, C: C, D: D, E: E, F: F, G: G, H: H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, $3Bcdj.rotr)(E, 6) ^ (0, $3Bcdj.rotr)(E, 11) ^ (0, $3Bcdj.rotr)(E, 25);\n            const T1 = H + sigma1 + $510ad3657d73a9d2$var$Chi(E, F, G) + $510ad3657d73a9d2$var$SHA256_K[i] + $510ad3657d73a9d2$var$SHA256_W[i] | 0;\n            const sigma0 = (0, $3Bcdj.rotr)(A, 2) ^ (0, $3Bcdj.rotr)(A, 13) ^ (0, $3Bcdj.rotr)(A, 22);\n            const T2 = sigma0 + $510ad3657d73a9d2$var$Maj(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        $510ad3657d73a9d2$var$SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass $510ad3657d73a9d2$var$SHA224 extends $510ad3657d73a9d2$var$SHA256 {\n    constructor(){\n        super();\n        this.A = -1056596264;\n        this.B = 914150663;\n        this.C = 812702999;\n        this.D = -150054599;\n        this.E = -4191439;\n        this.F = 1750603025;\n        this.G = 1694076839;\n        this.H = -1090891868;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ module.exports.sha256 = (0, $3Bcdj.wrapConstructor)(()=>new $510ad3657d73a9d2$var$SHA256());\nmodule.exports.sha224 = (0, $3Bcdj.wrapConstructor)(()=>new $510ad3657d73a9d2$var$SHA224());\n\n});\nparcelRegister(\"g9W9K\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.SHA2 = void 0;\n\nvar $dNiq9 = parcelRequire(\"dNiq9\");\n\nvar $3Bcdj = parcelRequire(\"3Bcdj\");\n// Polyfill for Safari 14\nfunction $bc3a993d7d38a7a0$var$setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass $bc3a993d7d38a7a0$var$SHA2 extends $3Bcdj.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, $3Bcdj.createView)(this.buffer);\n    }\n    update(data) {\n        $dNiq9.default.exists(this);\n        const { view: view, buffer: buffer, blockLen: blockLen } = this;\n        data = (0, $3Bcdj.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, $3Bcdj.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        $dNiq9.default.exists(this);\n        $dNiq9.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer: buffer, view: view, blockLen: blockLen, isLE: isLE } = this;\n        let { pos: pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        $bc3a993d7d38a7a0$var$setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, $3Bcdj.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer: buffer, outputLen: outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen: blockLen, buffer: buffer, length: length, finished: finished, destroyed: destroyed, pos: pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n}\nmodule.exports.SHA2 = $bc3a993d7d38a7a0$var$SHA2;\n\n});\nparcelRegister(\"dNiq9\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.output = module.exports.exists = module.exports.hash = module.exports.bytes = module.exports.bool = module.exports.number = void 0;\nfunction $a0ae23f5901291b4$var$number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\nmodule.exports.number = $a0ae23f5901291b4$var$number;\nfunction $a0ae23f5901291b4$var$bool(b) {\n    if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\nmodule.exports.bool = $a0ae23f5901291b4$var$bool;\nfunction $a0ae23f5901291b4$var$bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nmodule.exports.bytes = $a0ae23f5901291b4$var$bytes;\nfunction $a0ae23f5901291b4$var$hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    $a0ae23f5901291b4$var$number(hash.outputLen);\n    $a0ae23f5901291b4$var$number(hash.blockLen);\n}\nmodule.exports.hash = $a0ae23f5901291b4$var$hash;\nfunction $a0ae23f5901291b4$var$exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nmodule.exports.exists = $a0ae23f5901291b4$var$exists;\nfunction $a0ae23f5901291b4$var$output(out, instance) {\n    $a0ae23f5901291b4$var$bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n}\nmodule.exports.output = $a0ae23f5901291b4$var$output;\nconst $a0ae23f5901291b4$var$assert = {\n    number: $a0ae23f5901291b4$var$number,\n    bool: $a0ae23f5901291b4$var$bool,\n    bytes: $a0ae23f5901291b4$var$bytes,\n    hash: $a0ae23f5901291b4$var$hash,\n    exists: $a0ae23f5901291b4$var$exists,\n    output: $a0ae23f5901291b4$var$output\n};\nmodule.exports.default = $a0ae23f5901291b4$var$assert;\n\n});\n\n\n\nparcelRegister(\"4Dsex\", function(module, exports) {\n\n$parcel$export(module.exports, \"base64\", () => $3600b4829dff8fa9$export$b3b2de96497acc47);\n$parcel$export(module.exports, \"bech32\", () => $3600b4829dff8fa9$export$27c42482533637da);\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function $3600b4829dff8fa9$export$dfbcecb440255e4a(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`Wrong integer: ${n}`);\n}\nfunction $3600b4829dff8fa9$var$chain(...args) {\n    const wrap = (a, b)=>(c)=>a(b(c));\n    const encode = Array.from(args).reverse().reduce((acc, i)=>acc ? wrap(acc, i.encode) : i.encode, undefined);\n    const decode = args.reduce((acc, i)=>acc ? wrap(acc, i.decode) : i.decode, undefined);\n    return {\n        encode: encode,\n        decode: decode\n    };\n}\nfunction $3600b4829dff8fa9$var$alphabet(alphabet) {\n    return {\n        encode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i)=>{\n                $3600b4829dff8fa9$export$dfbcecb440255e4a(i);\n                if (i < 0 || i >= alphabet.length) throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input)=>{\n            if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter)=>{\n                if (typeof letter !== 'string') throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        }\n    };\n}\nfunction $3600b4829dff8fa9$var$join(separator = '') {\n    if (typeof separator !== 'string') throw new Error('join separator should be string');\n    return {\n        encode: (from)=>{\n            if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n            for (let i of from)if (typeof i !== 'string') throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            if (typeof to !== 'string') throw new Error('join.decode input should be string');\n            return to.split(separator);\n        }\n    };\n}\nfunction $3600b4829dff8fa9$var$padding(bits, chr = '=') {\n    $3600b4829dff8fa9$export$dfbcecb440255e4a(bits);\n    if (typeof chr !== 'string') throw new Error('padding chr should be string');\n    return {\n        encode (data) {\n            if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n            for (let i of data)if (typeof i !== 'string') throw new Error(`padding.encode: non-string input=${i}`);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n            for (let i of input)if (typeof i !== 'string') throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n            for(; end > 0 && input[end - 1] === chr; end--){\n                if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        }\n    };\n}\nfunction $3600b4829dff8fa9$var$normalize(fn) {\n    if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\nfunction $3600b4829dff8fa9$var$convertRadix(data, from, to) {\n    if (from < 2) throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d)=>{\n        $3600b4829dff8fa9$export$dfbcecb440255e4a(d);\n        if (d < 0 || d >= from) throw new Error(`Wrong integer: ${d}`);\n    });\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < digits.length; i++){\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) throw new Error('convertRadix: carry overflow');\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n            if (!done) continue;\n            else if (!digits[i]) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst $3600b4829dff8fa9$var$gcd = (a, b)=>!b ? a : $3600b4829dff8fa9$var$gcd(b, a % b);\nconst $3600b4829dff8fa9$var$radix2carry = (from, to)=>from + (to - $3600b4829dff8fa9$var$gcd(from, to));\nfunction $3600b4829dff8fa9$var$convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if ($3600b4829dff8fa9$var$radix2carry(from, to) > 32) throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${$3600b4829dff8fa9$var$radix2carry(from, to)}`);\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data){\n        $3600b4829dff8fa9$export$dfbcecb440255e4a(n);\n        if (n >= 2 ** from) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error('Excess padding');\n    if (!padding && carry) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\nfunction $3600b4829dff8fa9$var$radix(num) {\n    $3600b4829dff8fa9$export$dfbcecb440255e4a(num);\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n            return $3600b4829dff8fa9$var$convertRadix(Array.from(bytes), 256, num);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from($3600b4829dff8fa9$var$convertRadix(digits, num, 256));\n        }\n    };\n}\nfunction $3600b4829dff8fa9$var$radix2(bits, revPadding = false) {\n    $3600b4829dff8fa9$export$dfbcecb440255e4a(bits);\n    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n    if ($3600b4829dff8fa9$var$radix2carry(8, bits) > 32 || $3600b4829dff8fa9$var$radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes)=>{\n            if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n            return $3600b4829dff8fa9$var$convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from($3600b4829dff8fa9$var$convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\nfunction $3600b4829dff8fa9$var$unsafeWrapper(fn) {\n    if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\nfunction $3600b4829dff8fa9$var$checksum(len, fn) {\n    $3600b4829dff8fa9$export$dfbcecb440255e4a(len);\n    if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n    return {\n        encode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n            return payload;\n        }\n    };\n}\nconst $3600b4829dff8fa9$export$eab97d15b1788b8d = {\n    alphabet: $3600b4829dff8fa9$var$alphabet,\n    chain: $3600b4829dff8fa9$var$chain,\n    checksum: $3600b4829dff8fa9$var$checksum,\n    radix: $3600b4829dff8fa9$var$radix,\n    radix2: $3600b4829dff8fa9$var$radix2,\n    join: $3600b4829dff8fa9$var$join,\n    padding: $3600b4829dff8fa9$var$padding\n};\nconst $3600b4829dff8fa9$export$586f61c71cb02fe4 = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(4), $3600b4829dff8fa9$var$alphabet('0123456789ABCDEF'), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$export$4a4d5965e2738b2a = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(5), $3600b4829dff8fa9$var$alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), $3600b4829dff8fa9$var$padding(5), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$export$c57d6760d519c8ac = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(5), $3600b4829dff8fa9$var$alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), $3600b4829dff8fa9$var$padding(5), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$export$5fbcb08925249358 = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(5), $3600b4829dff8fa9$var$alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), $3600b4829dff8fa9$var$join(''), $3600b4829dff8fa9$var$normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst $3600b4829dff8fa9$export$b3b2de96497acc47 = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(6), $3600b4829dff8fa9$var$alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), $3600b4829dff8fa9$var$padding(6), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$export$7d21597c7bc64465 = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(6), $3600b4829dff8fa9$var$alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), $3600b4829dff8fa9$var$padding(6), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$var$genBase58 = (abc)=>$3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix(58), $3600b4829dff8fa9$var$alphabet(abc), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$export$61f53211c069eefb = $3600b4829dff8fa9$var$genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst $3600b4829dff8fa9$export$c6a7baed2941aad2 = $3600b4829dff8fa9$var$genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst $3600b4829dff8fa9$export$cbd4c72942a9201d = $3600b4829dff8fa9$var$genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst $3600b4829dff8fa9$var$XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\nconst $3600b4829dff8fa9$export$e86cd8e7f8cff4a6 = {\n    encode (data) {\n        let res = '';\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += $3600b4829dff8fa9$export$61f53211c069eefb.encode(block).padStart($3600b4829dff8fa9$var$XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = $3600b4829dff8fa9$var$XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = $3600b4829dff8fa9$export$61f53211c069eefb.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\nconst $3600b4829dff8fa9$export$fff625c574161df6 = (sha256)=>$3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$checksum(4, (data)=>sha256(sha256(data))), $3600b4829dff8fa9$export$61f53211c069eefb);\nconst $3600b4829dff8fa9$var$BECH_ALPHABET = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), $3600b4829dff8fa9$var$join(''));\nconst $3600b4829dff8fa9$var$POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\nfunction $3600b4829dff8fa9$var$bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < $3600b4829dff8fa9$var$POLYMOD_GENERATORS.length; i++)if ((b >> i & 1) === 1) chk ^= $3600b4829dff8fa9$var$POLYMOD_GENERATORS[i];\n    return chk;\n}\nfunction $3600b4829dff8fa9$var$bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = $3600b4829dff8fa9$var$bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = $3600b4829dff8fa9$var$bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = $3600b4829dff8fa9$var$bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = $3600b4829dff8fa9$var$bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = $3600b4829dff8fa9$var$bech32Polymod(chk);\n    chk ^= encodingConst;\n    return $3600b4829dff8fa9$var$BECH_ALPHABET.encode($3600b4829dff8fa9$var$convertRadix2([\n        chk % 2 ** 30\n    ], 30, 5, false));\n}\nfunction $3600b4829dff8fa9$var$genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = $3600b4829dff8fa9$var$radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = $3600b4829dff8fa9$var$unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string') throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${$3600b4829dff8fa9$var$BECH_ALPHABET.encode(words)}${$3600b4829dff8fa9$var$bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string') throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n        const words = $3600b4829dff8fa9$var$BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = $3600b4829dff8fa9$var$bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix: prefix,\n            words: words\n        };\n    }\n    const decodeUnsafe = $3600b4829dff8fa9$var$unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix: prefix, words: words } = decode(str, false);\n        return {\n            prefix: prefix,\n            words: words,\n            bytes: fromWords(words)\n        };\n    }\n    return {\n        encode: encode,\n        decode: decode,\n        decodeToBytes: decodeToBytes,\n        decodeUnsafe: decodeUnsafe,\n        fromWords: fromWords,\n        fromWordsUnsafe: fromWordsUnsafe,\n        toWords: toWords\n    };\n}\nconst $3600b4829dff8fa9$export$27c42482533637da = $3600b4829dff8fa9$var$genBech32('bech32');\nconst $3600b4829dff8fa9$export$4963f7e473ccf819 = $3600b4829dff8fa9$var$genBech32('bech32m');\nconst $3600b4829dff8fa9$export$74329b762b589566 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\nconst $3600b4829dff8fa9$export$834dfc94dde4b3d8 = $3600b4829dff8fa9$var$chain($3600b4829dff8fa9$var$radix2(4), $3600b4829dff8fa9$var$alphabet('0123456789abcdef'), $3600b4829dff8fa9$var$join(''), $3600b4829dff8fa9$var$normalize((s)=>{\n    if (typeof s !== 'string' || s.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst $3600b4829dff8fa9$var$CODERS = {\n    utf8: $3600b4829dff8fa9$export$74329b762b589566,\n    hex: $3600b4829dff8fa9$export$834dfc94dde4b3d8,\n    base16: $3600b4829dff8fa9$export$586f61c71cb02fe4,\n    base32: $3600b4829dff8fa9$export$4a4d5965e2738b2a,\n    base64: $3600b4829dff8fa9$export$b3b2de96497acc47,\n    base64url: $3600b4829dff8fa9$export$7d21597c7bc64465,\n    base58: $3600b4829dff8fa9$export$61f53211c069eefb,\n    base58xmr: $3600b4829dff8fa9$export$e86cd8e7f8cff4a6\n};\nconst $3600b4829dff8fa9$var$coderTypeError = `Invalid encoding type. Available types: ${Object.keys($3600b4829dff8fa9$var$CODERS).join(', ')}`;\nconst $3600b4829dff8fa9$export$7c746b75f47c9c7d = (type, bytes)=>{\n    if (typeof type !== 'string' || !$3600b4829dff8fa9$var$CODERS.hasOwnProperty(type)) throw new TypeError($3600b4829dff8fa9$var$coderTypeError);\n    if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n    return $3600b4829dff8fa9$var$CODERS[type].encode(bytes);\n};\nconst $3600b4829dff8fa9$export$42d51816ce590c93 = $3600b4829dff8fa9$export$7c746b75f47c9c7d;\nconst $3600b4829dff8fa9$export$c8dd6bc66a63753c = (type, str)=>{\n    if (!$3600b4829dff8fa9$var$CODERS.hasOwnProperty(type)) throw new TypeError($3600b4829dff8fa9$var$coderTypeError);\n    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n    return $3600b4829dff8fa9$var$CODERS[type].decode(str);\n};\nconst $3600b4829dff8fa9$export$b3317979f9250576 = $3600b4829dff8fa9$export$c8dd6bc66a63753c;\n\n});\n\nparcelRegister(\"3RPiR\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.unsafe = module.exports.siv = module.exports.gcm = module.exports.cfb = module.exports.cbc = module.exports.ecb = module.exports.ctr = module.exports.expandKeyDecLE = module.exports.expandKeyLE = void 0;\n\nvar $38xio = parcelRequire(\"38xio\");\n\nvar $8wowT = parcelRequire(\"8wowT\");\n\nvar $87adI = parcelRequire(\"87adI\");\n/*\nAES (Advanced Encryption Standard) aka Rijndael block cipher.\n\nData is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n1. **S-box**, table substitution\n2. **Shift rows**, cyclic shift left of all rows of data array\n3. **Mix columns**, multiplying every column by fixed polynomial\n4. **Add round key**, round_key xor i-th column of array\n\nResources:\n- FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n- Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\n*/ const $2d0e1e19edfeea80$var$BLOCK_SIZE = 16;\nconst $2d0e1e19edfeea80$var$BLOCK_SIZE32 = 4;\nconst $2d0e1e19edfeea80$var$EMPTY_BLOCK = new Uint8Array($2d0e1e19edfeea80$var$BLOCK_SIZE);\nconst $2d0e1e19edfeea80$var$POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction $2d0e1e19edfeea80$var$mul2(n) {\n    return n << 1 ^ $2d0e1e19edfeea80$var$POLY & -(n >> 7);\n}\nfunction $2d0e1e19edfeea80$var$mul(a, b) {\n    let res = 0;\n    for(; b > 0; b >>= 1){\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = $2d0e1e19edfeea80$var$mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst $2d0e1e19edfeea80$var$sbox = /* @__PURE__ */ (()=>{\n    let t = new Uint8Array(256);\n    for(let i = 0, x = 1; i < 256; i++, x ^= $2d0e1e19edfeea80$var$mul2(x))t[i] = x;\n    const box = new Uint8Array(256);\n    box[0] = 0x63; // first elm\n    for(let i = 0; i < 255; i++){\n        let x = t[255 - i];\n        x |= x << 8;\n        box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 0x63) & 0xff;\n    }\n    return box;\n})();\n// Inverted S-box\nconst $2d0e1e19edfeea80$var$invSbox = /* @__PURE__ */ $2d0e1e19edfeea80$var$sbox.map((_, j)=>$2d0e1e19edfeea80$var$sbox.indexOf(j));\n// Rotate u32 by 8\nconst $2d0e1e19edfeea80$var$rotr32_8 = (n)=>n << 24 | n >>> 8;\nconst $2d0e1e19edfeea80$var$rotl32_8 = (n)=>n << 8 | n >>> 24;\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction $2d0e1e19edfeea80$var$genTtable(sbox, fn) {\n    if (sbox.length !== 256) throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j)=>fn(sbox[j]));\n    const T1 = T0.map($2d0e1e19edfeea80$var$rotl32_8);\n    const T2 = T1.map($2d0e1e19edfeea80$var$rotl32_8);\n    const T3 = T2.map($2d0e1e19edfeea80$var$rotl32_8);\n    const T01 = new Uint32Array(65536);\n    const T23 = new Uint32Array(65536);\n    const sbox2 = new Uint16Array(65536);\n    for(let i = 0; i < 256; i++)for(let j = 0; j < 256; j++){\n        const idx = i * 256 + j;\n        T01[idx] = T0[i] ^ T1[j];\n        T23[idx] = T2[i] ^ T3[j];\n        sbox2[idx] = sbox[i] << 8 | sbox[j];\n    }\n    return {\n        sbox: sbox,\n        sbox2: sbox2,\n        T0: T0,\n        T1: T1,\n        T2: T2,\n        T3: T3,\n        T01: T01,\n        T23: T23\n    };\n}\nconst $2d0e1e19edfeea80$var$tableEncoding = /* @__PURE__ */ $2d0e1e19edfeea80$var$genTtable($2d0e1e19edfeea80$var$sbox, (s)=>$2d0e1e19edfeea80$var$mul(s, 3) << 24 | s << 16 | s << 8 | $2d0e1e19edfeea80$var$mul(s, 2));\nconst $2d0e1e19edfeea80$var$tableDecoding = /* @__PURE__ */ $2d0e1e19edfeea80$var$genTtable($2d0e1e19edfeea80$var$invSbox, (s)=>$2d0e1e19edfeea80$var$mul(s, 11) << 24 | $2d0e1e19edfeea80$var$mul(s, 13) << 16 | $2d0e1e19edfeea80$var$mul(s, 9) << 8 | $2d0e1e19edfeea80$var$mul(s, 14));\nconst $2d0e1e19edfeea80$var$xPowers = /* @__PURE__ */ (()=>{\n    const p = new Uint8Array(16);\n    for(let i = 0, x = 1; i < 16; i++, x = $2d0e1e19edfeea80$var$mul2(x))p[i] = x;\n    return p;\n})();\nfunction $2d0e1e19edfeea80$var$expandKeyLE(key) {\n    (0, $87adI.bytes)(key);\n    const len = key.length;\n    if (![\n        16,\n        24,\n        32\n    ].includes(len)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2: sbox2 } = $2d0e1e19edfeea80$var$tableEncoding;\n    const k32 = (0, $38xio.u32)(key);\n    const Nk = k32.length;\n    const subByte = (n)=>$2d0e1e19edfeea80$var$applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for(let i = Nk; i < xk.length; i++){\n        let t = xk[i - 1];\n        if (i % Nk === 0) t = subByte($2d0e1e19edfeea80$var$rotr32_8(t)) ^ $2d0e1e19edfeea80$var$xPowers[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nmodule.exports.expandKeyLE = $2d0e1e19edfeea80$var$expandKeyLE;\nfunction $2d0e1e19edfeea80$var$expandKeyDecLE(key) {\n    const encKey = $2d0e1e19edfeea80$var$expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2: sbox2 } = $2d0e1e19edfeea80$var$tableEncoding;\n    const { T0: T0, T1: T1, T2: T2, T3: T3 } = $2d0e1e19edfeea80$var$tableDecoding;\n    // Inverse key by chunks of 4 (rounds)\n    for(let i = 0; i < Nk; i += 4)for(let j = 0; j < 4; j++)xk[i + j] = encKey[Nk - i - 4 + j];\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for(let i = 4; i < Nk - 4; i++){\n        const x = xk[i];\n        const w = $2d0e1e19edfeea80$var$applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[w >>> 8 & 0xff] ^ T2[w >>> 16 & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\nmodule.exports.expandKeyDecLE = $2d0e1e19edfeea80$var$expandKeyDecLE;\n// Apply tables\nfunction $2d0e1e19edfeea80$var$apply0123(T01, T23, s0, s1, s2, s3) {\n    return T01[s0 << 8 & 0xff00 | s1 >>> 8 & 0xff] ^ T23[s2 >>> 8 & 0xff00 | s3 >>> 24 & 0xff];\n}\nfunction $2d0e1e19edfeea80$var$applySbox(sbox2, s0, s1, s2, s3) {\n    return sbox2[s0 & 0xff | s1 & 0xff00] | sbox2[s2 >>> 16 & 0xff | s3 >>> 16 & 0xff00] << 16;\n}\nfunction $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2: sbox2, T01: T01, T23: T23 } = $2d0e1e19edfeea80$var$tableEncoding;\n    let k = 0;\n    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];\n    const rounds = xk.length / 4 - 2;\n    for(let i = 0; i < rounds; i++){\n        const t0 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s3, s0, s1, s2);\n        s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s3, s0, s1, s2);\n    return {\n        s0: t0,\n        s1: t1,\n        s2: t2,\n        s3: t3\n    };\n}\nfunction $2d0e1e19edfeea80$var$decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2: sbox2, T01: T01, T23: T23 } = $2d0e1e19edfeea80$var$tableDecoding;\n    let k = 0;\n    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];\n    const rounds = xk.length / 4 - 2;\n    for(let i = 0; i < rounds; i++){\n        const t0 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ $2d0e1e19edfeea80$var$apply0123(T01, T23, s3, s2, s1, s0);\n        s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n    }\n    // Last round\n    const t0 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ $2d0e1e19edfeea80$var$applySbox(sbox2, s3, s2, s1, s0);\n    return {\n        s0: t0,\n        s1: t1,\n        s2: t2,\n        s3: t3\n    };\n}\nfunction $2d0e1e19edfeea80$var$getDst(len, dst) {\n    if (!dst) return new Uint8Array(len);\n    (0, $87adI.bytes)(dst);\n    if (dst.length < len) throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction $2d0e1e19edfeea80$var$ctrCounter(xk, nonce, src, dst) {\n    (0, $87adI.bytes)(nonce, $2d0e1e19edfeea80$var$BLOCK_SIZE);\n    (0, $87adI.bytes)(src);\n    const srcLen = src.length;\n    dst = $2d0e1e19edfeea80$var$getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = (0, $38xio.u32)(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = (0, $38xio.u32)(src);\n    const dst32 = (0, $38xio.u32)(dst);\n    // process blocks\n    for(let i = 0; i + 4 <= src32.length; i += 4){\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for(let i = ctr.length - 1; i >= 0; i--){\n            carry = carry + (ctr[i] & 0xff) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = $2d0e1e19edfeea80$var$BLOCK_SIZE * Math.floor(src32.length / $2d0e1e19edfeea80$var$BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([\n            s0,\n            s1,\n            s2,\n            s3\n        ]);\n        const buf = (0, $38xio.u8)(b32);\n        for(let i = start, pos = 0; i < srcLen; i++, pos++)dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction $2d0e1e19edfeea80$var$ctr32(xk, isLE, nonce, src, dst) {\n    (0, $87adI.bytes)(nonce, $2d0e1e19edfeea80$var$BLOCK_SIZE);\n    (0, $87adI.bytes)(src);\n    dst = $2d0e1e19edfeea80$var$getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = (0, $38xio.u32)(ctr);\n    const view = (0, $38xio.createView)(ctr);\n    const src32 = (0, $38xio.u32)(src);\n    const dst32 = (0, $38xio.u32)(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for(let i = 0; i + 4 <= src32.length; i += 4){\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = ctrNum + 1 >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = $2d0e1e19edfeea80$var$BLOCK_SIZE * Math.floor(src32.length / $2d0e1e19edfeea80$var$BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([\n            s0,\n            s1,\n            s2,\n            s3\n        ]);\n        const buf = (0, $38xio.u8)(b32);\n        for(let i = start, pos = 0; i < srcLen; i++, pos++)dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */ module.exports.ctr = (0, $38xio.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function ctr(key, nonce) {\n    (0, $87adI.bytes)(key);\n    (0, $87adI.bytes)(nonce, $2d0e1e19edfeea80$var$BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n        const n = nonce.slice();\n        const out = $2d0e1e19edfeea80$var$ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst)=>processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst)=>processCtr(ciphertext, dst)\n    };\n});\nfunction $2d0e1e19edfeea80$var$validateBlockDecrypt(data) {\n    (0, $87adI.bytes)(data);\n    if (data.length % $2d0e1e19edfeea80$var$BLOCK_SIZE !== 0) throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${$2d0e1e19edfeea80$var$BLOCK_SIZE}`);\n}\nfunction $2d0e1e19edfeea80$var$validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % $2d0e1e19edfeea80$var$BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0) throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = (0, $38xio.u32)(plaintext);\n    if (pcks5) {\n        let left = $2d0e1e19edfeea80$var$BLOCK_SIZE - remaining;\n        if (!left) left = $2d0e1e19edfeea80$var$BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = $2d0e1e19edfeea80$var$getDst(outLen, dst);\n    const o = (0, $38xio.u32)(out);\n    return {\n        b: b,\n        o: o,\n        out: out\n    };\n}\nfunction $2d0e1e19edfeea80$var$validatePCKS(data, pcks5) {\n    if (!pcks5) return data;\n    const len = data.length;\n    if (!len) throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16) throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for(let i = 0; i < lastByte; i++)if (data[len - i - 1] !== lastByte) throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction $2d0e1e19edfeea80$var$padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = (0, $38xio.u32)(tmp);\n    tmp.set(left);\n    const paddingByte = $2d0e1e19edfeea80$var$BLOCK_SIZE - left.length;\n    for(let i = $2d0e1e19edfeea80$var$BLOCK_SIZE - paddingByte; i < $2d0e1e19edfeea80$var$BLOCK_SIZE; i++)tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */ module.exports.ecb = (0, $38xio.wrapCipher)({\n    blockSize: 16\n}, function ecb(key, opts = {}) {\n    (0, $87adI.bytes)(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst)=>{\n            (0, $87adI.bytes)(plaintext);\n            const { b: b, o: o, out: _out } = $2d0e1e19edfeea80$var$validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n            let i = 0;\n            for(; i + 4 <= b.length;){\n                const { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n            }\n            if (pcks5) {\n                const tmp32 = $2d0e1e19edfeea80$var$padPCKS(plaintext.subarray(i * 4));\n                const { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst)=>{\n            $2d0e1e19edfeea80$var$validateBlockDecrypt(ciphertext);\n            const xk = $2d0e1e19edfeea80$var$expandKeyDecLE(key);\n            const out = $2d0e1e19edfeea80$var$getDst(ciphertext.length, dst);\n            const b = (0, $38xio.u32)(ciphertext);\n            const o = (0, $38xio.u32)(out);\n            for(let i = 0; i + 4 <= b.length;){\n                const { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n            }\n            xk.fill(0);\n            return $2d0e1e19edfeea80$var$validatePCKS(out, pcks5);\n        }\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */ module.exports.cbc = (0, $38xio.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function cbc(key, iv, opts = {}) {\n    (0, $87adI.bytes)(key);\n    (0, $87adI.bytes)(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst)=>{\n            const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n            const { b: b, o: o, out: _out } = $2d0e1e19edfeea80$var$validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = (0, $38xio.u32)(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for(; i + 4 <= b.length;){\n                s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];\n                ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3));\n                o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n            }\n            if (pcks5) {\n                const tmp32 = $2d0e1e19edfeea80$var$padPCKS(plaintext.subarray(i * 4));\n                s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];\n                ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3));\n                o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst)=>{\n            $2d0e1e19edfeea80$var$validateBlockDecrypt(ciphertext);\n            const xk = $2d0e1e19edfeea80$var$expandKeyDecLE(key);\n            const n32 = (0, $38xio.u32)(iv);\n            const out = $2d0e1e19edfeea80$var$getDst(ciphertext.length, dst);\n            const b = (0, $38xio.u32)(ciphertext);\n            const o = (0, $38xio.u32)(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for(let i = 0; i + 4 <= b.length;){\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = $2d0e1e19edfeea80$var$decrypt(xk, s0, s1, s2, s3);\n                o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;\n            }\n            xk.fill(0);\n            return $2d0e1e19edfeea80$var$validatePCKS(out, pcks5);\n        }\n    };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */ module.exports.cfb = (0, $38xio.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function cfb(key, iv) {\n    (0, $87adI.bytes)(key);\n    (0, $87adI.bytes)(iv, 16);\n    function processCfb(src, isEncrypt, dst) {\n        const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n        const srcLen = src.length;\n        dst = $2d0e1e19edfeea80$var$getDst(srcLen, dst);\n        const src32 = (0, $38xio.u32)(src);\n        const dst32 = (0, $38xio.u32)(dst);\n        const next32 = isEncrypt ? dst32 : src32;\n        const n32 = (0, $38xio.u32)(iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for(let i = 0; i + 4 <= src32.length;){\n            const { s0: e0, s1: e1, s2: e2, s3: e3 } = $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3);\n            dst32[i + 0] = src32[i + 0] ^ e0;\n            dst32[i + 1] = src32[i + 1] ^ e1;\n            dst32[i + 2] = src32[i + 2] ^ e2;\n            dst32[i + 3] = src32[i + 3] ^ e3;\n            s0 = next32[i++], s1 = next32[i++], s2 = next32[i++], s3 = next32[i++];\n        }\n        // leftovers (less than block)\n        const start = $2d0e1e19edfeea80$var$BLOCK_SIZE * Math.floor(src32.length / $2d0e1e19edfeea80$var$BLOCK_SIZE32);\n        if (start < srcLen) {\n            ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3));\n            const buf = (0, $38xio.u8)(new Uint32Array([\n                s0,\n                s1,\n                s2,\n                s3\n            ]));\n            for(let i = start, pos = 0; i < srcLen; i++, pos++)dst[i] = src[i] ^ buf[pos];\n            buf.fill(0);\n        }\n        xk.fill(0);\n        return dst;\n    }\n    return {\n        encrypt: (plaintext, dst)=>processCfb(plaintext, true, dst),\n        decrypt: (ciphertext, dst)=>processCfb(ciphertext, false, dst)\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction $2d0e1e19edfeea80$var$computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD) h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = (0, $38xio.createView)(num);\n    if (AAD) (0, $38xio.setBigUint64)(view, 0, BigInt(AAD.length * 8), isLE);\n    (0, $38xio.setBigUint64)(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */ module.exports.gcm = (0, $38xio.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 12,\n    tagLength: 16\n}, function gcm(key, nonce, AAD) {\n    (0, $87adI.bytes)(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0) throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = $2d0e1e19edfeea80$var$computeTag($8wowT.ghash, false, authKey, data, AAD);\n        for(let i = 0; i < tagMask.length; i++)tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n        const authKey = $2d0e1e19edfeea80$var$EMPTY_BLOCK.slice();\n        const counter = $2d0e1e19edfeea80$var$EMPTY_BLOCK.slice();\n        $2d0e1e19edfeea80$var$ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) counter.set(nonce);\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = $2d0e1e19edfeea80$var$EMPTY_BLOCK.slice();\n            const view = (0, $38xio.createView)(nonceLen);\n            (0, $38xio.setBigUint64)(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            $8wowT.ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = $2d0e1e19edfeea80$var$ctr32(xk, false, counter, $2d0e1e19edfeea80$var$EMPTY_BLOCK);\n        return {\n            xk: xk,\n            authKey: authKey,\n            counter: counter,\n            tagMask: tagMask\n        };\n    }\n    return {\n        encrypt: (plaintext)=>{\n            (0, $87adI.bytes)(plaintext);\n            const { xk: xk, authKey: authKey, counter: counter, tagMask: tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            $2d0e1e19edfeea80$var$ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext)=>{\n            (0, $87adI.bytes)(ciphertext);\n            if (ciphertext.length < tagLength) throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk: xk, authKey: authKey, counter: counter, tagMask: tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!(0, $38xio.equalBytes)(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n            const out = $2d0e1e19edfeea80$var$ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        }\n    };\n});\nconst $2d0e1e19edfeea80$var$limit = (name, min, max)=>(value)=>{\n        if (!Number.isSafeInteger(value) || min > value || value > max) throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n    };\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */ module.exports.siv = (0, $38xio.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 12,\n    tagLength: 16\n}, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = $2d0e1e19edfeea80$var$limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = $2d0e1e19edfeea80$var$limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = $2d0e1e19edfeea80$var$limit('nonce', 12, 12);\n    const CIPHER_LIMIT = $2d0e1e19edfeea80$var$limit('ciphertext', 16, 2 ** 36 + 16);\n    (0, $87adI.bytes)(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        (0, $87adI.bytes)(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32) throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = $2d0e1e19edfeea80$var$expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = (0, $38xio.u32)(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [\n            authKey,\n            encKey\n        ].map($38xio.u32)){\n            const d32 = (0, $38xio.u32)(derivedKey);\n            for(let i = 0; i < d32.length; i += 2){\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = $2d0e1e19edfeea80$var$encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return {\n            authKey: authKey,\n            encKey: $2d0e1e19edfeea80$var$expandKeyLE(encKey)\n        };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = $2d0e1e19edfeea80$var$computeTag($8wowT.polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for(let i = 0; i < 12; i++)tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = (0, $38xio.u32)(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(encKey, s0, s1, s2, s3));\n        t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return $2d0e1e19edfeea80$var$ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext)=>{\n            (0, $87adI.bytes)(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey: encKey, authKey: authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext)=>{\n            (0, $87adI.bytes)(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey: encKey, authKey: authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!(0, $38xio.equalBytes)(tag, expectedTag)) throw new Error('invalid polyval tag');\n            return plaintext;\n        }\n    };\n});\nfunction $2d0e1e19edfeea80$var$isBytes32(a) {\n    return a != null && typeof a === 'object' && (a instanceof Uint32Array || a.constructor.name === 'Uint32Array');\n}\nfunction $2d0e1e19edfeea80$var$encryptBlock(xk, block) {\n    (0, $87adI.bytes)(block, 16);\n    if (!$2d0e1e19edfeea80$var$isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = (0, $38xio.u32)(block);\n    let { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;\n    return block;\n}\nfunction $2d0e1e19edfeea80$var$decryptBlock(xk, block) {\n    (0, $87adI.bytes)(block, 16);\n    if (!$2d0e1e19edfeea80$var$isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = (0, $38xio.u32)(block);\n    let { s0: s0, s1: s1, s2: s2, s3: s3 } = $2d0e1e19edfeea80$var$decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nmodule.exports.unsafe = {\n    expandKeyLE: $2d0e1e19edfeea80$var$expandKeyLE,\n    expandKeyDecLE: $2d0e1e19edfeea80$var$expandKeyDecLE,\n    encrypt: $2d0e1e19edfeea80$var$encrypt,\n    decrypt: $2d0e1e19edfeea80$var$decrypt,\n    encryptBlock: $2d0e1e19edfeea80$var$encryptBlock,\n    decryptBlock: $2d0e1e19edfeea80$var$decryptBlock,\n    ctrCounter: $2d0e1e19edfeea80$var$ctrCounter,\n    ctr32: $2d0e1e19edfeea80$var$ctr32\n};\n\n});\nparcelRegister(\"38xio\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.u64Lengths = module.exports.setBigUint64 = module.exports.wrapCipher = module.exports.Hash = module.exports.equalBytes = module.exports.checkOpts = module.exports.concatBytes = module.exports.toBytes = module.exports.bytesToUtf8 = module.exports.utf8ToBytes = module.exports.asyncLoop = module.exports.nextTick = module.exports.numberToBytesBE = module.exports.bytesToNumberBE = module.exports.hexToNumber = module.exports.hexToBytes = module.exports.bytesToHex = module.exports.isLE = module.exports.createView = module.exports.u32 = module.exports.u16 = module.exports.u8 = void 0;\n\nvar $87adI = parcelRequire(\"87adI\");\n// Cast array to different type\nconst $248bf24903c02b9f$var$u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.u8 = $248bf24903c02b9f$var$u8;\nconst $248bf24903c02b9f$var$u16 = (arr)=>new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nmodule.exports.u16 = $248bf24903c02b9f$var$u16;\nconst $248bf24903c02b9f$var$u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nmodule.exports.u32 = $248bf24903c02b9f$var$u32;\n// Cast array to view\nconst $248bf24903c02b9f$var$createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nmodule.exports.createView = $248bf24903c02b9f$var$createView;\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nmodule.exports.isLE = new Uint8Array(new Uint32Array([\n    0x11223344\n]).buffer)[0] === 0x44;\nif (!module.exports.isLE) throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst $248bf24903c02b9f$var$hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function $248bf24903c02b9f$var$bytesToHex(bytes) {\n    (0, $87adI.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for(let i = 0; i < bytes.length; i++)hex += $248bf24903c02b9f$var$hexes[bytes[i]];\n    return hex;\n}\nmodule.exports.bytesToHex = $248bf24903c02b9f$var$bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst $248bf24903c02b9f$var$asciis = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction $248bf24903c02b9f$var$asciiToBase16(char) {\n    if (char >= $248bf24903c02b9f$var$asciis._0 && char <= $248bf24903c02b9f$var$asciis._9) return char - $248bf24903c02b9f$var$asciis._0;\n    if (char >= $248bf24903c02b9f$var$asciis._A && char <= $248bf24903c02b9f$var$asciis._F) return char - ($248bf24903c02b9f$var$asciis._A - 10);\n    if (char >= $248bf24903c02b9f$var$asciis._a && char <= $248bf24903c02b9f$var$asciis._f) return char - ($248bf24903c02b9f$var$asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function $248bf24903c02b9f$var$hexToBytes(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = $248bf24903c02b9f$var$asciiToBase16(hex.charCodeAt(hi));\n        const n2 = $248bf24903c02b9f$var$asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nmodule.exports.hexToBytes = $248bf24903c02b9f$var$hexToBytes;\nfunction $248bf24903c02b9f$var$hexToNumber(hex) {\n    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nmodule.exports.hexToNumber = $248bf24903c02b9f$var$hexToNumber;\n// BE: Big Endian, LE: Little Endian\nfunction $248bf24903c02b9f$var$bytesToNumberBE(bytes) {\n    return $248bf24903c02b9f$var$hexToNumber($248bf24903c02b9f$var$bytesToHex(bytes));\n}\nmodule.exports.bytesToNumberBE = $248bf24903c02b9f$var$bytesToNumberBE;\nfunction $248bf24903c02b9f$var$numberToBytesBE(n, len) {\n    return $248bf24903c02b9f$var$hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nmodule.exports.numberToBytesBE = $248bf24903c02b9f$var$numberToBytesBE;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst $248bf24903c02b9f$var$nextTick = async ()=>{};\nmodule.exports.nextTick = $248bf24903c02b9f$var$nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function $248bf24903c02b9f$var$asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, module.exports.nextTick)();\n        ts += diff;\n    }\n}\nmodule.exports.asyncLoop = $248bf24903c02b9f$var$asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function $248bf24903c02b9f$var$utf8ToBytes(str) {\n    if (typeof str !== 'string') throw new Error(`string expected, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nmodule.exports.utf8ToBytes = $248bf24903c02b9f$var$utf8ToBytes;\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */ function $248bf24903c02b9f$var$bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\nmodule.exports.bytesToUtf8 = $248bf24903c02b9f$var$bytesToUtf8;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function $248bf24903c02b9f$var$toBytes(data) {\n    if (typeof data === 'string') data = $248bf24903c02b9f$var$utf8ToBytes(data);\n    else if ((0, $87adI.isBytes)(data)) data = data.slice();\n    else throw new Error(`Uint8Array expected, got ${typeof data}`);\n    return data;\n}\nmodule.exports.toBytes = $248bf24903c02b9f$var$toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */ function $248bf24903c02b9f$var$concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0, $87adI.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nmodule.exports.concatBytes = $248bf24903c02b9f$var$concatBytes;\nfunction $248bf24903c02b9f$var$checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nmodule.exports.checkOpts = $248bf24903c02b9f$var$checkOpts;\n// Compares 2 u8a-s in kinda constant time\nfunction $248bf24903c02b9f$var$equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\nmodule.exports.equalBytes = $248bf24903c02b9f$var$equalBytes;\n// For runtime check if class implements interface\nclass $248bf24903c02b9f$var$Hash {\n}\nmodule.exports.Hash = $248bf24903c02b9f$var$Hash;\n/**\n * @__NO_SIDE_EFFECTS__\n */ const $248bf24903c02b9f$var$wrapCipher = (params, c)=>{\n    Object.assign(c, params);\n    return c;\n};\nmodule.exports.wrapCipher = $248bf24903c02b9f$var$wrapCipher;\n// Polyfill for Safari 14\nfunction $248bf24903c02b9f$var$setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nmodule.exports.setBigUint64 = $248bf24903c02b9f$var$setBigUint64;\nfunction $248bf24903c02b9f$var$u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = (0, module.exports.createView)(num);\n    $248bf24903c02b9f$var$setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    $248bf24903c02b9f$var$setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\nmodule.exports.u64Lengths = $248bf24903c02b9f$var$u64Lengths;\n\n});\nparcelRegister(\"87adI\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.output = module.exports.exists = module.exports.hash = module.exports.bytes = module.exports.bool = module.exports.number = module.exports.isBytes = void 0;\nfunction $5e86e7af933ab8a1$var$number(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\nmodule.exports.number = $5e86e7af933ab8a1$var$number;\nfunction $5e86e7af933ab8a1$var$bool(b) {\n    if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\nmodule.exports.bool = $5e86e7af933ab8a1$var$bool;\nfunction $5e86e7af933ab8a1$var$isBytes(a) {\n    return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nmodule.exports.isBytes = $5e86e7af933ab8a1$var$isBytes;\nfunction $5e86e7af933ab8a1$var$bytes(b, ...lengths) {\n    if (!$5e86e7af933ab8a1$var$isBytes(b)) throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nmodule.exports.bytes = $5e86e7af933ab8a1$var$bytes;\nfunction $5e86e7af933ab8a1$var$hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('hash must be wrapped by utils.wrapConstructor');\n    $5e86e7af933ab8a1$var$number(hash.outputLen);\n    $5e86e7af933ab8a1$var$number(hash.blockLen);\n}\nmodule.exports.hash = $5e86e7af933ab8a1$var$hash;\nfunction $5e86e7af933ab8a1$var$exists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nmodule.exports.exists = $5e86e7af933ab8a1$var$exists;\nfunction $5e86e7af933ab8a1$var$output(out, instance) {\n    $5e86e7af933ab8a1$var$bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n}\nmodule.exports.output = $5e86e7af933ab8a1$var$output;\nconst $5e86e7af933ab8a1$var$assert = {\n    number: $5e86e7af933ab8a1$var$number,\n    bool: $5e86e7af933ab8a1$var$bool,\n    bytes: $5e86e7af933ab8a1$var$bytes,\n    hash: $5e86e7af933ab8a1$var$hash,\n    exists: $5e86e7af933ab8a1$var$exists,\n    output: $5e86e7af933ab8a1$var$output\n};\nmodule.exports.default = $5e86e7af933ab8a1$var$assert;\n\n});\n\n\nparcelRegister(\"8wowT\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.polyval = module.exports.ghash = module.exports._toGHASHKey = void 0;\n\nvar $38xio = parcelRequire(\"38xio\");\n\nvar $87adI = parcelRequire(\"87adI\");\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst $634456ee3058786c$var$BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst $634456ee3058786c$var$ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst $634456ee3058786c$var$ZEROS32 = (0, $38xio.u32)($634456ee3058786c$var$ZEROS16);\nconst $634456ee3058786c$var$POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst $634456ee3058786c$var$mul2 = (s0, s1, s2, s3)=>{\n    const hiBit = s3 & 1;\n    return {\n        s3: s2 << 31 | s3 >>> 1,\n        s2: s1 << 31 | s2 >>> 1,\n        s1: s0 << 31 | s1 >>> 1,\n        s0: s0 >>> 1 ^ $634456ee3058786c$var$POLY << 24 & -(hiBit & 1)\n    };\n};\nconst $634456ee3058786c$var$swapLE = (n)=>(n >>> 0 & 0xff) << 24 | (n >>> 8 & 0xff) << 16 | (n >>> 16 & 0xff) << 8 | n >>> 24 & 0xff | 0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */ function $634456ee3058786c$var$_toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for(let i = 0; i < k.length; i++){\n        const t = k[i];\n        k[i] = t >>> 1 | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nmodule.exports._toGHASHKey = $634456ee3058786c$var$_toGHASHKey;\nconst $634456ee3058786c$var$estimateWindow = (bytes)=>{\n    if (bytes > 65536) return 8;\n    if (bytes > 1024) return 4;\n    return 2;\n};\nclass $634456ee3058786c$var$GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength){\n        this.blockLen = $634456ee3058786c$var$BLOCK_SIZE;\n        this.outputLen = $634456ee3058786c$var$BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = (0, $38xio.toBytes)(key);\n        (0, $87adI.bytes)(key, 16);\n        const kView = (0, $38xio.createView)(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for(let i = 0; i < 128; i++){\n            doubles.push({\n                s0: $634456ee3058786c$var$swapLE(k0),\n                s1: $634456ee3058786c$var$swapLE(k1),\n                s2: $634456ee3058786c$var$swapLE(k2),\n                s3: $634456ee3058786c$var$swapLE(k3)\n            });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = $634456ee3058786c$var$mul2(k0, k1, k2, k3));\n        }\n        const W = $634456ee3058786c$var$estimateWindow(expectedLength || 1024);\n        if (![\n            1,\n            2,\n            4,\n            8\n        ].includes(W)) throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = this.windowSize = 2 ** W;\n        const items = [];\n        // Create precompute table for window of W bits\n        for(let w = 0; w < windows; w++)// truth table: 00, 01, 10, 11\n        for(let byte = 0; byte < windowSize; byte++){\n            // prettier-ignore\n            let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n            for(let j = 0; j < W; j++){\n                const bit = byte >>> W - j - 1 & 1;\n                if (!bit) continue;\n                const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;\n            }\n            items.push({\n                s0: s0,\n                s1: s1,\n                s2: s2,\n                s3: s3\n            });\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;\n        const { W: W, t: t, windowSize: windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [\n            s0,\n            s1,\n            s2,\n            s3\n        ])for(let bytePos = 0; bytePos < 4; bytePos++){\n            const byte = num >>> 8 * bytePos & 0xff;\n            for(let bitPos = 8 / W - 1; bitPos >= 0; bitPos--){\n                const bit = byte >>> W * bitPos & mask;\n                const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;\n                w += 1;\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = (0, $38xio.toBytes)(data);\n        (0, $87adI.exists)(this);\n        const b32 = (0, $38xio.u32)(data);\n        const blocks = Math.floor(data.length / $634456ee3058786c$var$BLOCK_SIZE);\n        const left = data.length % $634456ee3058786c$var$BLOCK_SIZE;\n        for(let i = 0; i < blocks; i++)this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        if (left) {\n            $634456ee3058786c$var$ZEROS16.set(data.subarray(blocks * $634456ee3058786c$var$BLOCK_SIZE));\n            this._updateBlock($634456ee3058786c$var$ZEROS32[0], $634456ee3058786c$var$ZEROS32[1], $634456ee3058786c$var$ZEROS32[2], $634456ee3058786c$var$ZEROS32[3]);\n            $634456ee3058786c$var$ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t: t } = this;\n        // clean precompute table\n        for (const elm of t)elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;\n    }\n    digestInto(out) {\n        (0, $87adI.exists)(this);\n        (0, $87adI.output)(out, this);\n        this.finished = true;\n        const { s0: s0, s1: s1, s2: s2, s3: s3 } = this;\n        const o32 = (0, $38xio.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array($634456ee3058786c$var$BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass $634456ee3058786c$var$Polyval extends $634456ee3058786c$var$GHASH {\n    constructor(key, expectedLength){\n        key = (0, $38xio.toBytes)(key);\n        const ghKey = $634456ee3058786c$var$_toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = (0, $38xio.toBytes)(data);\n        (0, $87adI.exists)(this);\n        const b32 = (0, $38xio.u32)(data);\n        const left = data.length % $634456ee3058786c$var$BLOCK_SIZE;\n        const blocks = Math.floor(data.length / $634456ee3058786c$var$BLOCK_SIZE);\n        for(let i = 0; i < blocks; i++)this._updateBlock($634456ee3058786c$var$swapLE(b32[i * 4 + 3]), $634456ee3058786c$var$swapLE(b32[i * 4 + 2]), $634456ee3058786c$var$swapLE(b32[i * 4 + 1]), $634456ee3058786c$var$swapLE(b32[i * 4 + 0]));\n        if (left) {\n            $634456ee3058786c$var$ZEROS16.set(data.subarray(blocks * $634456ee3058786c$var$BLOCK_SIZE));\n            this._updateBlock($634456ee3058786c$var$swapLE($634456ee3058786c$var$ZEROS32[3]), $634456ee3058786c$var$swapLE($634456ee3058786c$var$ZEROS32[2]), $634456ee3058786c$var$swapLE($634456ee3058786c$var$ZEROS32[1]), $634456ee3058786c$var$swapLE($634456ee3058786c$var$ZEROS32[0]));\n            $634456ee3058786c$var$ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0, $87adI.exists)(this);\n        (0, $87adI.output)(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0: s0, s1: s1, s2: s2, s3: s3 } = this;\n        const o32 = (0, $38xio.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction $634456ee3058786c$var$wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key)=>hashCons(key, msg.length).update((0, $38xio.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength)=>hashCons(key, expectedLength);\n    return hashC;\n}\nmodule.exports.ghash = $634456ee3058786c$var$wrapConstructorWithKey((key, expectedLength)=>new $634456ee3058786c$var$GHASH(key, expectedLength));\nmodule.exports.polyval = $634456ee3058786c$var$wrapConstructorWithKey((key, expectedLength)=>new $634456ee3058786c$var$Polyval(key, expectedLength));\n\n});\n\n\nparcelRegister(\"lAjhr\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.xchacha20poly1305 = module.exports.chacha20poly1305 = module.exports._poly1305_aead = module.exports.chacha12 = module.exports.chacha8 = module.exports.xchacha20 = module.exports.chacha20 = module.exports.chacha20orig = module.exports.hchacha = void 0;\n\nvar $38xio = parcelRequire(\"38xio\");\n\nvar $byidz = parcelRequire(\"byidz\");\n\nvar $8niJx = parcelRequire(\"8niJx\");\n\nvar $87adI = parcelRequire(\"87adI\");\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */ // prettier-ignore\nfunction $040e20af249c8886$var$chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for(let r = 0; r < rounds; r += 2){\n        x00 = x00 + x04 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x00, 16);\n        x08 = x08 + x12 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x08, 12);\n        x00 = x00 + x04 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x00, 8);\n        x08 = x08 + x12 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x08, 7);\n        x01 = x01 + x05 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x01, 16);\n        x09 = x09 + x13 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x09, 12);\n        x01 = x01 + x05 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x01, 8);\n        x09 = x09 + x13 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x09, 7);\n        x02 = x02 + x06 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x02, 16);\n        x10 = x10 + x14 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x10, 12);\n        x02 = x02 + x06 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x02, 8);\n        x10 = x10 + x14 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x10, 7);\n        x03 = x03 + x07 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x03, 16);\n        x11 = x11 + x15 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x11, 12);\n        x03 = x03 + x07 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x03, 8);\n        x11 = x11 + x15 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x11, 7);\n        x00 = x00 + x05 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x00, 16);\n        x10 = x10 + x15 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x10, 12);\n        x00 = x00 + x05 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x00, 8);\n        x10 = x10 + x15 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x10, 7);\n        x01 = x01 + x06 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x01, 16);\n        x11 = x11 + x12 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x11, 12);\n        x01 = x01 + x06 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x01, 8);\n        x11 = x11 + x12 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x11, 7);\n        x02 = x02 + x07 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x02, 16);\n        x08 = x08 + x13 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x08, 12);\n        x02 = x02 + x07 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x02, 8);\n        x08 = x08 + x13 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x08, 7);\n        x03 = x03 + x04 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x03, 16);\n        x09 = x09 + x14 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x09, 12);\n        x03 = x03 + x04 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x03, 8);\n        x09 = x09 + x14 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = y00 + x00 | 0;\n    out[oi++] = y01 + x01 | 0;\n    out[oi++] = y02 + x02 | 0;\n    out[oi++] = y03 + x03 | 0;\n    out[oi++] = y04 + x04 | 0;\n    out[oi++] = y05 + x05 | 0;\n    out[oi++] = y06 + x06 | 0;\n    out[oi++] = y07 + x07 | 0;\n    out[oi++] = y08 + x08 | 0;\n    out[oi++] = y09 + x09 | 0;\n    out[oi++] = y10 + x10 | 0;\n    out[oi++] = y11 + x11 | 0;\n    out[oi++] = y12 + x12 | 0;\n    out[oi++] = y13 + x13 | 0;\n    out[oi++] = y14 + x14 | 0;\n    out[oi++] = y15 + x15 | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */ // prettier-ignore\nfunction $040e20af249c8886$var$hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for(let r = 0; r < 20; r += 2){\n        x00 = x00 + x04 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x00, 16);\n        x08 = x08 + x12 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x08, 12);\n        x00 = x00 + x04 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x00, 8);\n        x08 = x08 + x12 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x08, 7);\n        x01 = x01 + x05 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x01, 16);\n        x09 = x09 + x13 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x09, 12);\n        x01 = x01 + x05 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x01, 8);\n        x09 = x09 + x13 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x09, 7);\n        x02 = x02 + x06 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x02, 16);\n        x10 = x10 + x14 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x10, 12);\n        x02 = x02 + x06 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x02, 8);\n        x10 = x10 + x14 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x10, 7);\n        x03 = x03 + x07 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x03, 16);\n        x11 = x11 + x15 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x11, 12);\n        x03 = x03 + x07 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x03, 8);\n        x11 = x11 + x15 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x11, 7);\n        x00 = x00 + x05 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x00, 16);\n        x10 = x10 + x15 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x10, 12);\n        x00 = x00 + x05 | 0;\n        x15 = (0, $8niJx.rotl)(x15 ^ x00, 8);\n        x10 = x10 + x15 | 0;\n        x05 = (0, $8niJx.rotl)(x05 ^ x10, 7);\n        x01 = x01 + x06 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x01, 16);\n        x11 = x11 + x12 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x11, 12);\n        x01 = x01 + x06 | 0;\n        x12 = (0, $8niJx.rotl)(x12 ^ x01, 8);\n        x11 = x11 + x12 | 0;\n        x06 = (0, $8niJx.rotl)(x06 ^ x11, 7);\n        x02 = x02 + x07 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x02, 16);\n        x08 = x08 + x13 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x08, 12);\n        x02 = x02 + x07 | 0;\n        x13 = (0, $8niJx.rotl)(x13 ^ x02, 8);\n        x08 = x08 + x13 | 0;\n        x07 = (0, $8niJx.rotl)(x07 ^ x08, 7);\n        x03 = x03 + x04 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x03, 16);\n        x09 = x09 + x14 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x09, 12);\n        x03 = x03 + x04 | 0;\n        x14 = (0, $8niJx.rotl)(x14 ^ x03, 8);\n        x09 = x09 + x14 | 0;\n        x04 = (0, $8niJx.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\nmodule.exports.hchacha = $040e20af249c8886$var$hchacha;\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */ module.exports.chacha20orig = (0, $8niJx.createCipher)($040e20af249c8886$var$chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */ module.exports.chacha20 = (0, $8niJx.createCipher)($040e20af249c8886$var$chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */ module.exports.xchacha20 = (0, $8niJx.createCipher)($040e20af249c8886$var$chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: $040e20af249c8886$var$hchacha,\n    allowShortKeys: false\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */ module.exports.chacha8 = (0, $8niJx.createCipher)($040e20af249c8886$var$chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */ module.exports.chacha12 = (0, $8niJx.createCipher)($040e20af249c8886$var$chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12\n});\nconst $040e20af249c8886$var$ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst $040e20af249c8886$var$updatePadded = (h, msg)=>{\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left) h.update($040e20af249c8886$var$ZEROS16.subarray(left));\n};\nconst $040e20af249c8886$var$ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction $040e20af249c8886$var$computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, $040e20af249c8886$var$ZEROS32);\n    const h = $byidz.poly1305.create(authKey);\n    if (AAD) $040e20af249c8886$var$updatePadded(h, AAD);\n    $040e20af249c8886$var$updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0, $38xio.createView)(num);\n    (0, $38xio.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0, $38xio.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */ const $040e20af249c8886$var$_poly1305_aead = (xorStream)=>(key, nonce, AAD)=>{\n        const tagLength = 16;\n        (0, $87adI.bytes)(key, 32);\n        (0, $87adI.bytes)(nonce);\n        return {\n            encrypt: (plaintext, output)=>{\n                const plength = plaintext.length;\n                const clength = plength + tagLength;\n                if (output) (0, $87adI.bytes)(output, clength);\n                else output = new Uint8Array(clength);\n                xorStream(key, nonce, plaintext, output, 1);\n                const tag = $040e20af249c8886$var$computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n                output.set(tag, plength); // append tag\n                return output;\n            },\n            decrypt: (ciphertext, output)=>{\n                const clength = ciphertext.length;\n                const plength = clength - tagLength;\n                if (clength < tagLength) throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n                if (output) (0, $87adI.bytes)(output, plength);\n                else output = new Uint8Array(plength);\n                const data = ciphertext.subarray(0, -tagLength);\n                const passedTag = ciphertext.subarray(-tagLength);\n                const tag = $040e20af249c8886$var$computeTag(xorStream, key, nonce, data, AAD);\n                if (!(0, $38xio.equalBytes)(passedTag, tag)) throw new Error('invalid tag');\n                xorStream(key, nonce, data, output, 1);\n                return output;\n            }\n        };\n    };\nmodule.exports._poly1305_aead = $040e20af249c8886$var$_poly1305_aead;\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */ module.exports.chacha20poly1305 = (0, $38xio.wrapCipher)({\n    blockSize: 64,\n    nonceLength: 12,\n    tagLength: 16\n}, (0, module.exports._poly1305_aead)(module.exports.chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */ module.exports.xchacha20poly1305 = (0, $38xio.wrapCipher)({\n    blockSize: 64,\n    nonceLength: 24,\n    tagLength: 16\n}, (0, module.exports._poly1305_aead)(module.exports.xchacha20));\n\n});\nparcelRegister(\"byidz\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.poly1305 = module.exports.wrapConstructorWithKey = void 0;\n\nvar $87adI = parcelRequire(\"87adI\");\n\nvar $38xio = parcelRequire(\"38xio\");\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst $8691005ce78b9c39$var$u8to16 = (a, i)=>a[i++] & 0xff | (a[i++] & 0xff) << 8;\nclass $8691005ce78b9c39$var$Poly1305 {\n    constructor(key){\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0, $38xio.toBytes)(key);\n        (0, $87adI.bytes)(key, 32);\n        const t0 = $8691005ce78b9c39$var$u8to16(key, 0);\n        const t1 = $8691005ce78b9c39$var$u8to16(key, 2);\n        const t2 = $8691005ce78b9c39$var$u8to16(key, 4);\n        const t3 = $8691005ce78b9c39$var$u8to16(key, 6);\n        const t4 = $8691005ce78b9c39$var$u8to16(key, 8);\n        const t5 = $8691005ce78b9c39$var$u8to16(key, 10);\n        const t6 = $8691005ce78b9c39$var$u8to16(key, 12);\n        const t7 = $8691005ce78b9c39$var$u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n        this.r[5] = t4 >>> 1 & 0x1ffe;\n        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n        this.r[9] = t7 >>> 5 & 0x007f;\n        for(let i = 0; i < 8; i++)this.pad[i] = $8691005ce78b9c39$var$u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 2048;\n        const { h: h, r: r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = $8691005ce78b9c39$var$u8to16(data, offset + 0);\n        const t1 = $8691005ce78b9c39$var$u8to16(data, offset + 2);\n        const t2 = $8691005ce78b9c39$var$u8to16(data, offset + 4);\n        const t3 = $8691005ce78b9c39$var$u8to16(data, offset + 6);\n        const t4 = $8691005ce78b9c39$var$u8to16(data, offset + 8);\n        const t5 = $8691005ce78b9c39$var$u8to16(data, offset + 10);\n        const t6 = $8691005ce78b9c39$var$u8to16(data, offset + 12);\n        const t7 = $8691005ce78b9c39$var$u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 0x1fff);\n        let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 0x1fff);\n        let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 0x1fff);\n        let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 0x1fff);\n        let h5 = h[5] + (t4 >>> 1 & 0x1fff);\n        let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 0x1fff);\n        let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 0x1fff);\n        let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 0x1fff);\n        let h9 = h[9] + (t7 >>> 5 | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = (c << 2) + c | 0;\n        c = c + d0 | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h: h, pad: pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for(let i = 2; i < 10; i++){\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for(let i = 1; i < 10; i++){\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 8192;\n        let mask = (c ^ 1) - 1;\n        for(let i = 0; i < 10; i++)g[i] &= mask;\n        mask = ~mask;\n        for(let i = 0; i < 10; i++)h[i] = h[i] & mask | g[i];\n        h[0] = (h[0] | h[1] << 13) & 0xffff;\n        h[1] = (h[1] >>> 3 | h[2] << 10) & 0xffff;\n        h[2] = (h[2] >>> 6 | h[3] << 7) & 0xffff;\n        h[3] = (h[3] >>> 9 | h[4] << 4) & 0xffff;\n        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 0xffff;\n        h[5] = (h[6] >>> 2 | h[7] << 11) & 0xffff;\n        h[6] = (h[7] >>> 5 | h[8] << 8) & 0xffff;\n        h[7] = (h[8] >>> 8 | h[9] << 5) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for(let i = 1; i < 8; i++){\n            f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        (0, $87adI.exists)(this);\n        const { buffer: buffer, blockLen: blockLen } = this;\n        data = (0, $38xio.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for(; blockLen <= len - pos; pos += blockLen)this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        (0, $87adI.exists)(this);\n        (0, $87adI.output)(out, this);\n        this.finished = true;\n        const { buffer: buffer, h: h } = this;\n        let { pos: pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for(; pos < 16; pos++)buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for(let i = 0; i < 8; i++){\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer: buffer, outputLen: outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction $8691005ce78b9c39$var$wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key)=>hashCons(key).update((0, $38xio.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key)=>hashCons(key);\n    return hashC;\n}\nmodule.exports.wrapConstructorWithKey = $8691005ce78b9c39$var$wrapConstructorWithKey;\nmodule.exports.poly1305 = $8691005ce78b9c39$var$wrapConstructorWithKey((key)=>new $8691005ce78b9c39$var$Poly1305(key));\n\n});\n\nparcelRegister(\"8niJx\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.createCipher = module.exports.rotl = module.exports.sigma = void 0;\n\nvar $87adI = parcelRequire(\"87adI\");\n\nvar $38xio = parcelRequire(\"38xio\");\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/ // We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst $618f00ce983d19db$var$_utf8ToBytes = (str)=>Uint8Array.from(str.split('').map((c)=>c.charCodeAt(0)));\nconst $618f00ce983d19db$var$sigma16 = $618f00ce983d19db$var$_utf8ToBytes('expand 16-byte k');\nconst $618f00ce983d19db$var$sigma32 = $618f00ce983d19db$var$_utf8ToBytes('expand 32-byte k');\nconst $618f00ce983d19db$var$sigma16_32 = (0, $38xio.u32)($618f00ce983d19db$var$sigma16);\nconst $618f00ce983d19db$var$sigma32_32 = (0, $38xio.u32)($618f00ce983d19db$var$sigma32);\nmodule.exports.sigma = $618f00ce983d19db$var$sigma32_32.slice();\nfunction $618f00ce983d19db$var$rotl(a, b) {\n    return a << b | a >>> 32 - b;\n}\nmodule.exports.rotl = $618f00ce983d19db$var$rotl;\n// Is byte array aligned to 4 byte offset (u32)?\nfunction $618f00ce983d19db$var$isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst $618f00ce983d19db$var$BLOCK_LEN = 64;\nconst $618f00ce983d19db$var$BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst $618f00ce983d19db$var$MAX_COUNTER = 2 ** 32 - 1;\nconst $618f00ce983d19db$var$U32_EMPTY = new Uint32Array();\nfunction $618f00ce983d19db$var$runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array($618f00ce983d19db$var$BLOCK_LEN);\n    const b32 = (0, $38xio.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = $618f00ce983d19db$var$isAligned32(data) && $618f00ce983d19db$var$isAligned32(output);\n    const d32 = isAligned ? (0, $38xio.u32)(data) : $618f00ce983d19db$var$U32_EMPTY;\n    const o32 = isAligned ? (0, $38xio.u32)(output) : $618f00ce983d19db$var$U32_EMPTY;\n    for(let pos = 0; pos < len; counter++){\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= $618f00ce983d19db$var$MAX_COUNTER) throw new Error('arx: counter overflow');\n        const take = Math.min($618f00ce983d19db$var$BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === $618f00ce983d19db$var$BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n            for(let j = 0, posj; j < $618f00ce983d19db$var$BLOCK_LEN32; j++){\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += $618f00ce983d19db$var$BLOCK_LEN;\n            continue;\n        }\n        for(let j = 0, posj; j < take; j++){\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nfunction $618f00ce983d19db$var$createCipher(core, opts) {\n    const { allowShortKeys: allowShortKeys, extendNonceFn: extendNonceFn, counterLength: counterLength, counterRight: counterRight, rounds: rounds } = (0, $38xio.checkOpts)({\n        allowShortKeys: false,\n        counterLength: 8,\n        counterRight: false,\n        rounds: 20\n    }, opts);\n    if (typeof core !== 'function') throw new Error('core must be a function');\n    (0, $87adI.number)(counterLength);\n    (0, $87adI.number)(rounds);\n    (0, $87adI.bool)(counterRight);\n    (0, $87adI.bool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0)=>{\n        (0, $87adI.bytes)(key);\n        (0, $87adI.bytes)(nonce);\n        (0, $87adI.bytes)(data);\n        const len = data.length;\n        if (!output) output = new Uint8Array(len);\n        (0, $87adI.bytes)(output);\n        (0, $87adI.number)(counter);\n        if (counter < 0 || counter >= $618f00ce983d19db$var$MAX_COUNTER) throw new Error('arx: counter overflow');\n        if (output.length < len) throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            k = key.slice();\n            toClean.push(k);\n            sigma = $618f00ce983d19db$var$sigma32_32;\n        } else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = $618f00ce983d19db$var$sigma16_32;\n            toClean.push(k);\n        } else throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!$618f00ce983d19db$var$isAligned32(nonce)) {\n            nonce = nonce.slice();\n            toClean.push(nonce);\n        }\n        const k32 = (0, $38xio.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0, $38xio.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length) throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0, $38xio.u32)(nonce);\n        $618f00ce983d19db$var$runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        while(toClean.length > 0)toClean.pop().fill(0);\n        return output;\n    };\n}\nmodule.exports.createCipher = $618f00ce983d19db$var$createCipher;\n\n});\n\n\nparcelRegister(\"aN9nT\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.hkdf = module.exports.expand = module.exports.extract = void 0;\n\nvar $dNiq9 = parcelRequire(\"dNiq9\");\n\nvar $3Bcdj = parcelRequire(\"3Bcdj\");\n\nvar $70Xw9 = parcelRequire(\"70Xw9\");\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */ function $7db5c28b27589b25$var$extract(hash, ikm, salt) {\n    $dNiq9.default.hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0, $70Xw9.hmac)(hash, (0, $3Bcdj.toBytes)(salt), (0, $3Bcdj.toBytes)(ikm));\n}\nmodule.exports.extract = $7db5c28b27589b25$var$extract;\n// HKDF-Expand(PRK, info, L) -> OKM\nconst $7db5c28b27589b25$var$HKDF_COUNTER = new Uint8Array([\n    0\n]);\nconst $7db5c28b27589b25$var$EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */ function $7db5c28b27589b25$var$expand(hash, prk, info, length = 32) {\n    $dNiq9.default.hash(hash);\n    $dNiq9.default.number(length);\n    if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined) info = $7db5c28b27589b25$var$EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = $70Xw9.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for(let counter = 0; counter < blocks; counter++){\n        $7db5c28b27589b25$var$HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? $7db5c28b27589b25$var$EMPTY_BUFFER : T).update(info).update($7db5c28b27589b25$var$HKDF_COUNTER).digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    $7db5c28b27589b25$var$HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\nmodule.exports.expand = $7db5c28b27589b25$var$expand;\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */ const $7db5c28b27589b25$var$hkdf = (hash, ikm, salt, info, length)=>$7db5c28b27589b25$var$expand(hash, $7db5c28b27589b25$var$extract(hash, ikm, salt), info, length);\nmodule.exports.hkdf = $7db5c28b27589b25$var$hkdf;\n\n});\nparcelRegister(\"70Xw9\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nmodule.exports.hmac = module.exports.HMAC = void 0;\n\nvar $dNiq9 = parcelRequire(\"dNiq9\");\n\nvar $3Bcdj = parcelRequire(\"3Bcdj\");\n// HMAC (RFC 2104)\nclass $51b6b372898f65c0$var$HMAC extends $3Bcdj.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        $dNiq9.default.hash(hash);\n        const key = (0, $3Bcdj.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        $dNiq9.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        $dNiq9.default.exists(this);\n        $dNiq9.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash: oHash, iHash: iHash, finished: finished, destroyed: destroyed, blockLen: blockLen, outputLen: outputLen } = this;\n        to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nmodule.exports.HMAC = $51b6b372898f65c0$var$HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */ const $51b6b372898f65c0$var$hmac = (hash, key, message)=>new $51b6b372898f65c0$var$HMAC(hash, key).update(message).digest();\nmodule.exports.hmac = $51b6b372898f65c0$var$hmac;\nmodule.exports.hmac.create = (hash, key)=>new $51b6b372898f65c0$var$HMAC(hash, key);\n\n});\n\n\n\nparcelRegister(\"imRk1\", function(module, exports) {\n\n$parcel$export(module.exports, \"Invoice\", () => $d5f3a4ad9113e89a$export$ba5f874f962e090e);\n$parcel$export(module.exports, \"LightningAddress\", () => $d5f3a4ad9113e89a$export$ebeb97171ba8142c);\n$parcel$export(module.exports, \"fiat\", () => $d5f3a4ad9113e89a$export$c32e8ef196152e59);\nvar $d5f3a4ad9113e89a$var$e, $d5f3a4ad9113e89a$var$t, $d5f3a4ad9113e89a$var$r = ($d5f3a4ad9113e89a$var$e = function(e, t) {\n    function r(e) {\n        if (!Number.isSafeInteger(e)) throw new Error(`Wrong integer: ${e}`);\n    }\n    function n(...e) {\n        const t = (e, t)=>(r)=>e(t(r));\n        return {\n            encode: Array.from(e).reverse().reduce((e, r)=>e ? t(e, r.encode) : r.encode, void 0),\n            decode: e.reduce((e, r)=>e ? t(e, r.decode) : r.decode, void 0)\n        };\n    }\n    function o(e) {\n        return {\n            encode: (t)=>{\n                if (!Array.isArray(t) || t.length && \"number\" != typeof t[0]) throw new Error(\"alphabet.encode input should be an array of numbers\");\n                return t.map((t)=>{\n                    if (r(t), t < 0 || t >= e.length) throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);\n                    return e[t];\n                });\n            },\n            decode: (t)=>{\n                if (!Array.isArray(t) || t.length && \"string\" != typeof t[0]) throw new Error(\"alphabet.decode input should be array of strings\");\n                return t.map((t)=>{\n                    if (\"string\" != typeof t) throw new Error(`alphabet.decode: not string element=${t}`);\n                    const r = e.indexOf(t);\n                    if (-1 === r) throw new Error(`Unknown letter: \"${t}\". Allowed: ${e}`);\n                    return r;\n                });\n            }\n        };\n    }\n    function i(e = \"\") {\n        if (\"string\" != typeof e) throw new Error(\"join separator should be string\");\n        return {\n            encode: (t)=>{\n                if (!Array.isArray(t) || t.length && \"string\" != typeof t[0]) throw new Error(\"join.encode input should be array of strings\");\n                for (let e of t)if (\"string\" != typeof e) throw new Error(`join.encode: non-string input=${e}`);\n                return t.join(e);\n            },\n            decode: (t)=>{\n                if (\"string\" != typeof t) throw new Error(\"join.decode input should be string\");\n                return t.split(e);\n            }\n        };\n    }\n    function s(e, t = \"=\") {\n        if (r(e), \"string\" != typeof t) throw new Error(\"padding chr should be string\");\n        return {\n            encode (r) {\n                if (!Array.isArray(r) || r.length && \"string\" != typeof r[0]) throw new Error(\"padding.encode input should be array of strings\");\n                for (let e of r)if (\"string\" != typeof e) throw new Error(`padding.encode: non-string input=${e}`);\n                for(; r.length * e % 8;)r.push(t);\n                return r;\n            },\n            decode (r) {\n                if (!Array.isArray(r) || r.length && \"string\" != typeof r[0]) throw new Error(\"padding.encode input should be array of strings\");\n                for (let e of r)if (\"string\" != typeof e) throw new Error(`padding.decode: non-string input=${e}`);\n                let n = r.length;\n                if (n * e % 8) throw new Error(\"Invalid padding: string should have whole number of bytes\");\n                for(; n > 0 && r[n - 1] === t; n--)if (!((n - 1) * e % 8)) throw new Error(\"Invalid padding: string has too much padding\");\n                return r.slice(0, n);\n            }\n        };\n    }\n    function a(e) {\n        if (\"function\" != typeof e) throw new Error(\"normalize fn should be function\");\n        return {\n            encode: (e)=>e,\n            decode: (t)=>e(t)\n        };\n    }\n    function c(e, t, n) {\n        if (t < 2) throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);\n        if (n < 2) throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);\n        if (!Array.isArray(e)) throw new Error(\"convertRadix: data should be array\");\n        if (!e.length) return [];\n        let o = 0;\n        const i = [], s = Array.from(e);\n        for(s.forEach((e)=>{\n            if (r(e), e < 0 || e >= t) throw new Error(`Wrong integer: ${e}`);\n        });;){\n            let e = 0, r = !0;\n            for(let i = o; i < s.length; i++){\n                const a = s[i], c = t * e + a;\n                if (!Number.isSafeInteger(c) || t * e / t !== e || c - a != t * e) throw new Error(\"convertRadix: carry overflow\");\n                if (e = c % n, s[i] = Math.floor(c / n), !Number.isSafeInteger(s[i]) || s[i] * n + e !== c) throw new Error(\"convertRadix: carry overflow\");\n                r && (s[i] ? r = !1 : o = i);\n            }\n            if (i.push(e), r) break;\n        }\n        for(let t = 0; t < e.length - 1 && 0 === e[t]; t++)i.push(0);\n        return i.reverse();\n    }\n    Object.defineProperty(t, \"__esModule\", {\n        value: !0\n    }), t.bytes = t.stringToBytes = t.str = t.bytesToString = t.hex = t.utf8 = t.bech32m = t.bech32 = t.base58check = t.base58xmr = t.base58xrp = t.base58flickr = t.base58 = t.base64url = t.base64 = t.base32crockford = t.base32hex = t.base32 = t.base16 = t.utils = t.assertNumber = void 0, t.assertNumber = r;\n    const u = (e, t)=>t ? u(t, e % t) : e, h = (e, t)=>e + (t - u(e, t));\n    function l(e, t, n, o) {\n        if (!Array.isArray(e)) throw new Error(\"convertRadix2: data should be array\");\n        if (t <= 0 || t > 32) throw new Error(`convertRadix2: wrong from=${t}`);\n        if (n <= 0 || n > 32) throw new Error(`convertRadix2: wrong to=${n}`);\n        if (h(t, n) > 32) throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${h(t, n)}`);\n        let i = 0, s = 0;\n        const a = 2 ** n - 1, c = [];\n        for (const o of e){\n            if (r(o), o >= 2 ** t) throw new Error(`convertRadix2: invalid data word=${o} from=${t}`);\n            if (i = i << t | o, s + t > 32) throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);\n            for(s += t; s >= n; s -= n)c.push((i >> s - n & a) >>> 0);\n            i &= 2 ** s - 1;\n        }\n        if (i = i << n - s & a, !o && s >= t) throw new Error(\"Excess padding\");\n        if (!o && i) throw new Error(`Non-zero padding: ${i}`);\n        return o && s > 0 && c.push(i >>> 0), c;\n    }\n    function f(e) {\n        return r(e), {\n            encode: (t)=>{\n                if (!(t instanceof Uint8Array)) throw new Error(\"radix.encode input should be Uint8Array\");\n                return c(Array.from(t), 256, e);\n            },\n            decode: (t)=>{\n                if (!Array.isArray(t) || t.length && \"number\" != typeof t[0]) throw new Error(\"radix.decode input should be array of strings\");\n                return Uint8Array.from(c(t, e, 256));\n            }\n        };\n    }\n    function d(e, t = !1) {\n        if (r(e), e <= 0 || e > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n        if (h(8, e) > 32 || h(e, 8) > 32) throw new Error(\"radix2: carry overflow\");\n        return {\n            encode: (r)=>{\n                if (!(r instanceof Uint8Array)) throw new Error(\"radix2.encode input should be Uint8Array\");\n                return l(Array.from(r), 8, e, !t);\n            },\n            decode: (r)=>{\n                if (!Array.isArray(r) || r.length && \"number\" != typeof r[0]) throw new Error(\"radix2.decode input should be array of strings\");\n                return Uint8Array.from(l(r, e, 8, t));\n            }\n        };\n    }\n    function p(e) {\n        if (\"function\" != typeof e) throw new Error(\"unsafeWrapper fn should be function\");\n        return function(...t) {\n            try {\n                return e.apply(null, t);\n            } catch (e) {}\n        };\n    }\n    function m(e, t) {\n        if (r(e), \"function\" != typeof t) throw new Error(\"checksum fn should be function\");\n        return {\n            encode (r) {\n                if (!(r instanceof Uint8Array)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n                const n = t(r).slice(0, e), o = new Uint8Array(r.length + e);\n                return o.set(r), o.set(n, r.length), o;\n            },\n            decode (r) {\n                if (!(r instanceof Uint8Array)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n                const n = r.slice(0, -e), o = t(n).slice(0, e), i = r.slice(-e);\n                for(let t = 0; t < e; t++)if (o[t] !== i[t]) throw new Error(\"Invalid checksum\");\n                return n;\n            }\n        };\n    }\n    t.utils = {\n        alphabet: o,\n        chain: n,\n        checksum: m,\n        radix: f,\n        radix2: d,\n        join: i,\n        padding: s\n    }, t.base16 = n(d(4), o(\"0123456789ABCDEF\"), i(\"\")), t.base32 = n(d(5), o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), s(5), i(\"\")), t.base32hex = n(d(5), o(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), s(5), i(\"\")), t.base32crockford = n(d(5), o(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), i(\"\"), a((e)=>e.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\"))), t.base64 = n(d(6), o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), s(6), i(\"\")), t.base64url = n(d(6), o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), s(6), i(\"\"));\n    const y = (e)=>n(f(58), o(e), i(\"\"));\n    t.base58 = y(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"), t.base58flickr = y(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"), t.base58xrp = y(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n    const w = [\n        0,\n        2,\n        3,\n        5,\n        6,\n        7,\n        9,\n        10,\n        11\n    ];\n    t.base58xmr = {\n        encode (e) {\n            let r = \"\";\n            for(let n = 0; n < e.length; n += 8){\n                const o = e.subarray(n, n + 8);\n                r += t.base58.encode(o).padStart(w[o.length], \"1\");\n            }\n            return r;\n        },\n        decode (e) {\n            let r = [];\n            for(let n = 0; n < e.length; n += 11){\n                const o = e.slice(n, n + 11), i = w.indexOf(o.length), s = t.base58.decode(o);\n                for(let e = 0; e < s.length - i; e++)if (0 !== s[e]) throw new Error(\"base58xmr: wrong padding\");\n                r = r.concat(Array.from(s.slice(s.length - i)));\n            }\n            return Uint8Array.from(r);\n        }\n    }, t.base58check = (e)=>n(m(4, (t)=>e(e(t))), t.base58);\n    const g = n(o(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), i(\"\")), v = [\n        996825010,\n        642813549,\n        513874426,\n        1027748829,\n        705979059\n    ];\n    function b(e) {\n        const t = e >> 25;\n        let r = (33554431 & e) << 5;\n        for(let e = 0; e < v.length; e++)1 == (t >> e & 1) && (r ^= v[e]);\n        return r;\n    }\n    function E(e, t, r = 1) {\n        const n = e.length;\n        let o = 1;\n        for(let t = 0; t < n; t++){\n            const r = e.charCodeAt(t);\n            if (r < 33 || r > 126) throw new Error(`Invalid prefix (${e})`);\n            o = b(o) ^ r >> 5;\n        }\n        o = b(o);\n        for(let t = 0; t < n; t++)o = b(o) ^ 31 & e.charCodeAt(t);\n        for (let e of t)o = b(o) ^ e;\n        for(let e = 0; e < 6; e++)o = b(o);\n        return o ^= r, g.encode(l([\n            o % 2 ** 30\n        ], 30, 5, !1));\n    }\n    function x(e) {\n        const t = \"bech32\" === e ? 1 : 734539939, r = d(5), n = r.decode, o = r.encode, i = p(n);\n        function s(e, r = 90) {\n            if (\"string\" != typeof e) throw new Error(\"bech32.decode input should be string, not \" + typeof e);\n            if (e.length < 8 || !1 !== r && e.length > r) throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${r})`);\n            const n = e.toLowerCase();\n            if (e !== n && e !== e.toUpperCase()) throw new Error(\"String must be lowercase or uppercase\");\n            const o = (e = n).lastIndexOf(\"1\");\n            if (0 === o || -1 === o) throw new Error('Letter \"1\" must be present between prefix and data only');\n            const i = e.slice(0, o), s1 = e.slice(o + 1);\n            if (s1.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n            const a = g.decode(s1).slice(0, -6), c = E(i, a, t);\n            if (!s1.endsWith(c)) throw new Error(`Invalid checksum in ${e}: expected \"${c}\"`);\n            return {\n                prefix: i,\n                words: a\n            };\n        }\n        return {\n            encode: function(e, r, n = 90) {\n                if (\"string\" != typeof e) throw new Error(\"bech32.encode prefix should be string, not \" + typeof e);\n                if (!Array.isArray(r) || r.length && \"number\" != typeof r[0]) throw new Error(\"bech32.encode words should be array of numbers, not \" + typeof r);\n                const o = e.length + 7 + r.length;\n                if (!1 !== n && o > n) throw new TypeError(`Length ${o} exceeds limit ${n}`);\n                return `${e = e.toLowerCase()}1${g.encode(r)}${E(e, r, t)}`;\n            },\n            decode: s,\n            decodeToBytes: function(e) {\n                const { prefix: t, words: r } = s(e, !1);\n                return {\n                    prefix: t,\n                    words: r,\n                    bytes: n(r)\n                };\n            },\n            decodeUnsafe: p(s),\n            fromWords: n,\n            fromWordsUnsafe: i,\n            toWords: o\n        };\n    }\n    t.bech32 = x(\"bech32\"), t.bech32m = x(\"bech32m\"), t.utf8 = {\n        encode: (e)=>(new TextDecoder).decode(e),\n        decode: (e)=>(new TextEncoder).encode(e)\n    }, t.hex = n(d(4), o(\"0123456789abcdef\"), i(\"\"), a((e)=>{\n        if (\"string\" != typeof e || e.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);\n        return e.toLowerCase();\n    }));\n    const P = {\n        utf8: t.utf8,\n        hex: t.hex,\n        base16: t.base16,\n        base32: t.base32,\n        base64: t.base64,\n        base64url: t.base64url,\n        base58: t.base58,\n        base58xmr: t.base58xmr\n    }, A = `Invalid encoding type. Available types: ${Object.keys(P).join(\", \")}`;\n    t.bytesToString = (e, t)=>{\n        if (\"string\" != typeof e || !P.hasOwnProperty(e)) throw new TypeError(A);\n        if (!(t instanceof Uint8Array)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n        return P[e].encode(t);\n    }, t.str = t.bytesToString, t.stringToBytes = (e, t)=>{\n        if (!P.hasOwnProperty(e)) throw new TypeError(A);\n        if (\"string\" != typeof t) throw new TypeError(\"stringToBytes() expects string\");\n        return P[e].decode(t);\n    }, t.bytes = t.stringToBytes;\n}, $d5f3a4ad9113e89a$var$e($d5f3a4ad9113e89a$var$t = {\n    exports: {}\n}, $d5f3a4ad9113e89a$var$t.exports), $d5f3a4ad9113e89a$var$t.exports);\nconst { bech32: $d5f3a4ad9113e89a$var$n, hex: $d5f3a4ad9113e89a$var$o, utf8: $d5f3a4ad9113e89a$var$i } = $d5f3a4ad9113e89a$var$r, $d5f3a4ad9113e89a$var$s = {\n    bech32: \"bc\",\n    pubKeyHash: 0,\n    scriptHash: 5,\n    validWitnessVersions: [\n        0\n    ]\n}, $d5f3a4ad9113e89a$var$a = {\n    bech32: \"tb\",\n    pubKeyHash: 111,\n    scriptHash: 196,\n    validWitnessVersions: [\n        0\n    ]\n}, $d5f3a4ad9113e89a$var$c = {\n    bech32: \"tbs\",\n    pubKeyHash: 111,\n    scriptHash: 196,\n    validWitnessVersions: [\n        0\n    ]\n}, $d5f3a4ad9113e89a$var$u = {\n    bech32: \"bcrt\",\n    pubKeyHash: 111,\n    scriptHash: 196,\n    validWitnessVersions: [\n        0\n    ]\n}, $d5f3a4ad9113e89a$var$h = {\n    bech32: \"sb\",\n    pubKeyHash: 63,\n    scriptHash: 123,\n    validWitnessVersions: [\n        0\n    ]\n}, $d5f3a4ad9113e89a$var$l = [\n    \"option_data_loss_protect\",\n    \"initial_routing_sync\",\n    \"option_upfront_shutdown_script\",\n    \"gossip_queries\",\n    \"var_onion_optin\",\n    \"gossip_queries_ex\",\n    \"option_static_remotekey\",\n    \"payment_secret\",\n    \"basic_mpp\",\n    \"option_support_large_channel\"\n], $d5f3a4ad9113e89a$var$f = {\n    m: BigInt(1e3),\n    u: BigInt(1e6),\n    n: BigInt(1e9),\n    p: BigInt(1e12)\n}, $d5f3a4ad9113e89a$var$d = BigInt(\"2100000000000000000\"), $d5f3a4ad9113e89a$var$p = BigInt(1e11), $d5f3a4ad9113e89a$var$m = {\n    payment_hash: 1,\n    payment_secret: 16,\n    description: 13,\n    payee: 19,\n    description_hash: 23,\n    expiry: 6,\n    min_final_cltv_expiry: 24,\n    fallback_address: 9,\n    route_hint: 3,\n    feature_bits: 5,\n    metadata: 27\n}, $d5f3a4ad9113e89a$var$y = {};\nfor(let e = 0, t = Object.keys($d5f3a4ad9113e89a$var$m); e < t.length; e++){\n    const r = t[e], n = $d5f3a4ad9113e89a$var$m[t[e]].toString();\n    $d5f3a4ad9113e89a$var$y[n] = r;\n}\nconst $d5f3a4ad9113e89a$var$w = {\n    1: (e)=>$d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    16: (e)=>$d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    13: (e)=>$d5f3a4ad9113e89a$var$i.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    19: (e)=>$d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    23: (e)=>$d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    27: (e)=>$d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e)),\n    6: $d5f3a4ad9113e89a$var$v,\n    24: $d5f3a4ad9113e89a$var$v,\n    3: function(e) {\n        const t = [];\n        let r, i, s, a, c, u = $d5f3a4ad9113e89a$var$n.fromWordsUnsafe(e);\n        for(; u.length > 0;)r = $d5f3a4ad9113e89a$var$o.encode(u.slice(0, 33)), i = $d5f3a4ad9113e89a$var$o.encode(u.slice(33, 41)), s = parseInt($d5f3a4ad9113e89a$var$o.encode(u.slice(41, 45)), 16), a = parseInt($d5f3a4ad9113e89a$var$o.encode(u.slice(45, 49)), 16), c = parseInt($d5f3a4ad9113e89a$var$o.encode(u.slice(49, 51)), 16), u = u.slice(51), t.push({\n            pubkey: r,\n            short_channel_id: i,\n            fee_base_msat: s,\n            fee_proportional_millionths: a,\n            cltv_expiry_delta: c\n        });\n        return t;\n    },\n    5: function(e) {\n        const t = e.slice().reverse().map((e)=>[\n                !!(1 & e),\n                !!(2 & e),\n                !!(4 & e),\n                !!(8 & e),\n                !!(16 & e)\n            ]).reduce((e, t)=>e.concat(t), []);\n        for(; t.length < 2 * $d5f3a4ad9113e89a$var$l.length;)t.push(!1);\n        const r = {};\n        $d5f3a4ad9113e89a$var$l.forEach((e, n)=>{\n            let o;\n            o = t[2 * n] ? \"required\" : t[2 * n + 1] ? \"supported\" : \"unsupported\", r[e] = o;\n        });\n        const n = t.slice(2 * $d5f3a4ad9113e89a$var$l.length);\n        return r.extra_bits = {\n            start_bit: 2 * $d5f3a4ad9113e89a$var$l.length,\n            bits: n,\n            has_required: n.reduce((e, t, r)=>r % 2 != 0 ? e || !1 : e || t, !1)\n        }, r;\n    }\n};\nfunction $d5f3a4ad9113e89a$var$g(e) {\n    return (t)=>({\n            tagCode: parseInt(e),\n            words: $d5f3a4ad9113e89a$var$n.encode(\"unknown\", t, Number.MAX_SAFE_INTEGER)\n        });\n}\nfunction $d5f3a4ad9113e89a$var$v(e) {\n    return e.reverse().reduce((e, t, r)=>e + t * Math.pow(32, r), 0);\n}\nvar $d5f3a4ad9113e89a$export$99a70112ceb8327b = function(e) {\n    return Uint8Array.from(e.match(/.{1,2}/g).map(function(e) {\n        return parseInt(e, 16);\n    }));\n}, $d5f3a4ad9113e89a$export$299d8670b6d2c8e = function(e) {\n    if (!e) return null;\n    try {\n        var t = function(e, t) {\n            if (\"string\" != typeof e) throw new Error(\"Lightning Payment Request must be string\");\n            if (\"ln\" !== e.slice(0, 2).toLowerCase()) throw new Error(\"Not a proper lightning payment request\");\n            const r = [], i = $d5f3a4ad9113e89a$var$n.decode(e, Number.MAX_SAFE_INTEGER);\n            e = e.toLowerCase();\n            const l = i.prefix;\n            let b = i.words, E = e.slice(l.length + 1), x = b.slice(-104);\n            b = b.slice(0, -104);\n            let P = l.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/);\n            if (P && !P[2] && (P = l.match(/^ln(\\S+)$/)), !P) throw new Error(\"Not a proper lightning payment request\");\n            r.push({\n                name: \"lightning_network\",\n                letters: \"ln\"\n            });\n            const A = P[1];\n            let k;\n            switch(A){\n                case $d5f3a4ad9113e89a$var$s.bech32:\n                    k = $d5f3a4ad9113e89a$var$s;\n                    break;\n                case $d5f3a4ad9113e89a$var$a.bech32:\n                    k = $d5f3a4ad9113e89a$var$a;\n                    break;\n                case $d5f3a4ad9113e89a$var$c.bech32:\n                    k = $d5f3a4ad9113e89a$var$c;\n                    break;\n                case $d5f3a4ad9113e89a$var$u.bech32:\n                    k = $d5f3a4ad9113e89a$var$u;\n                    break;\n                case $d5f3a4ad9113e89a$var$h.bech32:\n                    k = $d5f3a4ad9113e89a$var$h;\n            }\n            if (!k || k.bech32 !== A) throw new Error(\"Unknown coin bech32 prefix\");\n            r.push({\n                name: \"coin_network\",\n                letters: A,\n                value: k\n            });\n            const _ = P[2];\n            let U;\n            _ ? (U = function(e, t) {\n                let r, n;\n                if (e.slice(-1).match(/^[munp]$/)) r = e.slice(-1), n = e.slice(0, -1);\n                else {\n                    if (e.slice(-1).match(/^[^munp0-9]$/)) throw new Error(\"Not a valid multiplier for the amount\");\n                    n = e;\n                }\n                if (!n.match(/^\\d+$/)) throw new Error(\"Not a valid human readable amount\");\n                const o = BigInt(n), i = r ? o * $d5f3a4ad9113e89a$var$p / $d5f3a4ad9113e89a$var$f[r] : o * $d5f3a4ad9113e89a$var$p;\n                if (\"p\" === r && o % BigInt(10) !== BigInt(0) || i > $d5f3a4ad9113e89a$var$d) throw new Error(\"Amount is outside of valid range\");\n                return i.toString();\n            }(_ + P[3]), r.push({\n                name: \"amount\",\n                letters: P[2] + P[3],\n                value: U\n            })) : U = null, r.push({\n                name: \"separator\",\n                letters: \"1\"\n            });\n            const L = $d5f3a4ad9113e89a$var$v(b.slice(0, 7));\n            let D, N, I, j;\n            for(b = b.slice(7), r.push({\n                name: \"timestamp\",\n                letters: E.slice(0, 7),\n                value: L\n            }), E = E.slice(7); b.length > 0;){\n                const e = b[0].toString();\n                D = $d5f3a4ad9113e89a$var$y[e] || \"unknown_tag\", N = $d5f3a4ad9113e89a$var$w[e] || $d5f3a4ad9113e89a$var$g(e), b = b.slice(1), I = $d5f3a4ad9113e89a$var$v(b.slice(0, 2)), b = b.slice(2), j = b.slice(0, I), b = b.slice(I), r.push({\n                    name: D,\n                    tag: E[0],\n                    letters: E.slice(0, 3 + I),\n                    value: N(j)\n                }), E = E.slice(3 + I);\n            }\n            r.push({\n                name: \"signature\",\n                letters: E.slice(0, 104),\n                value: $d5f3a4ad9113e89a$var$o.encode($d5f3a4ad9113e89a$var$n.fromWordsUnsafe(x))\n            }), E = E.slice(104), r.push({\n                name: \"checksum\",\n                letters: E\n            });\n            let S = {\n                paymentRequest: e,\n                sections: r,\n                get expiry () {\n                    let e = r.find((e)=>\"expiry\" === e.name);\n                    if (e) return R(\"timestamp\") + e.value;\n                },\n                get route_hints () {\n                    return r.filter((e)=>\"route_hint\" === e.name).map((e)=>e.value);\n                }\n            };\n            for(let e in $d5f3a4ad9113e89a$var$m)\"route_hint\" !== e && Object.defineProperty(S, e, {\n                get: ()=>R(e)\n            });\n            return S;\n            function R(e) {\n                let t = r.find((t)=>t.name === e);\n                return t ? t.value : void 0;\n            }\n        }(e);\n        if (!t || !t.sections) return null;\n        var r = t.sections.find(function(e) {\n            return \"payment_hash\" === e.name;\n        });\n        if (\"payment_hash\" !== (null == r ? void 0 : r.name) || !r.value) return null;\n        var i = r.value, l = 0, b = t.sections.find(function(e) {\n            return \"amount\" === e.name;\n        });\n        \"amount\" === (null == b ? void 0 : b.name) && b.value && (l = parseInt(b.value) / 1e3);\n        var E = t.sections.find(function(e) {\n            return \"timestamp\" === e.name;\n        });\n        if (\"timestamp\" !== (null == E ? void 0 : E.name) || !E.value) return null;\n        var x, P = E.value, A = t.sections.find(function(e) {\n            return \"expiry\" === e.name;\n        });\n        \"expiry\" === (null == A ? void 0 : A.name) && (x = A.value);\n        var k = t.sections.find(function(e) {\n            return \"description\" === e.name;\n        });\n        return {\n            paymentHash: i,\n            satoshi: l,\n            timestamp: P,\n            expiry: x,\n            description: \"description\" === (null == k ? void 0 : k.name) ? null == k ? void 0 : k.value : void 0\n        };\n    } catch (e) {\n        return null;\n    }\n};\nfunction $d5f3a4ad9113e89a$var$x(e, t = !0) {\n    if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nconst $d5f3a4ad9113e89a$var$P = (e)=>e instanceof Uint8Array, $d5f3a4ad9113e89a$var$A = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), $d5f3a4ad9113e89a$var$k = (e, t)=>e << 32 - t | e >>> t;\nif (68 !== new Uint8Array(new Uint32Array([\n    287454020\n]).buffer)[0]) throw new Error(\"Non little-endian hardware is not supported\");\nconst $d5f3a4ad9113e89a$var$_ = /* @__PURE__ */ Array.from({\n    length: 256\n}, (e, t)=>t.toString(16).padStart(2, \"0\"));\nfunction $d5f3a4ad9113e89a$var$U(e) {\n    if (!$d5f3a4ad9113e89a$var$P(e)) throw new Error(\"Uint8Array expected\");\n    let t = \"\";\n    for(let r = 0; r < e.length; r++)t += $d5f3a4ad9113e89a$var$_[e[r]];\n    return t;\n}\nfunction $d5f3a4ad9113e89a$var$L(e) {\n    if (\"string\" == typeof e && (e = function(e) {\n        if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n        return new Uint8Array((new TextEncoder).encode(e));\n    }(e)), !$d5f3a4ad9113e89a$var$P(e)) throw new Error(\"expected Uint8Array, got \" + typeof e);\n    return e;\n}\nclass $d5f3a4ad9113e89a$var$D {\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction $d5f3a4ad9113e89a$var$N(e) {\n    const t = (t)=>e().update($d5f3a4ad9113e89a$var$L(t)).digest(), r = e();\n    return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = ()=>e(), t;\n}\nclass $d5f3a4ad9113e89a$var$I extends $d5f3a4ad9113e89a$var$D {\n    constructor(e, t, r, n){\n        super(), this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = $d5f3a4ad9113e89a$var$A(this.buffer);\n    }\n    update(e) {\n        $d5f3a4ad9113e89a$var$x(this);\n        const { view: t, buffer: r, blockLen: n } = this, o = (e = $d5f3a4ad9113e89a$var$L(e)).length;\n        for(let i = 0; i < o;){\n            const s = Math.min(n - this.pos, o - i);\n            if (s !== n) r.set(e.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === n && (this.process(t, 0), this.pos = 0);\n            else {\n                const t = $d5f3a4ad9113e89a$var$A(e);\n                for(; n <= o - i; i += n)this.process(t, i);\n            }\n        }\n        return this.length += e.length, this.roundClean(), this;\n    }\n    digestInto(e) {\n        $d5f3a4ad9113e89a$var$x(this), function(e, t) {\n            !function(e, ...t) {\n                if (!(e instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n                if (t.length > 0 && !t.includes(e.length)) throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`);\n            }(e);\n            const r = t.outputLen;\n            if (e.length < r) throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n        }(e, this), this.finished = !0;\n        const { buffer: t, view: r, blockLen: n, isLE: o } = this;\n        let { pos: i } = this;\n        t[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > n - i && (this.process(r, 0), i = 0);\n        for(let e = i; e < n; e++)t[e] = 0;\n        !function(e, t, r, n) {\n            if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, r, n);\n            const o = BigInt(32), i = BigInt(4294967295), s = Number(r >> o & i), a = Number(r & i), c = n ? 0 : 4;\n            e.setUint32(t + (n ? 4 : 0), s, n), e.setUint32(t + c, a, n);\n        }(r, n - 8, BigInt(8 * this.length), o), this.process(r, 0);\n        const s = $d5f3a4ad9113e89a$var$A(e), a = this.outputLen;\n        if (a % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const c = a / 4, u = this.get();\n        if (c > u.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let e = 0; e < c; e++)s.setUint32(4 * e, u[e], o);\n    }\n    digest() {\n        const { buffer: e, outputLen: t } = this;\n        this.digestInto(e);\n        const r = e.slice(0, t);\n        return this.destroy(), r;\n    }\n    _cloneInto(e) {\n        e || (e = new this.constructor), e.set(...this.get());\n        const { blockLen: t, buffer: r, length: n, finished: o, destroyed: i, pos: s } = this;\n        return e.length = n, e.pos = s, e.finished = o, e.destroyed = i, n % t && e.buffer.set(r), e;\n    }\n}\nconst $d5f3a4ad9113e89a$var$j = (e, t, r)=>e & t ^ e & r ^ t & r, $d5f3a4ad9113e89a$var$S = /* @__PURE__ */ new Uint32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n]), $d5f3a4ad9113e89a$var$R = /* @__PURE__ */ new Uint32Array([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n]), $d5f3a4ad9113e89a$var$$ = /* @__PURE__ */ new Uint32Array(64);\nclass $d5f3a4ad9113e89a$var$T extends $d5f3a4ad9113e89a$var$I {\n    constructor(){\n        super(64, 32, 8, !1), this.A = 0 | $d5f3a4ad9113e89a$var$R[0], this.B = 0 | $d5f3a4ad9113e89a$var$R[1], this.C = 0 | $d5f3a4ad9113e89a$var$R[2], this.D = 0 | $d5f3a4ad9113e89a$var$R[3], this.E = 0 | $d5f3a4ad9113e89a$var$R[4], this.F = 0 | $d5f3a4ad9113e89a$var$R[5], this.G = 0 | $d5f3a4ad9113e89a$var$R[6], this.H = 0 | $d5f3a4ad9113e89a$var$R[7];\n    }\n    get() {\n        const { A: e, B: t, C: r, D: n, E: o, F: i, G: s, H: a } = this;\n        return [\n            e,\n            t,\n            r,\n            n,\n            o,\n            i,\n            s,\n            a\n        ];\n    }\n    set(e, t, r, n, o, i, s, a) {\n        this.A = 0 | e, this.B = 0 | t, this.C = 0 | r, this.D = 0 | n, this.E = 0 | o, this.F = 0 | i, this.G = 0 | s, this.H = 0 | a;\n    }\n    process(e, t) {\n        for(let r = 0; r < 16; r++, t += 4)$d5f3a4ad9113e89a$var$$[r] = e.getUint32(t, !1);\n        for(let e = 16; e < 64; e++){\n            const t = $d5f3a4ad9113e89a$var$$[e - 15], r = $d5f3a4ad9113e89a$var$$[e - 2], n = $d5f3a4ad9113e89a$var$k(t, 7) ^ $d5f3a4ad9113e89a$var$k(t, 18) ^ t >>> 3, o = $d5f3a4ad9113e89a$var$k(r, 17) ^ $d5f3a4ad9113e89a$var$k(r, 19) ^ r >>> 10;\n            $d5f3a4ad9113e89a$var$$[e] = o + $d5f3a4ad9113e89a$var$$[e - 7] + n + $d5f3a4ad9113e89a$var$$[e - 16] | 0;\n        }\n        let { A: r, B: n, C: o, D: i, E: s, F: a, G: c, H: u } = this;\n        for(let e = 0; e < 64; e++){\n            const t = u + ($d5f3a4ad9113e89a$var$k(s, 6) ^ $d5f3a4ad9113e89a$var$k(s, 11) ^ $d5f3a4ad9113e89a$var$k(s, 25)) + ((h = s) & a ^ ~h & c) + $d5f3a4ad9113e89a$var$S[e] + $d5f3a4ad9113e89a$var$$[e] | 0, l = ($d5f3a4ad9113e89a$var$k(r, 2) ^ $d5f3a4ad9113e89a$var$k(r, 13) ^ $d5f3a4ad9113e89a$var$k(r, 22)) + $d5f3a4ad9113e89a$var$j(r, n, o) | 0;\n            u = c, c = a, a = s, s = i + t | 0, i = o, o = n, n = r, r = t + l | 0;\n        }\n        var h;\n        r = r + this.A | 0, n = n + this.B | 0, o = o + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, o, i, s, a, c, u);\n    }\n    roundClean() {\n        $d5f3a4ad9113e89a$var$$.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n    }\n}\nconst $d5f3a4ad9113e89a$var$W = /* @__PURE__ */ $d5f3a4ad9113e89a$var$N(()=>new $d5f3a4ad9113e89a$var$T);\nvar $d5f3a4ad9113e89a$export$ba5f874f962e090e = /*#__PURE__*/ function() {\n    function e(e) {\n        var t, r, n, o;\n        if (this.paymentRequest = void 0, this.paymentHash = void 0, this.preimage = void 0, this.verify = void 0, this.satoshi = void 0, this.expiry = void 0, this.timestamp = void 0, this.createdDate = void 0, this.expiryDate = void 0, this.description = void 0, this.successAction = void 0, this.paymentRequest = e.pr, !this.paymentRequest) throw new Error(\"Invalid payment request\");\n        var i = $d5f3a4ad9113e89a$export$299d8670b6d2c8e(this.paymentRequest);\n        if (!i) throw new Error(\"Failed to decode payment request\");\n        this.paymentHash = i.paymentHash, this.satoshi = i.satoshi, this.timestamp = i.timestamp, this.expiry = i.expiry, this.createdDate = new Date(1e3 * this.timestamp), this.expiryDate = this.expiry ? new Date(1e3 * (this.timestamp + this.expiry)) : void 0, this.description = null != (t = i.description) ? t : null, this.verify = null != (r = e.verify) ? r : null, this.preimage = null != (n = e.preimage) ? n : null, this.successAction = null != (o = e.successAction) ? o : null;\n    }\n    var t = e.prototype;\n    return t.isPaid = function() {\n        try {\n            var e = this;\n            if (e.preimage) return Promise.resolve(e.validatePreimage(e.preimage));\n            if (e.verify) return Promise.resolve(e.verifyPayment());\n            throw new Error(\"Could not verify payment\");\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.validatePreimage = function(e) {\n        if (!e || !this.paymentHash) return !1;\n        try {\n            var t = $d5f3a4ad9113e89a$var$U($d5f3a4ad9113e89a$var$W($d5f3a4ad9113e89a$export$99a70112ceb8327b(e)));\n            return this.paymentHash === t;\n        } catch (e) {\n            return !1;\n        }\n    }, t.verifyPayment = function() {\n        try {\n            var e = this;\n            return Promise.resolve(function(t, r) {\n                try {\n                    var n = function() {\n                        if (!e.verify) throw new Error(\"LNURL verify not available\");\n                        return Promise.resolve(fetch(e.verify)).then(function(t) {\n                            if (!t.ok) throw new Error(\"Verification request failed: \" + t.status + \" \" + t.statusText);\n                            return Promise.resolve(t.json()).then(function(t) {\n                                return t.preimage && (e.preimage = t.preimage), t.settled;\n                            });\n                        });\n                    }();\n                } catch (e) {\n                    return r(e);\n                }\n                return n && n.then ? n.then(void 0, r) : n;\n            }(0, function(e) {\n                return console.error(\"Failed to check LNURL-verify\", e), !1;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.hasExpired = function() {\n        var e = this.expiryDate;\n        return !!e && e.getTime() < Date.now();\n    }, e;\n}(), $d5f3a4ad9113e89a$export$1890c02602d63c = function(e, t) {\n    var r = e.satoshi, n = e.comment, o = e.p, i = e.e, s = e.relays;\n    void 0 === t && (t = {});\n    try {\n        var a = t.nostr || globalThis.nostr;\n        if (!a) throw new Error(\"nostr option or window.nostr is not available\");\n        var c = [\n            [\n                \"relays\"\n            ].concat(s),\n            [\n                \"amount\",\n                r.toString()\n            ]\n        ];\n        return o && c.push([\n            \"p\",\n            o\n        ]), i && c.push([\n            \"e\",\n            i\n        ]), Promise.resolve(a.getPublicKey()).then(function(e) {\n            var t = {\n                pubkey: e,\n                created_at: Math.floor(Date.now() / 1e3),\n                kind: 9734,\n                tags: c,\n                content: null != n ? n : \"\"\n            };\n            return t.id = $d5f3a4ad9113e89a$export$11a838ad4e557e0e(t), Promise.resolve(a.signEvent(t));\n        });\n    } catch (i) {\n        return Promise.reject(i);\n    }\n}, $d5f3a4ad9113e89a$export$3e6ee22e431c91ae = function(e) {\n    if (\"keysend\" !== e.tag) throw new Error(\"Invalid keysend params\");\n    if (\"OK\" !== e.status) throw new Error(\"Keysend status not OK\");\n    if (!e.pubkey) throw new Error(\"Pubkey does not exist\");\n    var t, r;\n    return e.customData && e.customData[0] && (t = e.customData[0].customKey, r = e.customData[0].customValue), {\n        destination: e.pubkey,\n        customKey: t,\n        customValue: r\n    };\n};\nfunction $d5f3a4ad9113e89a$export$d08d852dd562b1ce(e) {\n    if (\"string\" != typeof e.content) return !1;\n    if (\"number\" != typeof e.created_at) return !1;\n    if (!Array.isArray(e.tags)) return !1;\n    for(var t = 0; t < e.tags.length; t++){\n        var r = e.tags[t];\n        if (!Array.isArray(r)) return !1;\n        for(var n = 0; n < r.length; n++)if (\"object\" == typeof r[n]) return !1;\n    }\n    return !0;\n}\nfunction $d5f3a4ad9113e89a$export$d32d86987f616a9e(e) {\n    if (!$d5f3a4ad9113e89a$export$d08d852dd562b1ce(e)) throw new Error(\"can't serialize event with wrong or missing properties\");\n    return JSON.stringify([\n        0,\n        e.pubkey,\n        e.created_at,\n        e.kind,\n        e.tags,\n        e.content\n    ]);\n}\nfunction $d5f3a4ad9113e89a$export$11a838ad4e557e0e(e) {\n    return $d5f3a4ad9113e89a$var$U($d5f3a4ad9113e89a$var$W($d5f3a4ad9113e89a$export$d32d86987f616a9e(e)));\n}\nfunction $d5f3a4ad9113e89a$export$fe45bd6b19e4f4ba(e, t) {\n    var r, n, o, i;\n    return t && e && (n = (r = null == (o = e.names) ? void 0 : o[t]) ? null == (i = e.relays) ? void 0 : i[r] : void 0), [\n        e,\n        r,\n        n\n    ];\n}\nvar $d5f3a4ad9113e89a$var$q = /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=+$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[+~%/.\\w-_]*)?\\??(?:[-+=&;%@.\\w_]*)#?(?:[\\w]*))?)/, $d5f3a4ad9113e89a$export$8304a22d431f958 = function(e) {\n    return !!e && $d5f3a4ad9113e89a$var$q.test(e);\n}, $d5f3a4ad9113e89a$export$3c93f2a0ff50284a = function(e) {\n    var t = e.amount;\n    return t > 0 && t >= e.min && t <= e.max;\n}, $d5f3a4ad9113e89a$export$178fe3191ba1e804 = function(e) {\n    try {\n        if (\"payRequest\" !== e.tag) throw new Error(\"Invalid pay service params\");\n        var t = (e.callback + \"\").trim();\n        if (!$d5f3a4ad9113e89a$export$8304a22d431f958(t)) throw new Error(\"Callback must be a valid url\");\n        var r, n, o = Math.ceil(Number(e.minSendable || 0)), i = Math.floor(Number(e.maxSendable));\n        if (!o || !i || o > i) throw new Error(\"Invalid pay service params\");\n        try {\n            r = JSON.parse(e.metadata + \"\"), n = $d5f3a4ad9113e89a$var$U($d5f3a4ad9113e89a$var$W(e.metadata + \"\"));\n        } catch (e) {\n            r = [], n = $d5f3a4ad9113e89a$var$U($d5f3a4ad9113e89a$var$W(\"[]\"));\n        }\n        for(var s = \"\", a = \"\", c = \"\", u = \"\", h = 0; h < r.length; h++){\n            var l = r[h], f = l[0], d = l[1];\n            switch(f){\n                case \"text/plain\":\n                    c = d;\n                    break;\n                case \"text/identifier\":\n                    u = d;\n                    break;\n                case \"text/email\":\n                    s = d;\n                    break;\n                case \"image/png;base64\":\n                case \"image/jpeg;base64\":\n                    a = \"data:\" + f + \",\" + d;\n            }\n        }\n        var p, m = e.payerData;\n        try {\n            p = new URL(t).hostname;\n        } catch (e) {}\n        return Promise.resolve({\n            callback: t,\n            fixed: o === i,\n            min: o,\n            max: i,\n            domain: p,\n            metadata: r,\n            metadataHash: n,\n            identifier: u,\n            email: s,\n            description: c,\n            image: a,\n            payerData: m,\n            commentAllowed: Number(e.commentAllowed) || 0,\n            rawData: e,\n            allowsNostr: e.allowsNostr || !1\n        });\n    } catch (e) {\n        return Promise.reject(e);\n    }\n};\nfunction $d5f3a4ad9113e89a$var$J() {\n    return $d5f3a4ad9113e89a$var$J = Object.assign ? Object.assign.bind() : function(e) {\n        for(var t = 1; t < arguments.length; t++){\n            var r = arguments[t];\n            for(var n in r)Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n        }\n        return e;\n    }, $d5f3a4ad9113e89a$var$J.apply(this, arguments);\n}\nvar $d5f3a4ad9113e89a$export$b35bd30dfac2a74b = function(e, t) {\n    try {\n        var r = e.boost;\n        t || (t = {});\n        var n = t.webln || globalThis.webln;\n        if (!n) throw new Error(\"WebLN not available\");\n        if (!n.keysend) throw new Error(\"Keysend not available in current WebLN provider\");\n        var o = e.amount || Math.floor(r.value_msat / 1e3), i = {\n            destination: e.destination,\n            amount: o,\n            customRecords: {\n                7629169: JSON.stringify(r)\n            }\n        };\n        return e.customKey && e.customValue && (i.customRecords[e.customKey] = e.customValue), Promise.resolve(n.enable()).then(function() {\n            return Promise.resolve(n.keysend(i));\n        });\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, $d5f3a4ad9113e89a$export$9437aa3703bd4b0c = /^((?:[^<>()[\\]\\\\.,;:\\s@\"]+(?:\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(?:\".+\"))@((?:\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(?:(?:[a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/, $d5f3a4ad9113e89a$export$29fc564f5fdb8b5d = \"https://api.getalby.com/lnurl\", $d5f3a4ad9113e89a$export$ebeb97171ba8142c = /*#__PURE__*/ function() {\n    function e(e, t) {\n        this.address = void 0, this.options = void 0, this.username = void 0, this.domain = void 0, this.pubkey = void 0, this.lnurlpData = void 0, this.keysendData = void 0, this.nostrData = void 0, this.nostrPubkey = void 0, this.nostrRelays = void 0, this.webln = void 0, this.address = e, this.options = {\n            proxy: \"https://api.getalby.com/lnurl\"\n        }, this.options = Object.assign(this.options, t), this.parse(), this.webln = this.options.webln;\n    }\n    var t = e.prototype;\n    return t.parse = function() {\n        var e = $d5f3a4ad9113e89a$export$9437aa3703bd4b0c.exec(this.address.toLowerCase());\n        e && (this.username = e[1], this.domain = e[2]);\n    }, t.getWebLN = function() {\n        return this.webln || globalThis.webln;\n    }, t.fetch = function() {\n        try {\n            var e = this;\n            return Promise.resolve(e.options.proxy ? e.fetchWithProxy() : e.fetchWithoutProxy());\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.fetchWithProxy = function() {\n        try {\n            var e = this;\n            return Promise.resolve(fetch(e.options.proxy + \"/lightning-address-details?\" + new URLSearchParams({\n                ln: e.address\n            }).toString())).then(function(t) {\n                if (!t.ok) throw new Error(\"Failed to fetch lnurl info: \" + t.status + \" \" + t.statusText);\n                return Promise.resolve(t.json()).then(function(t) {\n                    return Promise.resolve(e.parseLnUrlPayResponse(t.lnurlp)).then(function() {\n                        e.parseKeysendResponse(t.keysend), e.parseNostrResponse(t.nostr);\n                    });\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.fetchWithoutProxy = function() {\n        try {\n            var e = this;\n            return e.domain && e.username ? Promise.resolve(Promise.all([\n                e.fetchLnurlData(),\n                e.fetchKeysendData(),\n                e.fetchNostrData()\n            ])).then(function() {}) : Promise.resolve();\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.fetchLnurlData = function() {\n        try {\n            var e = this;\n            return Promise.resolve(fetch(e.lnurlpUrl())).then(function(t) {\n                var r = function() {\n                    if (t.ok) return Promise.resolve(t.json()).then(function(t) {\n                        return Promise.resolve(e.parseLnUrlPayResponse(t)).then(function() {});\n                    });\n                }();\n                if (r && r.then) return r.then(function() {});\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.fetchKeysendData = function() {\n        try {\n            var e = this;\n            return Promise.resolve(fetch(e.keysendUrl())).then(function(t) {\n                var r = function() {\n                    if (t.ok) return Promise.resolve(t.json()).then(function(t) {\n                        e.parseKeysendResponse(t);\n                    });\n                }();\n                if (r && r.then) return r.then(function() {});\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.fetchNostrData = function() {\n        try {\n            var e = this;\n            return Promise.resolve(fetch(e.nostrUrl())).then(function(t) {\n                var r = function() {\n                    if (t.ok) return Promise.resolve(t.json()).then(function(t) {\n                        e.parseNostrResponse(t);\n                    });\n                }();\n                if (r && r.then) return r.then(function() {});\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.lnurlpUrl = function() {\n        return \"https://\" + this.domain + \"/.well-known/lnurlp/\" + this.username;\n    }, t.keysendUrl = function() {\n        return \"https://\" + this.domain + \"/.well-known/keysend/\" + this.username;\n    }, t.nostrUrl = function() {\n        return \"https://\" + this.domain + \"/.well-known/nostr.json?name=\" + this.username;\n    }, t.generateInvoice = function(e) {\n        try {\n            var t, r = function(e) {\n                var r = t && t.pr && t.pr.toString();\n                if (!r) throw new Error(\"Invalid pay service invoice\");\n                var n = {\n                    pr: r\n                };\n                if (t && t.verify && (n.verify = t.verify.toString()), t && t.successAction && \"object\" == typeof t.successAction) {\n                    var o = t.successAction, i = o.tag, s = o.description, a = o.url;\n                    \"message\" === i ? n.successAction = {\n                        tag: i,\n                        message: o.message\n                    } : \"url\" === i && (n.successAction = {\n                        tag: i,\n                        description: s,\n                        url: a\n                    });\n                }\n                return new $d5f3a4ad9113e89a$export$ba5f874f962e090e(n);\n            }, n = this, o = function() {\n                if (n.options.proxy) return Promise.resolve(fetch(n.options.proxy + \"/generate-invoice?\" + new URLSearchParams($d5f3a4ad9113e89a$var$J({\n                    ln: n.address\n                }, e)).toString())).then(function(e) {\n                    if (!e.ok) throw new Error(\"Failed to generate invoice: \" + e.status + \" \" + e.statusText);\n                    return Promise.resolve(e.json()).then(function(e) {\n                        t = e.invoice;\n                    });\n                });\n                if (!n.lnurlpData) throw new Error(\"No lnurlpData available. Please call fetch() first.\");\n                if (!n.lnurlpData.callback || !$d5f3a4ad9113e89a$export$8304a22d431f958(n.lnurlpData.callback)) throw new Error(\"Valid callback does not exist in lnurlpData\");\n                var r = new URL(n.lnurlpData.callback);\n                return r.search = new URLSearchParams(e).toString(), Promise.resolve(fetch(r.toString())).then(function(e) {\n                    if (!e.ok) throw new Error(\"Failed to generate invoice: \" + e.status + \" \" + e.statusText);\n                    return Promise.resolve(e.json()).then(function(e) {\n                        t = e;\n                    });\n                });\n            }();\n            return Promise.resolve(o && o.then ? o.then(r) : r());\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.requestInvoice = function(e) {\n        try {\n            var t = this;\n            if (!t.lnurlpData) throw new Error(\"No lnurlpData available. Please call fetch() first.\");\n            var r = 1e3 * e.satoshi, n = t.lnurlpData, o = n.commentAllowed;\n            if (!$d5f3a4ad9113e89a$export$3c93f2a0ff50284a({\n                amount: r,\n                min: n.min,\n                max: n.max\n            })) throw new Error(\"Invalid amount\");\n            if (e.comment && o && o > 0 && e.comment.length > o) throw new Error(\"The comment length must be \" + o + \" characters or fewer\");\n            var i = {\n                amount: r.toString()\n            };\n            return e.comment && (i.comment = e.comment), e.payerdata && (i.payerdata = JSON.stringify(e.payerdata)), Promise.resolve(t.generateInvoice(i));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.boost = function(e, t) {\n        void 0 === t && (t = 0);\n        try {\n            var r = this;\n            if (!r.keysendData) throw new Error(\"No keysendData available. Please call fetch() first.\");\n            var n = r.keysendData, o = n.destination, i = n.customKey, s = n.customValue, a = r.getWebLN();\n            if (!a) throw new Error(\"WebLN not available\");\n            return Promise.resolve($d5f3a4ad9113e89a$export$b35bd30dfac2a74b({\n                destination: o,\n                customKey: i,\n                customValue: s,\n                amount: t,\n                boost: e\n            }, {\n                webln: a\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.zapInvoice = function(e, t) {\n        var r = e.satoshi, n = e.comment, o = e.relays, i = e.e;\n        void 0 === t && (t = {});\n        try {\n            var s = this;\n            if (!s.lnurlpData) throw new Error(\"No lnurlpData available. Please call fetch() first.\");\n            if (!s.nostrPubkey) throw new Error(\"Nostr Pubkey is missing\");\n            var a = s.nostrPubkey, c = 1e3 * r, u = s.lnurlpData, h = u.allowsNostr;\n            if (!$d5f3a4ad9113e89a$export$3c93f2a0ff50284a({\n                amount: c,\n                min: u.min,\n                max: u.max\n            })) throw new Error(\"Invalid amount\");\n            if (!h) throw new Error(\"Your provider does not support zaps\");\n            return Promise.resolve($d5f3a4ad9113e89a$export$1890c02602d63c({\n                satoshi: c,\n                comment: n,\n                p: a,\n                e: i,\n                relays: o\n            }, t)).then(function(e) {\n                var t = {\n                    amount: c.toString(),\n                    nostr: JSON.stringify(e)\n                };\n                return Promise.resolve(s.generateInvoice(t));\n            });\n        } catch (i) {\n            return Promise.reject(i);\n        }\n    }, t.zap = function(e, t) {\n        void 0 === t && (t = {});\n        try {\n            var r = this.zapInvoice(e, t), n = this.getWebLN();\n            if (!n) throw new Error(\"WebLN not available\");\n            return Promise.resolve(n.enable()).then(function() {\n                var e = n.sendPayment;\n                return Promise.resolve(r).then(function(t) {\n                    return e.call(n, t.paymentRequest);\n                });\n            });\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.parseLnUrlPayResponse = function(e) {\n        try {\n            var t = this, r = function() {\n                if (e) return Promise.resolve($d5f3a4ad9113e89a$export$178fe3191ba1e804(e)).then(function(e) {\n                    t.lnurlpData = e;\n                });\n            }();\n            return Promise.resolve(r && r.then ? r.then(function() {}) : void 0);\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }, t.parseKeysendResponse = function(e) {\n        e && (this.keysendData = $d5f3a4ad9113e89a$export$3e6ee22e431c91ae(e));\n    }, t.parseNostrResponse = function(e) {\n        if (e) {\n            var t = $d5f3a4ad9113e89a$export$fe45bd6b19e4f4ba(e, this.username);\n            this.nostrData = t[0], this.nostrPubkey = t[1], this.nostrRelays = t[2];\n        }\n    }, e;\n}(), $d5f3a4ad9113e89a$export$d7392285c701ecf5 = /*#__PURE__*/ function() {\n    function e(e) {\n        this.storage = void 0, this.storage = e || {};\n    }\n    var t = e.prototype;\n    return t.getItem = function(e) {\n        return this.storage[e];\n    }, t.setItem = function(e, t) {\n        this.storage[e] = t;\n    }, e;\n}(), $d5f3a4ad9113e89a$export$14737ae4d60f83b9 = /*#__PURE__*/ function() {\n    function e(e) {}\n    var t = e.prototype;\n    return t.getItem = function(e) {\n        return null;\n    }, t.setItem = function(e, t) {}, e;\n}(), $d5f3a4ad9113e89a$export$cc852eaafd7b5a62 = function(e) {\n    for(var t, r = e.replace(\"L402\", \"\").replace(\"LSAT\", \"\").trim(), n = {}, o = /(\\w+)=(\"([^\"]*)\"|'([^']*)'|([^,]*))/g; null !== (t = o.exec(r));)n[t[1]] = t[3] || t[4] || t[5];\n    return n;\n}, $d5f3a4ad9113e89a$var$ne = new $d5f3a4ad9113e89a$export$d7392285c701ecf5, $d5f3a4ad9113e89a$export$f7bad6ce3af02f7c = function(e, t, r) {\n    try {\n        var n, o = function(r) {\n            return n ? r : (t.headers[\"Accept-Authenticate\"] = i, Promise.resolve(fetch(e, t)).then(function(r) {\n                var n = r.headers.get(\"www-authenticate\");\n                if (!n) return r;\n                var o = $d5f3a4ad9113e89a$export$cc852eaafd7b5a62(n), c = o.token || o.macaroon, u = o.invoice;\n                return Promise.resolve(s.enable()).then(function() {\n                    return Promise.resolve(s.sendPayment(u)).then(function(r) {\n                        return a.setItem(e, JSON.stringify({\n                            token: c,\n                            preimage: r.preimage\n                        })), t.headers.Authorization = i + \" \" + c + \":\" + r.preimage, Promise.resolve(fetch(e, t));\n                    });\n                });\n            }));\n        };\n        r || (r = {});\n        var i = r.headerKey || \"L402\", s = r.webln || globalThis.webln;\n        if (!s) throw new Error(\"WebLN is missing\");\n        var a = r.store || $d5f3a4ad9113e89a$var$ne;\n        t || (t = {}), t.cache = \"no-store\", t.mode = \"cors\", t.headers || (t.headers = {});\n        var c = a.getItem(e), u = function() {\n            if (c) {\n                var r = JSON.parse(c);\n                return t.headers.Authorization = i + \" \" + r.token + \":\" + r.preimage, Promise.resolve(fetch(e, t)).then(function(e) {\n                    return n = 1, e;\n                });\n            }\n        }();\n        return Promise.resolve(u && u.then ? u.then(o) : o(u));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, $d5f3a4ad9113e89a$export$c1a7a44af0d8825b = {\n    __proto__: null,\n    fetchWithL402: $d5f3a4ad9113e89a$export$f7bad6ce3af02f7c,\n    MemoryStorage: $d5f3a4ad9113e89a$export$d7392285c701ecf5,\n    NoStorage: $d5f3a4ad9113e89a$export$14737ae4d60f83b9,\n    parseL402: $d5f3a4ad9113e89a$export$cc852eaafd7b5a62\n}, $d5f3a4ad9113e89a$export$dfa27062c7281cab = function(e) {\n    try {\n        var t = \"https://getalby.com/api/rates/\" + e.toLowerCase() + \".json\";\n        return Promise.resolve(fetch(t)).then(function(e) {\n            if (!e.ok) throw new Error(\"Failed to fetch rate: \" + e.status + \" \" + e.statusText);\n            return Promise.resolve(e.json()).then(function(e) {\n                return e.rate_float / 1e8;\n            });\n        });\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}, $d5f3a4ad9113e89a$export$cbdbadc5090a1f57 = function(e) {\n    var t = e.satoshi;\n    return Promise.resolve($d5f3a4ad9113e89a$export$dfa27062c7281cab(e.currency)).then(function(e) {\n        return Number(t) * e;\n    });\n}, $d5f3a4ad9113e89a$export$2aeac1888f394001 = function(e) {\n    var t = e.amount;\n    return Promise.resolve($d5f3a4ad9113e89a$export$dfa27062c7281cab(e.currency)).then(function(e) {\n        return Math.floor(Number(t) / e);\n    });\n}, $d5f3a4ad9113e89a$export$60fb9846ff371075 = function(e) {\n    var t = e.currency, r = e.locale;\n    return r || (r = \"en\"), Promise.resolve($d5f3a4ad9113e89a$export$cbdbadc5090a1f57({\n        satoshi: e.satoshi,\n        currency: t\n    })).then(function(e) {\n        return e.toLocaleString(r, {\n            style: \"currency\",\n            currency: t\n        });\n    });\n}, $d5f3a4ad9113e89a$export$c32e8ef196152e59 = {\n    __proto__: null,\n    getFiatBtcRate: $d5f3a4ad9113e89a$export$dfa27062c7281cab,\n    getFiatValue: $d5f3a4ad9113e89a$export$cbdbadc5090a1f57,\n    getSatoshiValue: $d5f3a4ad9113e89a$export$2aeac1888f394001,\n    getFormattedFiatValue: $d5f3a4ad9113e89a$export$60fb9846ff371075\n};\n\n});\n\n\nparcelRequire(\"9BsJg\");\n\nvar $9BsJg = parcelRequire(\"9BsJg\");\nclass $a77da6ceca5d66da$export$d9a919bae0329c9a {\n    constructor(){\n        this.wallets = {\n            1: {\n                isConnected: false,\n                nwcClient: null,\n                connectionData: null,\n                transactionsSupported: null\n            },\n            2: {\n                isConnected: false,\n                nwcClient: null,\n                connectionData: null,\n                transactionsSupported: null\n            }\n        };\n    }\n    // Local Storage Functions\n    saveNWCString(walletId, nwcUrl) {\n        localStorage.setItem(`nwc-wallet-${walletId}`, nwcUrl);\n        this.log(`Wallet ${walletId}: NWC string saved`);\n    }\n    loadNWCString(walletId) {\n        return localStorage.getItem(`nwc-wallet-${walletId}`) || '';\n    }\n    clearNWCString(walletId) {\n        localStorage.removeItem(`nwc-wallet-${walletId}`);\n        this.log(`Wallet ${walletId}: Saved NWC string deleted`);\n    }\n    log(message) {\n        const logElement = document.getElementById('debug-log');\n        const timestamp = new Date().toLocaleTimeString();\n        logElement.textContent += `[${timestamp}] ${message}\\n`;\n        logElement.scrollTop = logElement.scrollHeight;\n    }\n    updateConnectionStatus(walletId, status, message) {\n        const statusElement = document.getElementById(`connection-status-${walletId}`);\n        const badgeClass = status === 'connected' ? 'bg-success' : status === 'connecting' ? 'bg-warning' : 'bg-secondary';\n        statusElement.className = `badge ${badgeClass} status-badge`;\n        statusElement.textContent = message;\n    }\n    toggleConnectionVisibility(walletId) {\n        const textarea = document.getElementById(`nwc-url-${walletId}`);\n        const toggleBtn = document.getElementById(`toggle-visibility-${walletId}`);\n        const isHidden = textarea.style.webkitTextSecurity === 'disc';\n        if (isHidden) {\n            // Show text\n            textarea.style.webkitTextSecurity = 'none';\n            toggleBtn.textContent = \"\\uD83D\\uDE48\";\n            toggleBtn.title = 'Connection String verstecken';\n        } else {\n            // Hide text\n            textarea.style.webkitTextSecurity = 'disc';\n            toggleBtn.textContent = \"\\uD83D\\uDC41\\uFE0F\";\n            toggleBtn.title = 'Connection String anzeigen';\n        }\n    }\n    async connectWallet(walletId) {\n        const nwcUrl = document.getElementById(`nwc-url-${walletId}`).value;\n        if (!nwcUrl) {\n            alert('Please enter a valid NWC connection string');\n            return;\n        }\n        if (!nwcUrl.startsWith('nostr+walletconnect://')) {\n            alert('Invalid NWC connection string. Must start with \"nostr+walletconnect://\"');\n            return;\n        }\n        this.log(`Wallet ${walletId}: Attempting to connect real wallet...`);\n        this.updateConnectionStatus(walletId, 'connecting', 'Connecting...');\n        try {\n            // Create new NWC client with credentials\n            this.wallets[walletId].nwcClient = new (0, $9BsJg.nwc).NWCClient({\n                nostrWalletConnectUrl: nwcUrl\n            });\n            // Test connection by getting wallet info\n            const info = await this.wallets[walletId].nwcClient.getInfo();\n            this.wallets[walletId].isConnected = true;\n            this.wallets[walletId].connectionData = {\n                url: nwcUrl\n            };\n            this.updateConnectionStatus(walletId, 'connected', 'Connected');\n            // Disable connection form when connected\n            document.getElementById(`nwc-url-${walletId}`).disabled = true;\n            document.getElementById(`toggle-visibility-${walletId}`).disabled = true;\n            document.getElementById(`connect-btn-${walletId}`).disabled = true;\n            document.getElementById(`disconnect-btn-${walletId}`).disabled = false;\n            // Auto-save connection string\n            this.saveNWCString(walletId, nwcUrl);\n            this.log(`Wallet ${walletId}: Successfully connected!`);\n            this.log(`Wallet ${walletId}: Alias: ${info.alias || 'N/A'}`);\n            this.log(`Wallet ${walletId}: Pubkey: ${info.pubkey ? info.pubkey.substring(0, 20) + '...' : 'N/A'}`);\n            this.log(`Wallet ${walletId}: Methods: ${info.methods ? info.methods.join(', ') : 'N/A'}`);\n            // Display initial wallet info\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(info, null, 2);\n            // Trigger stabilization UI update\n            window.dispatchEvent(new CustomEvent('walletConnectionChanged'));\n        } catch (error) {\n            this.updateConnectionStatus(walletId, 'disconnected', 'Connection failed');\n            this.log(`Wallet ${walletId}: Error connecting: ${error.message}`);\n            console.error(`Wallet ${walletId} NWC Connection Error:`, error);\n        }\n    }\n    disconnectWallet(walletId) {\n        this.log(`Wallet ${walletId}: Disconnecting...`);\n        this.wallets[walletId].isConnected = false;\n        this.wallets[walletId].nwcClient = null;\n        this.wallets[walletId].connectionData = null;\n        this.wallets[walletId].transactionsSupported = null;\n        this.updateConnectionStatus(walletId, 'disconnected', 'Not connected');\n        // Re-enable connection form when disconnected\n        document.getElementById(`nwc-url-${walletId}`).disabled = false;\n        document.getElementById(`toggle-visibility-${walletId}`).disabled = false;\n        document.getElementById(`connect-btn-${walletId}`).disabled = false;\n        document.getElementById(`disconnect-btn-${walletId}`).disabled = true;\n        document.getElementById(`wallet-info-${walletId}`).textContent = '';\n        document.getElementById(`payment-result-${walletId}`).textContent = '';\n        this.log(`Wallet ${walletId}: Successfully disconnected`);\n        // Trigger stabilization UI update\n        window.dispatchEvent(new CustomEvent('walletConnectionChanged'));\n    }\n    async getWalletInfo(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        try {\n            this.log(`Wallet ${walletId}: get_info request sent...`);\n            const info = await this.wallets[walletId].nwcClient.getInfo();\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(info, null, 2);\n            this.log(`Wallet ${walletId}: get_info response received`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error in get_info: ${error.message}`);\n            document.getElementById(`wallet-info-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n    async getBalance(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        try {\n            this.log(`Wallet ${walletId}: get_balance request sent...`);\n            const balance = await this.wallets[walletId].nwcClient.getBalance();\n            // Convert balance display to show correct sats\n            const displayBalance = {\n                ...balance,\n                balance_sats: Math.round(balance.balance / 1000),\n                balance_millisats: balance.balance\n            };\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(displayBalance, null, 2);\n            this.log(`Wallet ${walletId}: Balance: ${Math.round(balance.balance / 1000)} sats (${balance.balance} millisats)`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error in get_balance: ${error.message}`);\n            document.getElementById(`wallet-info-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n    async createInvoice(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        const amount = prompt('Enter amount in Satoshis:', '1000');\n        if (!amount) return;\n        const description = prompt('Description (optional):', `NWC Demo Invoice - Wallet ${walletId}`);\n        try {\n            this.log(`Wallet ${walletId}: make_invoice request for ${amount} sats...`);\n            const invoice = await this.wallets[walletId].nwcClient.makeInvoice({\n                amount: parseInt(amount) * 1000,\n                description: description || `NWC Demo Invoice - Wallet ${walletId}`\n            });\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(invoice, null, 2);\n            this.log(`Wallet ${walletId}: Invoice created successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error creating invoice: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n    async payInvoice(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        const invoice = prompt('Enter Lightning Invoice:', 'lnbc...');\n        if (!invoice) return;\n        try {\n            this.log(`Wallet ${walletId}: pay_invoice request sent...`);\n            const result = await this.wallets[walletId].nwcClient.payInvoice({\n                invoice: invoice\n            });\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(result, null, 2);\n            this.log(`Wallet ${walletId}: Payment sent successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error paying invoice: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n    async listTransactions(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        try {\n            this.log(`Wallet ${walletId}: list_transactions request sent...`);\n            const transactions = await this.wallets[walletId].nwcClient.listTransactions({\n                from: 0,\n                until: Math.floor(Date.now() / 1000),\n                limit: 50,\n                offset: 0,\n                unpaid: false,\n                type: undefined\n            });\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(transactions, null, 2);\n            this.log(`Wallet ${walletId}: ${transactions.transactions ? transactions.transactions.length : 0} transactions retrieved`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error retrieving transactions: ${error.message}`);\n            console.error(`Wallet ${walletId} listTransactions error:`, error);\n            // Fallback: Try without parameters\n            try {\n                this.log(`Wallet ${walletId}: Trying listTransactions without parameters...`);\n                const transactions = await this.wallets[walletId].nwcClient.listTransactions({});\n                document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(transactions, null, 2);\n                this.log(`Wallet ${walletId}: Transactions retrieved with fallback method`);\n            } catch (fallbackError) {\n                this.log(`Wallet ${walletId}: Fallback also failed: ${fallbackError.message}`);\n                document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}\\nFallback Error: ${fallbackError.message}`;\n            }\n        }\n    }\n    async payKeysend(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n        const pubkey = prompt('Recipient Pubkey:', '02...');\n        const amount = prompt('Amount in Satoshis:', '1000');\n        if (!pubkey || !amount) return;\n        try {\n            this.log(`Wallet ${walletId}: pay_keysend request for ${amount} sats to ${pubkey.substring(0, 10)}...`);\n            const result = await this.wallets[walletId].nwcClient.payKeysend({\n                pubkey: pubkey,\n                amount: parseInt(amount) * 1000 // Convert to millisats\n            });\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(result, null, 2);\n            this.log(`Wallet ${walletId}: Keysend payment sent successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error sending keysend: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n    saveConnectionString(walletId) {\n        const nwcUrl = document.getElementById(`nwc-url-${walletId}`).value;\n        if (!nwcUrl) {\n            alert('No connection string to save');\n            return;\n        }\n        this.saveNWCString(walletId, nwcUrl);\n    }\n    clearConnectionString(walletId) {\n        this.clearNWCString(walletId);\n        document.getElementById(`nwc-url-${walletId}`).value = '';\n    }\n    loadSavedConnectionStrings() {\n        // Load saved connection strings for both wallets\n        for(let walletId = 1; walletId <= 2; walletId++){\n            const savedUrl = this.loadNWCString(walletId);\n            if (savedUrl) {\n                const textarea = document.getElementById(`nwc-url-${walletId}`);\n                textarea.value = savedUrl;\n                // Ensure the text is properly masked\n                textarea.style.webkitTextSecurity = 'disc';\n                this.log(`Wallet ${walletId}: Saved NWC string loaded`);\n            }\n        }\n    }\n    clearLog() {\n        document.getElementById('debug-log').textContent = 'Debug messages will be displayed here...\\n';\n    }\n}\n\n\n// Bitcoin Price Management Module\nclass $6a2e34ea2fddba81$export$1a7dcbc42b6f58b1 {\n    constructor(){\n        this.priceUpdateInterval = null;\n        this.priceChart = null;\n        this.PRICE_STORAGE_KEY = 'nwc-price-history';\n        this.MAX_PRICE_HISTORY = 10000; // Keep last 10,000 price points\n        this.PRICE_CHANGE_THRESHOLD = 0.5; // Minimum 0.5% price change to store point\n    }\n    // Price Storage Functions\n    savePriceHistory(priceData) {\n        try {\n            const history = this.getPriceHistory();\n            const timestamp = Date.now();\n            // Check if we should save this point\n            if (history.length > 0) {\n                const lastPoint = history[history.length - 1];\n                const timeDiff = timestamp - lastPoint.timestamp;\n                // Minimum interval: 1 hour (to match historical data pattern)\n                const minInterval = 3600000; // 1 hour in milliseconds\n                // Check for significant price change\n                const shouldSave = Object.keys(priceData).some((currency)=>{\n                    const oldPrice = lastPoint.prices[currency];\n                    const newPrice = priceData[currency];\n                    const changePercent = Math.abs((newPrice - oldPrice) / oldPrice * 100);\n                    return changePercent >= this.PRICE_CHANGE_THRESHOLD;\n                });\n                // Only save if significant change or enough time has passed\n                const hoursPassed = timeDiff / 3600000;\n                if (hoursPassed < 1) {\n                    // Too soon, just update timestamp of last point\n                    lastPoint.timestamp = timestamp;\n                    localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n                    return;\n                } else if (hoursPassed < 2 && !shouldSave) {\n                    // Between 1-2 hours but no significant change, skip\n                    lastPoint.timestamp = timestamp;\n                    localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n                    return;\n                }\n            }\n            // Add new price point\n            history.push({\n                timestamp: timestamp,\n                prices: {\n                    ...priceData\n                }\n            });\n            // Keep only last MAX_PRICE_HISTORY points\n            if (history.length > this.MAX_PRICE_HISTORY) history.splice(0, history.length - this.MAX_PRICE_HISTORY);\n            localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n            console.log(`\\u{1F4BE} Neuer Preispunkt gespeichert (${history.length} total)`);\n        } catch (error) {\n            console.error('Error saving price history:', error);\n        }\n    }\n    getPriceHistory() {\n        try {\n            const stored = localStorage.getItem(this.PRICE_STORAGE_KEY);\n            return stored ? JSON.parse(stored) : [];\n        } catch (error) {\n            console.error('Error loading price history:', error);\n            return [];\n        }\n    }\n    getFilteredPriceHistory(timeRange) {\n        const history = this.getPriceHistory();\n        if (history.length === 0) return [];\n        const now = Date.now();\n        let timeWindow;\n        switch(timeRange){\n            case '12h':\n                timeWindow = 43200000; // 12 hours\n                break;\n            case '24h':\n                timeWindow = 86400000; // 24 hours\n                break;\n            case '2d':\n                timeWindow = 172800000; // 2 days\n                break;\n            case '4d':\n                timeWindow = 345600000; // 4 days\n                break;\n            case '7d':\n                timeWindow = 604800000; // 7 days\n                break;\n            default:\n                timeWindow = 43200000; // Default to 12 hours\n        }\n        const cutoffTime = now - timeWindow;\n        return history.filter((point)=>point.timestamp >= cutoffTime);\n    }\n    clearPriceHistory() {\n        localStorage.removeItem(this.PRICE_STORAGE_KEY);\n        this.log('Price history cleared');\n    }\n    async clearAndReloadPriceData() {\n        try {\n            this.log(\"\\uD83D\\uDDD1\\uFE0F Clearing all price data...\");\n            // Clear existing price history\n            localStorage.removeItem(this.PRICE_STORAGE_KEY);\n            // Clear chart\n            if (this.priceChart) {\n                this.priceChart.data.labels = [];\n                this.priceChart.data.datasets.forEach((dataset)=>{\n                    dataset.data = [];\n                });\n                this.priceChart.update();\n            }\n            this.log(\"\\u2705 Price data cleared\");\n            // Reload fresh historical data\n            await this.fetchHistoricalPrices();\n            this.log(\"\\u2705 Fresh price data loaded\");\n        } catch (error) {\n            this.log(`\\u{274C} Error reloading price data: ${error.message}`);\n            console.error('Error clearing and reloading price data:', error);\n        }\n    }\n    log(message) {\n        const logElement = document.getElementById('debug-log');\n        if (logElement) {\n            const timestamp = new Date().toLocaleTimeString();\n            logElement.textContent += `[${timestamp}] ${message}\\n`;\n            logElement.scrollTop = logElement.scrollHeight;\n        }\n    }\n    // Historical Price Functions\n    async fetchHistoricalPrices() {\n        try {\n            this.log(\"\\uD83D\\uDCC8 Loading real historical prices from mempool.space...\");\n            const response = await fetch('https://mempool.space/api/v1/historical-price');\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            const data = await response.json();\n            this.log(`\\u{1F4C8} ${data.prices.length} historical data points received from API`);\n            // Convert mempool.space data to our format\n            const convertedHistory = data.prices.map((item)=>({\n                    timestamp: item.time * 1000,\n                    prices: {\n                        USD: item.USD,\n                        EUR: item.EUR,\n                        GBP: item.GBP,\n                        CHF: item.CHF,\n                        CAD: item.CAD,\n                        JPY: item.JPY,\n                        AUD: item.AUD // Also include AUD if we want to expand later\n                    }\n                }));\n            // Sort by timestamp (oldest first) and limit to our storage limit\n            const sortedHistory = convertedHistory.sort((a, b)=>a.timestamp - b.timestamp).slice(-this.MAX_PRICE_HISTORY);\n            // Save to localStorage\n            localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(sortedHistory));\n            this.log(`\\u{1F4C8} ${sortedHistory.length} real historical price points saved`);\n            // Update chart if it exists\n            if (this.priceChart) this.updatePriceChart();\n        } catch (error) {\n            this.log(`\\u{1F4C8} Error loading historical prices: ${error.message}`);\n            console.error('Historical price fetch error:', error);\n            // Fallback: Log that we're using existing data\n            const existingHistory = this.getPriceHistory();\n            if (existingHistory.length > 0) this.log(`\\u{1F4C8} Using ${existingHistory.length} existing price points`);\n            else this.log(\"\\uD83D\\uDCC8 No historical data available\");\n        }\n    }\n    // Bitcoin Price Functions\n    async fetchBitcoinPrice() {\n        try {\n            this.log('Fetching Bitcoin price...');\n            const response = await fetch('https://mempool.space/api/v1/prices');\n            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n            const priceData = await response.json();\n            // Update price displays\n            this.updatePriceDisplay(priceData);\n            // Update live price in chart\n            this.updateLivePriceInChart(priceData);\n            this.log('Bitcoin price updated successfully');\n        } catch (error) {\n            this.log(`Error fetching Bitcoin price: ${error.message}`);\n            console.error('Bitcoin price fetch error:', error);\n            // Update displays with error\n            const currencies = [\n                'usd',\n                'eur',\n                'gbp',\n                'chf',\n                'cad',\n                'jpy'\n            ];\n            currencies.forEach((currency)=>{\n                const priceEl = document.getElementById(`price-${currency}`);\n                const satsEl = document.getElementById(`sats-${currency}`);\n                if (priceEl) priceEl.textContent = 'Error';\n                if (satsEl) satsEl.textContent = 'Error';\n            });\n            const updatedEl = document.getElementById('price-updated');\n            if (updatedEl) updatedEl.textContent = 'Last Update: Error';\n        }\n    }\n    updateLivePriceInChart(priceData) {\n        if (!this.priceChart) return;\n        const now = Date.now();\n        const selectedRange = document.querySelector('input[name=\"timeRange\"]:checked')?.value || '12h';\n        // Get current history\n        const history = this.getPriceHistory();\n        // Create current price point\n        const currentPricePoint = {\n            timestamp: now,\n            prices: {\n                USD: priceData.USD,\n                EUR: priceData.EUR,\n                GBP: priceData.GBP,\n                CHF: priceData.CHF,\n                CAD: priceData.CAD,\n                JPY: priceData.JPY\n            }\n        };\n        // Create temporary history with current price\n        const liveHistory = [\n            ...history,\n            currentPricePoint\n        ];\n        // Filter for selected time range\n        const filteredHistory = this.filterHistoryByRange(liveHistory, selectedRange);\n        if (filteredHistory.length === 0) return;\n        // Update chart with live data\n        const labels = filteredHistory.map((item)=>item.timestamp);\n        const currencies = [\n            'USD',\n            'EUR',\n            'GBP',\n            'CHF',\n            'CAD',\n            'JPY'\n        ];\n        this.priceChart.data.labels = labels;\n        currencies.forEach((currency, index)=>{\n            const dataPoints = filteredHistory.map((item)=>({\n                    x: item.timestamp,\n                    y: item.prices[currency]\n                }));\n            this.priceChart.data.datasets[index].data = dataPoints;\n        });\n        // Update chart with no animation for smooth live updates\n        this.priceChart.update('none');\n        // Save to persistent history only according to our rules\n        this.savePriceHistory(priceData);\n    }\n    filterHistoryByRange(history, timeRange) {\n        if (history.length === 0) return [];\n        const now = Date.now();\n        let timeWindow;\n        switch(timeRange){\n            case '12h':\n                timeWindow = 43200000;\n                break;\n            case '24h':\n                timeWindow = 86400000;\n                break;\n            case '2d':\n                timeWindow = 172800000;\n                break;\n            case '4d':\n                timeWindow = 345600000;\n                break;\n            case '7d':\n                timeWindow = 604800000;\n                break;\n            default:\n                timeWindow = 43200000;\n        }\n        const cutoffTime = now - timeWindow;\n        return history.filter((point)=>point.timestamp >= cutoffTime);\n    }\n    updatePriceDisplay(priceData) {\n        // Format and display prices\n        const currencies = {\n            usd: {\n                symbol: '$',\n                value: priceData.USD,\n                unit: '$1'\n            },\n            eur: {\n                symbol: \"\\u20AC\",\n                value: priceData.EUR,\n                unit: \"\\u20AC1\"\n            },\n            gbp: {\n                symbol: \"\\xa3\",\n                value: priceData.GBP,\n                unit: \"\\xa31\"\n            },\n            chf: {\n                symbol: \"\\u20A3\",\n                value: priceData.CHF,\n                unit: \"\\u20A31\"\n            },\n            cad: {\n                symbol: 'C$',\n                value: priceData.CAD,\n                unit: 'C$1'\n            },\n            jpy: {\n                symbol: \"\\xa5\",\n                value: priceData.JPY,\n                unit: \"\\xa51\"\n            }\n        };\n        Object.entries(currencies).forEach(([currency, data])=>{\n            const priceElement = document.getElementById(`price-${currency}`);\n            const satsElement = document.getElementById(`sats-${currency}`);\n            if (priceElement && satsElement && data.value) {\n                // Format Bitcoin price\n                const formattedValue = currency === 'jpy' ? Math.round(data.value).toLocaleString() : data.value.toLocaleString('de-DE', {\n                    minimumFractionDigits: 0,\n                    maximumFractionDigits: 0\n                });\n                priceElement.textContent = `${data.symbol} ${formattedValue}`;\n                // Calculate satoshis for 1 unit of currency\n                const satoshisPerUnit = Math.round(100000000 / data.value);\n                const formattedSats = satoshisPerUnit.toLocaleString('de-DE');\n                satsElement.textContent = `${formattedSats} sats = ${data.unit}`;\n            }\n        });\n        // Update timestamp\n        const now = new Date();\n        const timeString = now.toLocaleTimeString('en-US');\n        const updatedEl = document.getElementById('price-updated');\n        if (updatedEl) updatedEl.textContent = `Last Update: ${timeString}`;\n    }\n    startPriceUpdates() {\n        // Clear existing interval\n        if (this.priceUpdateInterval) clearInterval(this.priceUpdateInterval);\n        // Fetch price immediately\n        this.fetchBitcoinPrice();\n        // Set up auto-refresh every 30 seconds\n        this.priceUpdateInterval = setInterval(()=>this.fetchBitcoinPrice(), 30000);\n        this.log('Bitcoin price auto-update started (every 30 seconds)');\n    }\n    stopPriceUpdates() {\n        if (this.priceUpdateInterval) {\n            clearInterval(this.priceUpdateInterval);\n            this.priceUpdateInterval = null;\n            this.log('Bitcoin price auto-update stopped');\n        }\n    }\n    // Chart Functions\n    initializePriceChart() {\n        const ctx = document.getElementById('priceChart')?.getContext('2d');\n        if (!ctx) return;\n        this.priceChart = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: [],\n                datasets: [\n                    {\n                        label: 'USD ($)',\n                        data: [],\n                        borderColor: '#0066cc',\n                        backgroundColor: 'rgba(0, 102, 204, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: \"EUR (\\u20AC)\",\n                        data: [],\n                        borderColor: '#dc3545',\n                        backgroundColor: 'rgba(220, 53, 69, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: \"GBP (\\xa3)\",\n                        data: [],\n                        borderColor: '#28a745',\n                        backgroundColor: 'rgba(40, 167, 69, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'CHF',\n                        data: [],\n                        borderColor: '#ffc107',\n                        backgroundColor: 'rgba(255, 193, 7, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'CAD',\n                        data: [],\n                        borderColor: '#6f42c1',\n                        backgroundColor: 'rgba(111, 66, 193, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: \"JPY (\\xa5)\",\n                        data: [],\n                        borderColor: '#fd7e14',\n                        backgroundColor: 'rgba(253, 126, 20, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y1'\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    mode: 'index',\n                    intersect: false\n                },\n                plugins: {\n                    legend: {\n                        display: true,\n                        position: 'top',\n                        onClick: function(e, legendItem, legend) {\n                            const index = legendItem.datasetIndex;\n                            const chart = legend.chart;\n                            const isVisible = chart.isDatasetVisible(index);\n                            chart.setDatasetVisibility(index, !isVisible);\n                            chart.update('none');\n                        }\n                    },\n                    tooltip: {\n                        mode: 'index',\n                        intersect: false,\n                        callbacks: {\n                            title: function(context) {\n                                return 'Bitcoin Preis';\n                            },\n                            label: function(context) {\n                                const currency = context.dataset.label;\n                                const value = context.parsed.y;\n                                return `${currency}: ${value.toLocaleString('de-DE')}`;\n                            }\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        type: 'linear',\n                        position: 'bottom',\n                        min: function(context) {\n                            const data = context.chart.data.labels;\n                            return data.length > 0 ? Math.min(...data) : 0;\n                        },\n                        max: function(context) {\n                            const data = context.chart.data.labels;\n                            return data.length > 0 ? Math.max(...data) : 0;\n                        },\n                        grid: {\n                            color: 'rgba(0, 0, 0, 0.1)'\n                        },\n                        ticks: {\n                            callback: function(value) {\n                                const date = new Date(value);\n                                return date.toLocaleTimeString('de-DE', {\n                                    hour: '2-digit',\n                                    minute: '2-digit'\n                                });\n                            },\n                            maxTicksLimit: 8\n                        }\n                    },\n                    y: {\n                        type: 'linear',\n                        display: true,\n                        position: 'left',\n                        beginAtZero: false,\n                        title: {\n                            display: true,\n                            text: 'USD/EUR/GBP/CHF/CAD'\n                        },\n                        grid: {\n                            color: 'rgba(0, 0, 0, 0.1)'\n                        }\n                    },\n                    y1: {\n                        type: 'linear',\n                        display: true,\n                        position: 'right',\n                        beginAtZero: false,\n                        title: {\n                            display: true,\n                            text: \"JPY (\\xa5)\"\n                        },\n                        grid: {\n                            drawOnChartArea: false\n                        }\n                    }\n                }\n            }\n        });\n        // Update chart initially\n        this.updatePriceChart();\n    }\n    updatePriceChart() {\n        if (!this.priceChart) return;\n        // Get selected time range\n        const selectedRange = document.querySelector('input[name=\"timeRange\"]:checked')?.value || '12h';\n        const history = this.getFilteredPriceHistory(selectedRange);\n        if (history.length === 0) {\n            this.priceChart.data.labels = [];\n            this.priceChart.data.datasets.forEach((dataset)=>{\n                dataset.data = [];\n            });\n            this.priceChart.update();\n            return;\n        }\n        // Prepare data for chart\n        const labels = history.map((item)=>item.timestamp);\n        const currencies = [\n            'USD',\n            'EUR',\n            'GBP',\n            'CHF',\n            'CAD',\n            'JPY'\n        ];\n        // Update chart data\n        this.priceChart.data.labels = labels;\n        currencies.forEach((currency, index)=>{\n            const dataPoints = history.map((item)=>({\n                    x: item.timestamp,\n                    y: item.prices[currency]\n                }));\n            this.priceChart.data.datasets[index].data = dataPoints;\n        });\n        // Update chart\n        this.priceChart.update('none'); // No animation for smoother updates\n    }\n}\n\n\n// Balance Stabilization Manager Module\nclass $d0c67cc6a727cdb2$export$3d022597fb56d1f4 {\n    constructor(walletManager){\n        this.walletManager = walletManager;\n        this.stabilizationData = {\n            active: false,\n            currency: null,\n            initialBalance: 0,\n            targetValue: 0,\n            initialPrice: 0,\n            checkInterval: null,\n            threshold: 1,\n            lastRebalanceTime: 0,\n            rebalanceMinInterval: 5000,\n            errorCount: 0,\n            maxErrors: 5\n        };\n    }\n    log(message) {\n        this.walletManager.log(message);\n    }\n    async startStabilization() {\n        const currency = document.getElementById('stabilization-currency').value;\n        if (!currency) {\n            alert('Please select a currency');\n            return;\n        }\n        if (!this.walletManager.wallets[2].isConnected || !this.walletManager.wallets[2].nwcClient) {\n            alert('Stability Receiver must be connected for stabilization');\n            return;\n        }\n        if (!this.walletManager.wallets[1].isConnected || !this.walletManager.wallets[1].nwcClient) {\n            alert('Stability Provider must be connected for rebalancing');\n            return;\n        }\n        try {\n            this.log(`\\u{1F4B1} Starting stabilization for ${currency.toUpperCase()}...`);\n            // Get current balance of Stability Receiver\n            const balanceResponse = await this.walletManager.wallets[2].nwcClient.getBalance();\n            // Convert from millisats to sats\n            const currentBalance = Math.round(balanceResponse.balance / 1000);\n            // Get current Bitcoin prices\n            const response = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await response.json();\n            const currentPrice = priceData[currency.toUpperCase()];\n            if (!currentPrice) throw new Error(`Price for ${currency.toUpperCase()} not available`);\n            // Calculate target value in selected currency\n            const targetValue = currentBalance / 100000000 * currentPrice;\n            // Store stabilization data\n            this.stabilizationData = {\n                active: true,\n                currency: currency,\n                initialBalance: currentBalance,\n                targetValue: targetValue,\n                initialPrice: currentPrice,\n                checkInterval: null,\n                threshold: 1,\n                lastRebalanceTime: 0,\n                rebalanceMinInterval: 5000,\n                errorCount: 0,\n                maxErrors: 5\n            };\n            // Update UI\n            this.updateStabilizationUI();\n            // Start monitoring with longer interval to reduce timeout issues\n            this.stabilizationData.checkInterval = setInterval(()=>this.checkRebalancing(), 15000); // every 15 seconds\n            this.log(`\\u{1F4B1} Stabilization active: ${currentBalance} sats = ${targetValue.toFixed(2)} ${currency.toUpperCase()}`);\n            this.log(`\\u{1F4B1} Monitoring started (every 15 seconds with timeout protection)`);\n        } catch (error) {\n            this.log(`\\u{1F4B1} Error starting stabilization: ${error.message}`);\n            console.error('Stabilization start error:', error);\n        }\n    }\n    async stopStabilization() {\n        if (!this.stabilizationData.active) return;\n        this.log(\"\\uD83D\\uDCB1 Stopping stabilization...\");\n        // Clear monitoring interval\n        if (this.stabilizationData.checkInterval) clearInterval(this.stabilizationData.checkInterval);\n        // Reset stabilization data\n        this.stabilizationData = {\n            active: false,\n            currency: null,\n            initialBalance: 0,\n            targetValue: 0,\n            initialPrice: 0,\n            checkInterval: null,\n            threshold: 1,\n            lastRebalanceTime: 0,\n            rebalanceMinInterval: 5000,\n            errorCount: 0,\n            maxErrors: 5\n        };\n        // Update UI\n        this.updateStabilizationUI();\n        this.log(\"\\uD83D\\uDCB1 Stabilization stopped\");\n    }\n    async checkRebalancing() {\n        if (!this.stabilizationData.active) return;\n        try {\n            // Get current prices\n            const response = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await response.json();\n            const currentPrice = priceData[this.stabilizationData.currency.toUpperCase()];\n            // Get current balance of Stability Receiver\n            const balanceResponse = await this.walletManager.wallets[2].nwcClient.getBalance();\n            // Convert from millisats to sats\n            const currentBalance = Math.round(balanceResponse.balance / 1000);\n            // Calculate current value in target currency\n            const currentValue = currentBalance / 100000000 * currentPrice;\n            // Calculate required balance to maintain target value\n            const requiredBalance = Math.round(this.stabilizationData.targetValue / currentPrice * 100000000);\n            const difference = currentBalance - requiredBalance;\n            // Update status display\n            this.updateStabilizationStatus(currentBalance, currentValue, requiredBalance, difference);\n            // Update wallet displays\n            this.updateWalletStabilizationDisplay();\n            // Check if rebalancing is needed and allowed\n            const now = Date.now();\n            const timeSinceLastRebalance = now - this.stabilizationData.lastRebalanceTime;\n            // Debug logging\n            this.log(`\\u{1F4B1} Debug: difference=${difference}, abs=${Math.abs(difference)}, lastRebalance=${this.stabilizationData.lastRebalanceTime}, timeSince=${timeSinceLastRebalance}`);\n            // Get current threshold from UI\n            const currentThreshold = parseInt(document.getElementById('rebalance-threshold').value) || 1;\n            this.stabilizationData.threshold = currentThreshold;\n            if (Math.abs(difference) >= this.stabilizationData.threshold) {\n                if (timeSinceLastRebalance >= this.stabilizationData.rebalanceMinInterval) {\n                    this.log(`\\u{1F4B1} Rebalancing needed: ${difference > 0 ? '+' : ''}${difference} sats difference`);\n                    await this.performRebalancing(difference);\n                } else {\n                    const waitTime = Math.round((this.stabilizationData.rebalanceMinInterval - timeSinceLastRebalance) / 1000);\n                    if (!isNaN(waitTime) && waitTime > 0) this.log(`\\u{1F4B1} Rebalancing required (${difference > 0 ? '+' : ''}${difference} sats), but waiting ${waitTime}s (cooldown)`);\n                    else {\n                        this.log(`\\u{1F4B1} Rebalancing required (${difference > 0 ? '+' : ''}${difference} sats), starting immediately`);\n                        await this.performRebalancing(difference);\n                    }\n                }\n            } else // Log when difference is below threshold\n            if (Math.abs(difference) > 0) this.log(`\\u{1F4B1} Small difference: ${difference > 0 ? '+' : ''}${difference} sats (below ${this.stabilizationData.threshold} sats threshold)`);\n            // Reset error counter on successful check\n            this.stabilizationData.errorCount = 0;\n        } catch (error) {\n            this.stabilizationData.errorCount++;\n            this.log(`\\u{1F4B1} Error in rebalancing check (${this.stabilizationData.errorCount}/${this.stabilizationData.maxErrors}): ${error.message}`);\n            console.error('Rebalancing check error:', error);\n            // Stop stabilization if too many errors\n            if (this.stabilizationData.errorCount >= this.stabilizationData.maxErrors) {\n                this.log(`\\u{1F4B1} Too many errors (${this.stabilizationData.maxErrors}), stopping stabilization`);\n                this.stopStabilization();\n            }\n        }\n    }\n    async performRebalancing(difference) {\n        const amount = Math.abs(difference);\n        try {\n            this.log(`\\u{1F4B1} Starte Rebalancing: ${amount} sats (${difference > 0 ? \"Receiver \\u2192 Provider\" : \"Provider \\u2192 Receiver\"})`);\n            // Add timeout wrapper for all operations\n            const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>reject(new Error('Operation timed out after 30 seconds')), 30000));\n            if (difference > 0) {\n                // Stability Receiver has too much -> send excess to Stability Provider\n                // Create invoice on Stability Provider with timeout\n                const invoicePromise = this.walletManager.wallets[1].nwcClient.makeInvoice({\n                    amount: amount * 1000,\n                    description: `Stabilization: excess ${amount} sats (${this.stabilizationData.currency.toUpperCase()})`\n                });\n                const invoice = await Promise.race([\n                    invoicePromise,\n                    timeoutPromise\n                ]);\n                this.log(`\\u{1F4B1} Invoice erstellt: ${amount} sats`);\n                // Pay invoice from Stability Receiver with timeout\n                const paymentPromise = this.walletManager.wallets[2].nwcClient.payInvoice({\n                    invoice: invoice.invoice\n                });\n                const payment = await Promise.race([\n                    paymentPromise,\n                    timeoutPromise\n                ]);\n                this.log(`\\u{1F4B1} Rebalancing erfolgreich: ${amount} sats \\xfcbertragen (Receiver \\u{2192} Provider)`);\n            } else {\n                // Stability Receiver has too little -> receive from Stability Provider\n                // Create invoice on Stability Receiver with timeout\n                const invoicePromise = this.walletManager.wallets[2].nwcClient.makeInvoice({\n                    amount: amount * 1000,\n                    description: `Stabilization: deficit ${amount} sats (${this.stabilizationData.currency.toUpperCase()})`\n                });\n                const invoice = await Promise.race([\n                    invoicePromise,\n                    timeoutPromise\n                ]);\n                this.log(`\\u{1F4B1} Invoice erstellt: ${amount} sats`);\n                // Pay invoice from Stability Provider with timeout\n                const paymentPromise = this.walletManager.wallets[1].nwcClient.payInvoice({\n                    invoice: invoice.invoice\n                });\n                const payment = await Promise.race([\n                    paymentPromise,\n                    timeoutPromise\n                ]);\n                this.log(`\\u{1F4B1} Rebalancing erfolgreich: ${amount} sats \\xfcbertragen (Provider \\u{2192} Receiver)`);\n            }\n            // Update last rebalance time\n            this.stabilizationData.lastRebalanceTime = Date.now();\n            this.stabilizationData.errorCount = 0; // Reset error counter on success\n        } catch (error) {\n            this.stabilizationData.errorCount++;\n            if (error.message.includes('timed out')) {\n                this.log(`\\u{1F4B1} Rebalancing Timeout: ${error.message}`);\n                this.log(`\\u{1F4B1} M\\xf6glicherweise Relay-Verbindungsprobleme. Versuche beim n\\xe4chsten Zyklus erneut.`);\n            } else if (error.message.includes('insufficient')) this.log(`\\u{1F4B1} Rebalancing fehlgeschlagen: Unzureichende Balance`);\n            else this.log(`\\u{1F4B1} Rebalancing fehlgeschlagen: ${error.message}`);\n            console.error('Rebalancing error:', error);\n            // If too many consecutive errors, pause rebalancing for longer\n            if (this.stabilizationData.errorCount >= 3) {\n                this.stabilizationData.lastRebalanceTime = Date.now();\n                this.log(`\\u{1F4B1} Pausiere Rebalancing f\\xfcr 2 Minuten nach ${this.stabilizationData.errorCount} Fehlern`);\n                setTimeout(()=>{\n                    this.stabilizationData.lastRebalanceTime = 0;\n                    this.log(`\\u{1F4B1} Rebalancing wieder bereit`);\n                }, 120000); // 2 minutes pause\n            }\n        }\n    }\n    updateStabilizationUI() {\n        const currencySelect = document.getElementById('stabilization-currency');\n        const startBtn = document.getElementById('start-stabilization');\n        const stopBtn = document.getElementById('stop-stabilization');\n        const thresholdInput = document.getElementById('rebalance-threshold');\n        if (this.stabilizationData.active) {\n            currencySelect.disabled = true;\n            thresholdInput.disabled = true;\n            startBtn.disabled = true;\n            stopBtn.disabled = false;\n        } else {\n            currencySelect.disabled = false;\n            thresholdInput.disabled = false;\n            startBtn.disabled = !currencySelect.value || !this.walletManager.wallets[1].isConnected || !this.walletManager.wallets[2].isConnected;\n            stopBtn.disabled = true;\n        }\n    }\n    updateStabilizationStatus(currentBalance, currentValue, requiredBalance, difference) {\n        const statusElement = document.getElementById('stabilization-status');\n        const infoElement = document.getElementById('stabilization-info');\n        if (this.stabilizationData.active) {\n            const currency = this.stabilizationData.currency.toUpperCase();\n            const targetValue = this.stabilizationData.targetValue;\n            statusElement.className = 'alert alert-success py-2 px-3 mb-2';\n            statusElement.innerHTML = `Status: Aktiv (${currency})`;\n            infoElement.innerHTML = `\n                <div><strong>Zielwert:</strong> ${targetValue.toFixed(2)} ${currency}</div>\n                <div><strong>Aktueller Wert:</strong> ${currentValue.toFixed(2)} ${currency}</div>\n                <div><strong>Balance:</strong> ${currentBalance.toLocaleString()} sats</div>\n                <div><strong>Soll-Balance:</strong> ${requiredBalance.toLocaleString()} sats</div>\n                <div><strong>Differenz:</strong> ${difference > 0 ? '+' : ''}${difference.toLocaleString()} sats</div>\n            `;\n        } else {\n            statusElement.className = 'alert alert-secondary py-2 px-3 mb-2';\n            statusElement.innerHTML = 'Status: Nicht aktiv';\n            infoElement.innerHTML = '';\n        }\n    }\n    async updateWalletStabilizationDisplay() {\n        // Update Stability Provider display\n        await this.updateSingleWalletDisplay(1);\n        // Update Stability Receiver display\n        await this.updateSingleWalletDisplay(2);\n        // Update transaction displays\n        await this.updateWalletTransactions(1);\n        await this.updateWalletTransactions(2);\n    }\n    async updateSingleWalletDisplay(walletId) {\n        const infoElement = document.getElementById(`wallet${walletId}-stabilization-info`);\n        if (!this.walletManager.wallets[walletId].isConnected) {\n            infoElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <i class=\"fas fa-info-circle\"></i>\n                    <div>Wallet ${walletId} verbinden um Daten anzuzeigen</div>\n                </div>\n            `;\n            return;\n        }\n        try {\n            // Get wallet balance\n            const balanceResponse = await this.walletManager.wallets[walletId].nwcClient.getBalance();\n            const balanceSats = Math.round(balanceResponse.balance / 1000);\n            // Get current Bitcoin price\n            const priceResponse = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await priceResponse.json();\n            // Calculate values for different currencies\n            const currencies = {\n                USD: {\n                    symbol: '$',\n                    value: priceData.USD\n                },\n                EUR: {\n                    symbol: \"\\u20AC\",\n                    value: priceData.EUR\n                },\n                GBP: {\n                    symbol: \"\\xa3\",\n                    value: priceData.GBP\n                },\n                CHF: {\n                    symbol: \"\\u20A3\",\n                    value: priceData.CHF\n                },\n                CAD: {\n                    symbol: 'C$',\n                    value: priceData.CAD\n                },\n                JPY: {\n                    symbol: \"\\xa5\",\n                    value: priceData.JPY\n                }\n            };\n            let currencyDisplays = '';\n            Object.entries(currencies).forEach(([code, data])=>{\n                const value = balanceSats / 100000000 * data.value;\n                currencyDisplays += `\n                    <div class=\"d-flex justify-content-between mb-1\">\n                        <span class=\"small\">${code}:</span>\n                        <span class=\"small fw-bold\">${data.symbol}${value.toFixed(2)}</span>\n                    </div>\n                `;\n            });\n            // Show stabilization status for Stability Receiver\n            let stabilizationStatus = '';\n            if (walletId === 2 && this.stabilizationData.active) {\n                const targetCurrency = this.stabilizationData.currency.toUpperCase();\n                const currentValue = balanceSats / 100000000 * currencies[targetCurrency].value;\n                const targetValue = this.stabilizationData.targetValue;\n                const difference = currentValue - targetValue;\n                stabilizationStatus = `\n                    <div class=\"border-top pt-2 mt-2\">\n                        <div class=\"small text-success\">\n                            <strong>\\u{1F3AF} Stabilisierung aktiv (${targetCurrency})</strong>\n                        </div>\n                        <div class=\"d-flex justify-content-between\">\n                            <span class=\"small\">Zielwert:</span>\n                            <span class=\"small\">${currencies[targetCurrency].symbol}${targetValue.toFixed(2)}</span>\n                        </div>\n                        <div class=\"d-flex justify-content-between\">\n                            <span class=\"small\">Differenz:</span>\n                            <span class=\"small ${difference >= 0 ? 'text-success' : 'text-danger'}\">\n                                ${difference >= 0 ? '+' : ''}${currencies[targetCurrency].symbol}${difference.toFixed(2)}\n                            </span>\n                        </div>\n                    </div>\n                `;\n            }\n            infoElement.innerHTML = `\n                <div class=\"mb-2\">\n                    <div class=\"d-flex justify-content-between mb-2\">\n                        <span class=\"fw-bold\">Balance:</span>\n                        <span class=\"fw-bold text-primary\">${balanceSats.toLocaleString()} sats</span>\n                    </div>\n                    <div class=\"border-top pt-2\">\n                        <div class=\"small text-muted mb-1\">W\\xe4hrungswerte:</div>\n                        ${currencyDisplays}\n                    </div>\n                    ${stabilizationStatus}\n                </div>\n            `;\n        } catch (error) {\n            infoElement.innerHTML = `\n                <div class=\"text-center text-danger py-3\">\n                    <i class=\"fas fa-exclamation-triangle\"></i>\n                    <div>Fehler beim Laden der Wallet-Daten</div>\n                    <small>${error.message}</small>\n                </div>\n            `;\n        }\n    }\n    async updateWalletTransactions(walletId) {\n        const transactionsElement = document.getElementById(`wallet${walletId}-transactions`);\n        if (!this.walletManager.wallets[walletId].isConnected) {\n            transactionsElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <i class=\"fas fa-info-circle\"></i>\n                    <div>Wallet ${walletId} verbinden um Transaktionen anzuzeigen</div>\n                </div>\n            `;\n            return;\n        }\n        // Check if we already know transactions are not supported\n        if (this.walletManager.wallets[walletId].transactionsSupported === false) {\n            transactionsElement.innerHTML = `\n                <div class=\"text-center text-warning py-3\">\n                    <i class=\"fas fa-clock\"></i>\n                    <div>Transaktionen nicht verf\\xfcgbar</div>\n                    <small class=\"text-muted\">NWC Provider unterst\\xfctzt diese Funktion nicht</small>\n                </div>\n            `;\n            return;\n        }\n        // Show loading state only on first attempt\n        if (this.walletManager.wallets[walletId].transactionsSupported === null) transactionsElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <div class=\"spinner-border spinner-border-sm me-2\" role=\"status\"></div>\n                    <div>Transaktionen werden geladen...</div>\n                </div>\n            `;\n        try {\n            // Use the existing working listTransactions logic\n            const transactionResponse = await this.walletManager.wallets[walletId].nwcClient.listTransactions({\n                from: 0,\n                until: Math.floor(Date.now() / 1000),\n                limit: 10,\n                offset: 0,\n                unpaid: false,\n                type: undefined\n            });\n            let transactions = transactionResponse.transactions || transactionResponse;\n            // If that fails, try without parameters as fallback\n            if (!transactions || transactions.length === 0) {\n                const fallbackResponse = await this.walletManager.wallets[walletId].nwcClient.listTransactions({});\n                transactions = fallbackResponse.transactions || fallbackResponse;\n            }\n            // Mark as supported if we get here\n            this.walletManager.wallets[walletId].transactionsSupported = true;\n            if (!transactions || transactions.length === 0) {\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-muted py-3\">\n                        <i class=\"fas fa-inbox\"></i>\n                        <div>Keine Transaktionen gefunden</div>\n                    </div>\n                `;\n                return;\n            }\n            // Sort transactions by date (newest first) and limit to last 10\n            const sortedTransactions = transactions.sort((a, b)=>b.created_at - a.created_at).slice(0, 10);\n            let transactionHtml = '';\n            sortedTransactions.forEach((tx)=>{\n                const date = new Date(tx.created_at * 1000);\n                const amountSats = Math.round(tx.amount / 1000); // Convert millisats to sats\n                const txType = tx.type || 'payment';\n                // Determine if transaction is incoming or outgoing\n                let isIncoming = false;\n                let icon = \"\\uD83D\\uDCB8\";\n                let colorClass = 'text-danger';\n                let typeText = 'Ausgehend';\n                // Check transaction type first, then amount as fallback\n                if (txType === 'incoming') {\n                    isIncoming = true;\n                    icon = \"\\uD83D\\uDCE5\";\n                    colorClass = 'text-success';\n                    typeText = 'Empfangen';\n                } else if (txType === 'outgoing') {\n                    isIncoming = false;\n                    icon = \"\\uD83D\\uDCE4\";\n                    colorClass = 'text-danger';\n                    typeText = 'Gesendet';\n                } else {\n                    // Fallback: use amount sign to determine direction\n                    isIncoming = amountSats > 0;\n                    if (isIncoming) {\n                        icon = \"\\uD83D\\uDCB0\";\n                        colorClass = 'text-success';\n                        typeText = 'Eingehend';\n                    }\n                }\n                // Format description\n                let description = tx.description || tx.memo || 'Keine Beschreibung';\n                if (description.length > 40) description = description.substring(0, 40) + '...';\n                transactionHtml += `\n                    <div class=\"border-bottom px-3 py-2\">\n                        <div class=\"d-flex justify-content-between align-items-start mb-1\">\n                            <div class=\"d-flex align-items-center\">\n                                <span class=\"me-2\">${icon}</span>\n                                <div>\n                                    <div class=\"small fw-bold ${colorClass}\">\n                                        ${isIncoming ? '+' : '-'}${Math.abs(amountSats).toLocaleString()} sats\n                                    </div>\n                                    <div class=\"text-muted\" style=\"font-size: 0.75rem;\">\n                                        ${typeText}\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"text-end\">\n                                <div class=\"text-muted small\">\n                                    ${date.toLocaleString('de-DE', {\n                    day: '2-digit',\n                    month: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit'\n                })}\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"small text-muted\" style=\"font-size: 0.75rem;\">\n                            ${description}\n                        </div>\n                    </div>\n                `;\n            });\n            transactionsElement.innerHTML = transactionHtml;\n        } catch (error) {\n            console.warn(`Wallet ${walletId} transactions error:`, error.message);\n            // Determine if it's a timeout or other error\n            const isTimeout = error.message.includes('Timeout') || error.message.includes('reply timeout');\n            if (isTimeout) {\n                // Mark transactions as unsupported for this wallet\n                this.walletManager.wallets[walletId].transactionsSupported = false;\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-warning py-3\">\n                        <i class=\"fas fa-clock\"></i>\n                        <div>Transaktionen nicht verf\\xfcgbar</div>\n                        <small class=\"text-muted\">NWC Provider unterst\\xfctzt diese Funktion nicht</small>\n                    </div>\n                `;\n            } else {\n                // For non-timeout errors, still mark as unsupported to avoid retries\n                this.walletManager.wallets[walletId].transactionsSupported = false;\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-danger py-3\">\n                        <i class=\"fas fa-exclamation-triangle\"></i>\n                        <div>Fehler beim Laden der Transaktionen</div>\n                        <small class=\"text-muted\">${error.message}</small>\n                    </div>\n                `;\n            }\n        }\n    }\n}\n\n\n// Main Application Class\nclass $77ac944da51b7354$var$NWCApp {\n    constructor(){\n        this.walletManager = new (0, $a77da6ceca5d66da$export$d9a919bae0329c9a)();\n        this.priceManager = new (0, $6a2e34ea2fddba81$export$1a7dcbc42b6f58b1)();\n        this.stabilizationManager = new (0, $d0c67cc6a727cdb2$export$3d022597fb56d1f4)(this.walletManager);\n        this.setupEventListeners();\n        this.makeGlobalFunctions();\n    }\n    setupEventListeners() {\n        // Listen for wallet connection changes to update stabilization UI\n        window.addEventListener('walletConnectionChanged', ()=>{\n            this.stabilizationManager.updateStabilizationUI();\n            this.stabilizationManager.updateWalletStabilizationDisplay();\n        });\n        // Setup currency selection handler\n        const currencySelect = document.getElementById('stabilization-currency');\n        if (currencySelect) currencySelect.addEventListener('change', ()=>{\n            this.stabilizationManager.updateStabilizationUI();\n        });\n        // Handle page load\n        window.addEventListener('load', ()=>{\n            this.initialize();\n        });\n    }\n    initialize() {\n        this.walletManager.log('NWC Demo page loaded');\n        this.walletManager.log('REAL NWC INTEGRATION with local dependencies - Use real wallet connection strings!');\n        this.walletManager.log('Supported wallets: Alby Hub, Coinos, Primal, lnwallet.app, Yakihonne...');\n        // Start Bitcoin price updates\n        this.priceManager.startPriceUpdates();\n        // Initialize stabilization UI\n        this.stabilizationManager.updateStabilizationUI();\n        // Load saved connection strings\n        this.walletManager.loadSavedConnectionStrings();\n        // Initialize price chart\n        this.priceManager.initializePriceChart();\n        // Load historical prices on first load if no data exists\n        const existingHistory = this.priceManager.getPriceHistory();\n        if (existingHistory.length === 0) this.priceManager.fetchHistoricalPrices();\n    }\n    // Make functions globally available for HTML onclick handlers\n    makeGlobalFunctions() {\n        // Wallet functions\n        window.connectWallet = (walletId)=>this.walletManager.connectWallet(walletId);\n        window.disconnectWallet = (walletId)=>this.walletManager.disconnectWallet(walletId);\n        window.getWalletInfo = (walletId)=>this.walletManager.getWalletInfo(walletId);\n        window.getBalance = (walletId)=>this.walletManager.getBalance(walletId);\n        window.createInvoice = (walletId)=>this.walletManager.createInvoice(walletId);\n        window.payInvoice = (walletId)=>this.walletManager.payInvoice(walletId);\n        window.listTransactions = (walletId)=>this.walletManager.listTransactions(walletId);\n        window.payKeysend = (walletId)=>this.walletManager.payKeysend(walletId);\n        window.saveConnectionString = (walletId)=>this.walletManager.saveConnectionString(walletId);\n        window.clearConnectionString = (walletId)=>this.walletManager.clearConnectionString(walletId);\n        window.toggleConnectionVisibility = (walletId)=>this.walletManager.toggleConnectionVisibility(walletId);\n        window.clearLog = ()=>this.walletManager.clearLog();\n        // Price functions\n        window.fetchBitcoinPrice = ()=>this.priceManager.fetchBitcoinPrice();\n        window.startPriceUpdates = ()=>this.priceManager.startPriceUpdates();\n        window.stopPriceUpdates = ()=>this.priceManager.stopPriceUpdates();\n        window.fetchHistoricalPrices = ()=>this.priceManager.fetchHistoricalPrices();\n        window.updatePriceChart = ()=>this.priceManager.updatePriceChart();\n        window.clearAndReloadPriceData = ()=>this.priceManager.clearAndReloadPriceData();\n        // Stabilization functions\n        window.startStabilization = ()=>this.stabilizationManager.startStabilization();\n        window.stopStabilization = ()=>this.stabilizationManager.stopStabilization();\n    }\n}\n// Initialize the application\nnew $77ac944da51b7354$var$NWCApp();\n\n\n//# sourceMappingURL=nwc.36942d46.js.map\n","import{Relay as e,nip19 as t,finalizeEvent as n,getEventHash as r,nip04 as o,nip44 as i,generateSecretKey as s,getPublicKey as u}from\"nostr-tools\";import{Invoice as c,LightningAddress as a,fiat as l}from\"@getalby/lightning-tools\";function h(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function f(e,t,n){return t&&h(e.prototype,t),n&&h(e,n),Object.defineProperty(e,\"prototype\",{writable:!1}),e}function d(){return d=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},d.apply(this,arguments)}function v(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,m(e,t)}function p(e){return p=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(e){return e.__proto__||Object.getPrototypeOf(e)},p(e)}function m(e,t){return m=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},m(e,t)}function y(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}function P(e,t,n){return P=y()?Reflect.construct.bind():function(e,t,n){var r=[null];r.push.apply(r,t);var o=new(Function.bind.apply(e,r));return n&&m(o,n.prototype),o},P.apply(null,arguments)}function w(e){var t=\"function\"==typeof Map?new Map:void 0;return w=function(e){if(null===e||-1===Function.toString.call(e).indexOf(\"[native code]\"))return e;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return P(e,arguments,p(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),m(n,e)},w(e)}function g(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t.indexOf(n=i[r])>=0||(o[n]=e[n]);return o}var b=/*#__PURE__*/function(){function e(){this.events={}}var t=e.prototype;return t.on=function(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)},t.off=function(e,t){this.events[e]&&(this.events[e]=this.events[e].filter(function(e){return e!==t}))},t.emit=function(e,t){this.events[e]&&this.events[e].forEach(function(e){return e(t)})},e}();function _(e){return Object.entries(e).map(function(e){var t=e[0],n=e[1];return t&&n?t+\"=\"+n:\"\"}).filter(function(e){return e}).join(\"&\")}function k(e,t){return\"Basic \"+btoa(e+\":\"+t)}var E={__proto__:null,buildQueryString:_,basicAuthHeader:k},T=/*#__PURE__*/function(e){function t(t,n,r,o){var i,s=t.toString();return n&&(s+=\" \"+n),s+=\": \",s+=o.message?o.message:JSON.stringify(o),(i=e.call(this,s)||this).status=void 0,i.statusText=void 0,i.headers=void 0,i.error=void 0,i.status=t,i.statusText=n,i.headers=r,i.error=o,i}return v(t,e),t}(/*#__PURE__*/w(Error)),N={__proto__:null,OAuthClient:function(){},AuthClient:function(){},AlbyResponseError:T},j=[\"auth\",\"endpoint\",\"params\",\"request_body\",\"method\",\"max_retries\",\"base_url\",\"user_agent\",\"headers\"],q=function(e){return Promise.resolve(R(e)).then(function(e){return e.json()})},R=function(e){var t=e.auth,n=e.endpoint,r=e.params,o=void 0===r?{}:r,i=e.request_body,s=e.method,u=e.max_retries,c=e.base_url,a=void 0===c?O:c,l=e.user_agent,h=e.headers,f=g(e,j);try{var v=function(e){return Promise.resolve(S(p.toString(),d({headers:d({},m?{\"Content-Type\":\"application/json; charset=utf-8\"}:void 0,e,h,{\"User-Agent\":null!=l?l:\"@getalby/sdk\",\"X-User-Agent\":null!=l?l:\"@getalby/sdk\"}),method:s,body:m?JSON.stringify(i):void 0},f),u)).then(function(e){var t=function(){if(!e.ok)return Promise.resolve(e.json()).then(function(t){throw new T(e.status,e.statusText,e.headers,t)})}();return t&&t.then?t.then(function(t){return e}):e})},p=new URL(a+n);p.search=_(o);var m=\"POST\"===s&&!!i;return Promise.resolve(t?Promise.resolve(t.getAuthHeader(p.href,s)).then(v):v(void 0))}catch(e){return Promise.reject(e)}},S=function e(t,n,r){void 0===r&&(r=0);try{return Promise.resolve(fetch(t,n)).then(function(o){var i,s=function(){if(429===o.status&&r>0){var s=Number(o.headers.get(\"x-rate-limit-reset\")),u=Number(o.headers.get(\"x-rate-limit-remaining\")),c=1e3*s-Date.now(),a=1e3;return 0===u&&(a=c),Promise.resolve(new Promise(function(e){return setTimeout(e,a)})).then(function(){var o=e(t,n,r-1);return i=1,o})}}();return s&&s.then?s.then(function(e){return i?e:o}):i?s:o})}catch(e){return Promise.reject(e)}},O=\"https://api.getalby.com\",I=function(e){return e.reduce(function(e,t){return e+t.toString(16).padStart(2,\"0\")},\"\")},x=[\"expires_in\"],A=[\"token\"];function U(e){var t=e.expires_in;return d({},g(e,x),!!t&&{expires_at:Date.now()+1e3*t})}var C=/*#__PURE__*/function(){function e(e){this.token=void 0,this.options=void 0,this.code_verifier=void 0,this.code_challenge=void 0,this._refreshAccessTokenPromise=void 0,this._tokenEvents=void 0,this._tokenEvents=new b;var t=e.token,n=g(e,A);this.options=d({client_secret:\"\"},n),this.token=t,this._refreshAccessTokenPromise=null}var t=e.prototype;return t.on=function(e,t){this._tokenEvents.on(e,t)},t.refreshAccessToken=function(){try{var e=this;return e._refreshAccessTokenPromise||(e._refreshAccessTokenPromise=new Promise(function(t,n){try{return Promise.resolve(function(r,o){try{var i=function(n,r){try{var o=function(){var n,r=null==(n=e.token)?void 0:n.refresh_token,o=e.options,i=o.client_id,s=o.client_secret,u=o.request_options,c=o.user_agent;if(!i)throw new Error(\"client_id is required\");if(!r)throw new Error(\"refresh_token is required\");return Promise.resolve(q(d({},u,{endpoint:\"/oauth/token\",params:{client_id:i,grant_type:\"refresh_token\",refresh_token:r},user_agent:c,method:\"POST\",headers:d({},null==u?void 0:u.headers,{\"Content-type\":\"application/x-www-form-urlencoded\"},{Authorization:k(i,s)})}))).then(function(n){var r=U(n);e.token=r,t({token:r}),e._tokenEvents.emit(\"tokenRefreshed\",e.token)})}()}catch(e){return r(e)}return o&&o.then?o.then(void 0,r):o}(0,function(t){console.error(t),n(t),e._tokenEvents.emit(\"tokenRefreshFailed\",t)})}catch(e){return o(!0,e)}return i&&i.then?i.then(o.bind(null,!1),o.bind(null,!0)):o(!1,i)}(0,function(t,n){if(e._refreshAccessTokenPromise=null,t)throw n;return n}))}catch(e){return Promise.reject(e)}})),Promise.resolve(e._refreshAccessTokenPromise)}catch(e){return Promise.reject(e)}},t.isAccessTokenExpired=function(){var e,t,n=null==(e=this.token)?void 0:e.refresh_token,r=null==(t=this.token)?void 0:t.expires_at;return!r||!!n&&r<=Date.now()+1e3},t.requestAccessToken=function(e){try{var t=this,n=t.options,r=n.client_id,o=n.client_secret,i=n.callback,s=n.request_options,u=n.user_agent,c=t.code_verifier;if(!r)throw new Error(\"client_id is required\");if(!o&&!c)throw new Error(\"either client_secret is required, or code should be generated using a challenge\");if(!i)throw new Error(\"callback is required\");return Promise.resolve(q(d({},s,{endpoint:\"/oauth/token\",params:{code:e,grant_type:\"authorization_code\",code_verifier:c,client_id:r,redirect_uri:i},user_agent:u,method:\"POST\",headers:d({},null==s?void 0:s.headers,{\"Content-Type\":\"application/x-www-form-urlencoded\"},{Authorization:k(r,o)})}))).then(function(e){var n=U(e);return t.token=n,{token:n}})}catch(e){return Promise.reject(e)}},t.generateAuthURL=function(e){try{var t=function(){var t=n.code_challenge,o=new URL(e.authorizeUrl||\"https://getalby.com/oauth\");return o.search=_(d({},e,{client_id:i,scope:u.join(\" \"),response_type:\"code\",redirect_uri:s,code_challenge_method:r,code_challenge:t})),o.toString()},n=this;e||(e={});var r,o=n.options,i=o.client_id,s=o.callback,u=o.scopes;if(!s)throw new Error(\"callback required\");if(!u)throw new Error(\"scopes required\");var c=function(){if(\"S256\"===e.code_challenge_method)return Promise.resolve(n._generateS256Challenge()).then(function(){r=\"S256\"});\"plain\"===e.code_challenge_method&&e.code_challenge&&(n.code_challenge=e.code_challenge,n.code_verifier=e.code_challenge,r=\"plain\")}();return Promise.resolve(c&&c.then?c.then(t):t())}catch(e){return Promise.reject(e)}},t.getAuthHeader=function(){try{var e,t=function(){return{Authorization:\"Bearer \"+n.token.access_token}},n=this;if(null==(e=n.token)||!e.access_token)throw new Error(\"access_token is required\");var r=function(){if(n.isAccessTokenExpired())return Promise.resolve(n.refreshAccessToken()).then(function(){})}();return Promise.resolve(r&&r.then?r.then(t):t())}catch(e){return Promise.reject(e)}},t._generateS256Challenge=function(){try{var e=this,t=crypto.getRandomValues(new Uint8Array(64));return e.code_verifier=I(t),Promise.resolve(crypto.subtle.digest(\"SHA-256\",(new TextEncoder).encode(e.code_verifier))).then(function(t){var n=new Uint8Array(t);e.code_challenge=btoa(String.fromCharCode.apply(String,n)).replace(/\\+/g,\"-\").replace(/\\//g,\"_\").replace(/=+$/,\"\")})}catch(e){return Promise.reject(e)}},e}(),M=/*#__PURE__*/function(){function e(e){this.bearer_token=void 0,this.bearer_token=e}return e.prototype.getAuthHeader=function(){return{Authorization:\"Bearer \"+this.bearer_token}},e}(),F={__proto__:null,OAuth2User:C,OAuth2Bearer:M};function W(e){var t={};return e.recipient.customKey&&e.recipient.customValue&&(t[e.recipient.customKey]=e.recipient.customValue),t[7629169]=JSON.stringify(e.boostagram),{destination:e.recipient.address,amount:e.amount,custom_records:t}}var L=/*#__PURE__*/function(){function e(e,t){this.auth=void 0,this.defaultRequestOptions=void 0,this.auth=\"string\"==typeof e?new M(e):e,this.defaultRequestOptions=d({},t,{user_agent:null==t?void 0:t.user_agent})}var t=e.prototype;return t.accountBalance=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/balance\",params:e,method:\"GET\"}))},t.signMessage=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/signatures\",request_body:e,method:\"POST\"}))},t.accountSummary=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/user/summary\",params:e,method:\"GET\"}))},t.accountInformation=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/user/me\",params:e,method:\"GET\"}))},t.accountValue4Value=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/user/value4value\",params:e,method:\"GET\"}))},t.incomingInvoices=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/invoices/incoming\",params:e,method:\"GET\"}))},t.outgoingInvoices=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/invoices/outgoing\",params:e,method:\"GET\"}))},t.invoices=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/invoices\",params:e,method:\"GET\"}))},t.getInvoice=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/invoices/\"+e,method:\"GET\"}))},t.decodeInvoice=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/decode/bolt11/\"+e,method:\"GET\"}))},t.createInvoice=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/invoices\",request_body:e,method:\"POST\"}))},t.keysend=function(e,t){var n,r;return Array.isArray(e)?(n=\"/payments/keysend/multi\",r={keysends:e.map(function(e){return d({},e,{custom_records:e.customRecords})})}):(n=\"/payments/keysend\",r=d({},e,{custom_records:e.customRecords})),q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:n,request_body:r,method:\"POST\"}))},t.sendPayment=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/payments/bolt11\",request_body:e,method:\"POST\"}))},t.sendBoostagram=function(e,t){var n,r;return Array.isArray(e)?(n=\"/payments/keysend/multi\",r={keysends:e.map(function(e){return W(e)})}):(n=\"/payments/keysend\",r=W(e)),q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:n,request_body:r,method:\"POST\"}))},t.sendBoostagramToAlbyAccount=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/payments/keysend\",request_body:{destination:\"030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3\",custom_records:{696969:e.account},amount:e.amount,memo:e.memo},method:\"POST\"}))},t.createWebhookEndpoint=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/webhook_endpoints\",request_body:e,method:\"POST\"}))},t.deleteWebhookEndpoint=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/webhook_endpoints/\"+e,method:\"DELETE\"}))},t.getSwapInfo=function(e){return q(d({auth:this.auth},this.defaultRequestOptions,e,{endpoint:\"/swaps/info\",method:\"GET\"}))},t.createSwap=function(e,t){return q(d({auth:this.auth},this.defaultRequestOptions,t,{endpoint:\"/swaps\",method:\"POST\",request_body:e}))},e}(),K={__proto__:null,auth:F,types:N,utils:E,Client:L};if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error(\"Non little-endian hardware is not supported\");const B=/* @__PURE__ */Array.from({length:256},(e,t)=>t.toString(16).padStart(2,\"0\"));function J(e){if(!(e instanceof Uint8Array))throw new Error(\"Uint8Array expected\");let t=\"\";for(let n=0;n<e.length;n++)t+=B[e[n]];return t}function H(e){if(\"string\"!=typeof e)throw new Error(\"hex string expected, got \"+typeof e);const t=e.length;if(t%2)throw new Error(\"padded hex string expected, got unpadded hex of length \"+t);const n=new Uint8Array(t/2);for(let t=0;t<n.length;t++){const r=2*t,o=e.slice(r,r+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error(\"Invalid byte sequence\");n[t]=i}return n}var z=/*#__PURE__*/function(e){function t(t,n){var r;return(r=e.call(this,t)||this).code=void 0,r.code=n,r}return v(t,e),t}(/*#__PURE__*/w(Error)),D=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),G=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),V=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),Y=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(V),X=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(V),Q=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),$=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),Z=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),ee=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z),te=/*#__PURE__*/function(e){function t(){return e.apply(this,arguments)||this}return v(t,e),t}(z);function ne(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}function re(e,t,n){if(!e.s){if(n instanceof oe){if(!n.s)return void(n.o=re.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(re.bind(null,e,t),re.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var oe=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){var r=new e,o=this.s;if(o){var i=1&o?t:n;if(i){try{re(r,1,i(this.v))}catch(e){re(r,2,e)}return r}return this}return this.o=function(e){try{var o=e.v;1&e.s?re(r,1,t?t(o):o):n?re(r,1,n(o)):re(r,2,o)}catch(e){re(r,2,e)}},r},e}();function ie(e){return e instanceof oe&&1&e.s}var se=/*#__PURE__*/function(){function c(n){this.relay=void 0,this.relayUrl=void 0,this.secret=void 0,this.lud16=void 0,this.walletPubkey=void 0,this.options=void 0,this._encryptionType=void 0,n&&n.nostrWalletConnectUrl&&(n=d({},c.parseWalletConnectUrl(n.nostrWalletConnectUrl),n)),this.options=d({},n||{}),this.relayUrl=this.options.relayUrl,this.relay=new e(this.relayUrl),this.options.secret&&(this.secret=this.options.secret.toLowerCase().startsWith(\"nsec\")?t.decode(this.options.secret).data:this.options.secret),this.lud16=this.options.lud16,this.walletPubkey=this.options.walletPubkey.toLowerCase().startsWith(\"npub\")?t.decode(this.options.walletPubkey).data:this.options.walletPubkey,void 0===globalThis.WebSocket&&console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\")}c.parseWalletConnectUrl=function(e){e=e.replace(\"nostrwalletconnect://\",\"http://\").replace(\"nostr+walletconnect://\",\"http://\").replace(\"nostrwalletconnect:\",\"http://\").replace(\"nostr+walletconnect:\",\"http://\");var t=new URL(e),n=t.searchParams.get(\"relay\");if(!n)throw new Error(\"No relay URL found in connection string\");var r={walletPubkey:t.host,relayUrl:n},o=t.searchParams.get(\"secret\");o&&(r.secret=o);var i=t.searchParams.get(\"lud16\");return i&&(r.lud16=i),r};var a=c.prototype;return a.getNostrWalletConnectUrl=function(e){void 0===e&&(e=!0);var t=\"nostr+walletconnect://\"+this.walletPubkey+\"?relay=\"+this.relayUrl+\"&pubkey=\"+this.publicKey;return e&&(t=t+\"&secret=\"+this.secret),this.lud16&&(t=t+\"&lud16=\"+this.lud16),t},a.getPublicKey=function(){return Promise.resolve(this.publicKey)},a.signEvent=function(e){if(!this.secret)throw new Error(\"Missing secret key\");return Promise.resolve(n(e,H(this.secret)))},a.getEventHash=function(e){return r(e)},a.close=function(){return this.relay.close()},a.encrypt=function(e,t){try{var n,r=this;if(!r.secret)throw new Error(\"Missing secret\");var s=function(){if(\"nip04\"===r.encryptionType)return Promise.resolve(o.encrypt(r.secret,e,t)).then(function(e){n=e});var s=i.getConversationKey(H(r.secret),e);n=i.encrypt(t,s)}();return Promise.resolve(s&&s.then?s.then(function(){return n}):n)}catch(e){return Promise.reject(e)}},a.decrypt=function(e,t){try{var n,r=this;if(!r.secret)throw new Error(\"Missing secret\");var s=function(){if(\"nip04\"===r.encryptionType)return Promise.resolve(o.decrypt(r.secret,e,t)).then(function(e){n=e});var s=i.getConversationKey(H(r.secret),e);n=i.decrypt(t,s)}();return Promise.resolve(s&&s.then?s.then(function(){return n}):n)}catch(e){return Promise.reject(e)}},c.getAuthorizationUrl=function(e,t,n){if(void 0===t&&(t={}),e.indexOf(\"/#/\")>-1)throw new Error(\"hash router paths not supported\");var r=new URL(e);return t.name&&r.searchParams.set(\"name\",t.name),r.searchParams.set(\"pubkey\",n),t.returnTo&&r.searchParams.set(\"return_to\",t.returnTo),t.budgetRenewal&&r.searchParams.set(\"budget_renewal\",t.budgetRenewal),t.expiresAt&&r.searchParams.set(\"expires_at\",Math.floor(t.expiresAt.getTime()/1e3).toString()),t.maxAmount&&r.searchParams.set(\"max_amount\",t.maxAmount.toString()),t.requestMethods&&r.searchParams.set(\"request_methods\",t.requestMethods.join(\" \")),t.notificationTypes&&r.searchParams.set(\"notification_types\",t.notificationTypes.join(\" \")),t.isolated&&r.searchParams.set(\"isolated\",\"true\"),t.metadata&&r.searchParams.set(\"metadata\",JSON.stringify(t.metadata)),r},c.fromAuthorizationUrl=function(e,t,n){void 0===t&&(t={}),n=n||J(s()),t.name||(t.name=document.location.host);var r=this.getAuthorizationUrl(e,t,u(H(n))),o=window.outerHeight/2+window.screenY-300,i=window.outerWidth/2+window.screenX-200;return new Promise(function(e,t){var s=window.open(r.toString(),document.title+\" - Wallet Connect\",\"height=600,width=400,top=\"+o+\",left=\"+i);if(s){var u=function o(i){var u=i.data;u&&\"nwc:success\"===u.type&&i.origin===r.protocol+\"//\"+r.host&&(u.relayUrl||t(new Error(\"no relayUrl in response\")),u.walletPubkey||t(new Error(\"no walletPubkey in response\")),e(new c({relayUrl:u.relayUrl,walletPubkey:u.walletPubkey,secret:n,lud16:u.lud16})),clearInterval(a),window.removeEventListener(\"message\",o),s&&s.close())},a=setInterval(function(){s&&s.closed&&(clearInterval(a),window.removeEventListener(\"message\",u),t(new Error(\"Popup closed\")))},500);window.addEventListener(\"message\",u)}else t(new Error(\"failed to execute window.open\"))})},a.getWalletServiceInfo=function(){try{var e=this;return Promise.resolve(e._checkConnected()).then(function(){return Promise.resolve(new Promise(function(t,n){var r=[],o=e.relay.subscribe([{kinds:[13194],limit:1,authors:[e.walletPubkey]}],{eoseTimeout:1e4});o.onevent=function(e){r.push(e)},o.oneose=function(){o.close(),t(r)}})).then(function(e){var t;if(!e.length)throw new Error(\"no info event (kind 13194) returned from relay\");var n=e[0].content,r=e[0].tags.find(function(e){return\"notifications\"===e[0]}),o=e[0].tags.find(function(e){return\"v\"===e[0]}),i=e[0].tags.find(function(e){return\"encryption\"===e[0]}),s=[\"nip04\"];return o&&o[1].includes(\"1.0\")&&s.push(\"nip44_v2\"),i&&(s=i[1].split(\" \")),{encryptions:s,capabilities:n.split(/[ |,]/g),notifications:(null==r||null==(t=r[1])?void 0:t.split(\" \"))||[]}})})}catch(e){return Promise.reject(e)}},a.getInfo=function(){try{var e=this;return Promise.resolve(ne(function(){return Promise.resolve(e.executeNip47Request(\"get_info\",{},function(e){return!!e.methods},{replyTimeout:1e4}))},function(e){throw console.error(\"Failed to request get_info\",e),e}))}catch(e){return Promise.reject(e)}},a.getBudget=function(){try{var e=this;return Promise.resolve(ne(function(){return Promise.resolve(e.executeNip47Request(\"get_budget\",{},function(e){return void 0!==e},{replyTimeout:1e4}))},function(e){throw console.error(\"Failed to request get_budget\",e),e}))}catch(e){return Promise.reject(e)}},a.getBalance=function(){try{var e=this;return Promise.resolve(ne(function(){return Promise.resolve(e.executeNip47Request(\"get_balance\",{},function(e){return void 0!==e.balance},{replyTimeout:1e4}))},function(e){throw console.error(\"Failed to request get_balance\",e),e}))}catch(e){return Promise.reject(e)}},a.payInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"pay_invoice\",e,function(e){return!!e}))},function(e){throw console.error(\"Failed to request pay_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.payKeysend=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"pay_keysend\",e,function(e){return!!e.preimage}))},function(e){throw console.error(\"Failed to request pay_keysend\",e),e}))}catch(e){return Promise.reject(e)}},a.signMessage=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"sign_message\",e,function(t){return t.message===e.message&&!!t.signature}))},function(e){throw console.error(\"Failed to request sign_message\",e),e}))}catch(e){return Promise.reject(e)}},a.createConnection=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"create_connection\",e,function(e){return!!e.wallet_pubkey}))},function(e){throw console.error(\"Failed to request create_connection\",e),e}))}catch(e){return Promise.reject(e)}},a.multiPayInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeMultiNip47Request(\"multi_pay_invoice\",e,e.invoices.length,function(e){return!!e.preimage})).then(function(e){return{invoices:e,errors:[]}})},function(e){throw console.error(\"Failed to request multi_pay_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.multiPayKeysend=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeMultiNip47Request(\"multi_pay_keysend\",e,e.keysends.length,function(e){return!!e.preimage})).then(function(e){return{keysends:e,errors:[]}})},function(e){throw console.error(\"Failed to request multi_pay_keysend\",e),e}))}catch(e){return Promise.reject(e)}},a.makeInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){if(!e.amount)throw new Error(\"No amount specified\");return Promise.resolve(t.executeNip47Request(\"make_invoice\",e,function(e){return!!e.invoice}))},function(e){throw console.error(\"Failed to request make_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.makeHoldInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){if(!e.amount)throw new Error(\"No amount specified\");if(!e.payment_hash)throw new Error(\"No payment hash specified\");return Promise.resolve(t.executeNip47Request(\"make_hold_invoice\",e,function(e){return!!e.invoice}))},function(e){throw console.error(\"Failed to request make_hold_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.settleHoldInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"settle_hold_invoice\",e,function(e){return!!e}))},function(e){throw console.error(\"Failed to request settle_hold_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.cancelHoldInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"cancel_hold_invoice\",e,function(e){return!!e}))},function(e){throw console.error(\"Failed to request cancel_hold_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.lookupInvoice=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"lookup_invoice\",e,function(e){return!!e.invoice}))},function(e){throw console.error(\"Failed to request lookup_invoice\",e),e}))}catch(e){return Promise.reject(e)}},a.listTransactions=function(e){try{var t=this;return Promise.resolve(ne(function(){return Promise.resolve(t.executeNip47Request(\"list_transactions\",e,function(e){return!!e.transactions},{replyTimeout:1e4}))},function(e){throw console.error(\"Failed to request list_transactions\",e),e}))}catch(e){return Promise.reject(e)}},a.subscribeNotifications=function(e,t){try{var n,r,o,i=this,s=!0;return function(){try{var u=function(e,t,n){for(var r;;){var o=e();if(ie(o)&&(o=o.v),!o)return i;if(o.then){r=0;break}var i=n();if(i&&i.then){if(!ie(i)){r=1;break}i=i.s}}var s=new oe,u=re.bind(null,s,2);return(0===r?o.then(a):1===r?i.then(c):(void 0).then(function(){(o=e())?o.then?o.then(a).then(void 0,u):a(o):re(s,1,i)})).then(void 0,u),s;function c(t){i=t;do{if(!(o=e())||ie(o)&&!o.v)return void re(s,1,i);if(o.then)return void o.then(a).then(void 0,u);ie(i=n())&&(i=i.v)}while(!i||!i.then);i.then(c).then(void 0,u)}function a(e){e?(i=n())&&i.then?i.then(c).then(void 0,u):c(i):re(s,1,i)}}(function(){return!!s},0,function(){function u(){var e=function(){if(s)return Promise.resolve(new Promise(function(e){return setTimeout(e,1e3)})).then(function(){})}();if(e&&e.then)return e.then(function(){})}var c=ne(function(){return Promise.resolve(i._checkConnected()).then(function(){return Promise.resolve(i._selectEncryptionType()).then(function(){return o=i.relay.subscribe([{kinds:[].concat(\"nip04\"===i.encryptionType?[23196]:[23197]),authors:[i.walletPubkey],\"#p\":[i.publicKey]}],{}),console.info(\"subscribed to relay\"),o.onevent=function(n){try{return Promise.resolve(i.decrypt(i.walletPubkey,n.content)).then(function(n){var r;try{r=JSON.parse(n)}catch(e){return void console.error(\"Failed to parse decrypted event content\",e)}r.notification?(!t||t.indexOf(r.notification_type)>-1)&&e(r):console.error(\"No notification in response\",r)})}catch(e){return Promise.reject(e)}},Promise.resolve(new Promise(function(e){n=function(){e()},i.relay.onclose=r=function(){console.info(\"relay disconnected\"),null==n||n()}})).then(function(){void 0!==r&&(i.relay.onclose=null)})})})},function(e){console.error(\"error subscribing to notifications\",e||\"unknown relay error\")});return c&&c.then?c.then(u):u()});u&&u.then&&u.then(function(){})}catch(e){Promise.reject(e)}}(),Promise.resolve(function(){var e;s=!1,null==n||n(),null==(e=o)||e.close()})}catch(e){return Promise.reject(e)}},a.executeNip47Request=function(e,t,n,r){try{var o=this;return Promise.resolve(o._checkConnected()).then(function(){return Promise.resolve(o._selectEncryptionType()).then(function(){return new Promise(function(i,s){try{return Promise.resolve(o.encrypt(o.walletPubkey,JSON.stringify({method:e,params:t}))).then(function(e){var t={kind:23194,created_at:Math.floor(Date.now()/1e3),tags:[[\"p\",o.walletPubkey],[\"v\",\"nip44_v2\"===o.encryptionType?\"1.0\":\"0.0\"],[\"encryption\",o.encryptionType]],content:e};return Promise.resolve(o.signEvent(t)).then(function(e){var t=o.relay.subscribe([{kinds:[23195],authors:[o.walletPubkey],\"#e\":[e.id]}],{}),u=setTimeout(function(){t.close(),s(new X(\"reply timeout: event \"+e.id,\"INTERNAL\"))},(null==r?void 0:r.replyTimeout)||6e4);t.onevent=function(e){try{return clearTimeout(u),t.close(),Promise.resolve(o.decrypt(o.walletPubkey,e.content)).then(function(e){var r,o,c;try{r=JSON.parse(e)}catch(e){return clearTimeout(u),t.close(),void s(new $(\"failed to deserialize response\",\"INTERNAL\"))}r.result?n(r.result)?i(r.result):(clearTimeout(u),t.close(),s(new Z(\"response from NWC failed validation: \"+JSON.stringify(r.result),\"INTERNAL\"))):(clearTimeout(u),t.close(),s(new G((null==(o=r.error)?void 0:o.message)||\"unknown Error\",(null==(c=r.error)?void 0:c.code)||\"INTERNAL\")))})}catch(e){return Promise.reject(e)}};var c=setTimeout(function(){t.close(),s(new Y(\"publish timeout: \"+e.id,\"INTERNAL\"))},(null==r?void 0:r.publishTimeout)||5e3),a=ne(function(){return Promise.resolve(o.relay.publish(e)).then(function(){clearTimeout(c)})},function(e){clearTimeout(c),s(new Q(\"failed to publish: \"+e,\"INTERNAL\"))});if(a&&a.then)return a.then(function(){})})})}catch(e){Promise.reject(e)}})})})}catch(e){return Promise.reject(e)}},a.executeMultiNip47Request=function(e,t,n,r,o){try{var i=this;return Promise.resolve(i._checkConnected()).then(function(){return Promise.resolve(i._selectEncryptionType()).then(function(){var s=[];return new Promise(function(u,c){try{return Promise.resolve(i.encrypt(i.walletPubkey,JSON.stringify({method:e,params:t}))).then(function(e){var t={kind:23194,created_at:Math.floor(Date.now()/1e3),tags:[[\"p\",i.walletPubkey],[\"v\",\"nip44_v2\"===i.encryptionType?\"1.0\":\"0.0\"],[\"encryption\",i.encryptionType]],content:e};return Promise.resolve(i.signEvent(t)).then(function(e){var t=i.relay.subscribe([{kinds:[23195],authors:[i.walletPubkey],\"#e\":[e.id]}],{}),a=setTimeout(function(){t.close(),c(new X(\"reply timeout: event \"+e.id,\"INTERNAL\"))},(null==o?void 0:o.replyTimeout)||6e4);t.onevent=function(e){try{return Promise.resolve(i.decrypt(i.walletPubkey,e.content)).then(function(o){var i;try{i=JSON.parse(o)}catch(e){clearTimeout(a),t.close(),c(new $(\"failed to deserialize response\",\"INTERNAL\"))}if(i.result){var l;if(!r(i.result))return clearTimeout(a),t.close(),void c(new Z(\"Response from NWC failed validation: \"+JSON.stringify(i.result),\"INTERNAL\"));var h=null==(l=e.tags.find(function(e){return\"d\"===e[0]}))?void 0:l[1];if(void 0===h)return clearTimeout(a),t.close(),void c(new Z(\"No d tag found in response event\",\"INTERNAL\"));s.push(d({},i.result,{dTag:h})),s.length===n&&(clearTimeout(a),t.close(),u(s))}else{var f,v;clearTimeout(a),t.close(),c(new ee(null==(f=i.error)?void 0:f.message,null==(v=i.error)?void 0:v.code))}})}catch(e){return Promise.reject(e)}};var l=setTimeout(function(){t.close(),c(new Y(\"Publish timeout: \"+e.id,\"INTERNAL\"))},(null==o?void 0:o.publishTimeout)||5e3),h=ne(function(){return Promise.resolve(i.relay.publish(e)).then(function(){clearTimeout(l)})},function(e){clearTimeout(l),c(new Q(\"Failed to publish: \"+e,\"INTERNAL\"))});if(h&&h.then)return h.then(function(){})})})}catch(e){Promise.reject(e)}})})})}catch(e){return Promise.reject(e)}},a._checkConnected=function(){try{var e=this;if(!e.secret)throw new Error(\"Missing secret key\");if(!e.relayUrl)throw new Error(\"Missing relay url\");return Promise.resolve(ne(function(){var t=function(){if(!e.relay.connected)return Promise.resolve(e.relay.connect()).then(function(){})}();if(t&&t.then)return t.then(function(){})},function(){throw console.error(\"failed to connect to relay\",e.relayUrl),new D(\"Failed to connect to \"+e.relayUrl,\"OTHER\")}))}catch(e){return Promise.reject(e)}},a._selectEncryptionType=function(){try{var e=this;return Promise.resolve(function(){if(!e._encryptionType)return Promise.resolve(e.getWalletServiceInfo()).then(function(t){var n=e._findPreferredEncryptionType(t.encryptions);if(!n)throw new te(\"no compatible encryption or version found between wallet and client\",\"UNSUPPORTED_ENCRYPTION\");\"nip04\"===n&&console.warn(\"NIP-04 encryption is about to be deprecated. Please upgrade your wallet service to use NIP-44 instead.\"),e._encryptionType=n})}())}catch(e){return Promise.reject(e)}},a._findPreferredEncryptionType=function(e){return e.includes(\"nip44_v2\")?\"nip44_v2\":e.includes(\"nip04\")?\"nip04\":null},f(c,[{key:\"nostrWalletConnectUrl\",get:function(){return this.getNostrWalletConnectUrl()}},{key:\"connected\",get:function(){return this.relay.connected}},{key:\"publicKey\",get:function(){if(!this.secret)throw new Error(\"Missing secret key\");return u(H(this.secret))}},{key:\"encryptionType\",get:function(){if(!this._encryptionType)throw new Error(\"Missing encryption or version\");return this._encryptionType}}]),c}(),ue={get_info:\"getInfo\",get_balance:\"getBalance\",make_invoice:\"makeInvoice\",pay_invoice:\"sendPayment\",pay_keysend:\"payKeysend\",lookup_invoice:\"lookupInvoice\",list_transactions:\"listTransactions\",multi_pay_invoice:\"sendMultiPayment\",multi_pay_keysend:\"multiKeysend\",sign_message:\"signMessage\"},ce=/*#__PURE__*/function(){function e(e){this._enabled=!1,this.client=void 0,this.subscribers=void 0,this.client=(null==e?void 0:e.client)||new se(e),this.subscribers={}}e.fromAuthorizationUrl=function(t,n,r){void 0===n&&(n={});try{return Promise.resolve(se.fromAuthorizationUrl(t,n,r)).then(function(t){return new e({client:t})})}catch(e){return Promise.reject(e)}};var t=e.prototype;return t.on=function(e,t){this.subscribers[e]=t},t.notify=function(e,t){var n=this.subscribers[e];n&&n(t)},t.getPublicKey=function(){return this.client.getPublicKey()},t.signEvent=function(e){return this.client.signEvent(e)},t.enable=function(){try{return this._enabled=!0,Promise.resolve()}catch(e){return Promise.reject(e)}},t.close=function(){return this.client.close()},t.getInfo=function(){try{var e=this;return Promise.resolve(e.checkEnabled()).then(function(){var t=[\"lightning\",\"nostr\"],n=\"Alby JS SDK\";return function(r,o){try{var i=Promise.resolve(e.client.getInfo()).then(function(r){var o={methods:r.methods.map(function(e){return ue[e]}),node:{alias:r.alias,pubkey:r.pubkey,color:r.color},supports:t,version:n};return e.notify(\"getInfo\",o),o})}catch(e){return o(e)}return i&&i.then?i.then(void 0,o):i}(0,function(e){return console.error(\"Using minimal getInfo\",e),{methods:[\"sendPayment\"],node:{},supports:t,version:n}})})}catch(e){return Promise.reject(e)}},t.getBalance=function(){try{var e=this;return Promise.resolve(e.checkEnabled()).then(function(){return Promise.resolve(e.client.getBalance()).then(function(t){var n={balance:Math.floor(t.balance/1e3),currency:\"sats\"};return e.notify(\"getBalance\",n),n})})}catch(e){return Promise.reject(e)}},t.sendPayment=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.payInvoice({invoice:e})).then(function(e){var n={preimage:e.preimage};return t.notify(\"sendPayment\",n),n})})}catch(e){return Promise.reject(e)}},t.sendPaymentAsync=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return t.client.payInvoice({invoice:e}),t.notify(\"sendPaymentAsync\",{}),{}})}catch(e){return Promise.reject(e)}},t.keysend=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.payKeysend(le(e))).then(function(e){var n={preimage:e.preimage};return t.notify(\"keysend\",n),n})})}catch(e){return Promise.reject(e)}},t.signMessage=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.signMessage({message:e})).then(function(e){var n={message:e.message,signature:e.signature};return t.notify(\"keysend\",n),n})})}catch(e){return Promise.reject(e)}},t.makeInvoice=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){var n,r=\"object\"==typeof e?e:void 0,o=+(null!=(n=null==r?void 0:r.amount)?n:e);if(!o)throw new Error(\"No amount specified\");return Promise.resolve(t.client.makeInvoice({amount:1e3*o,description:null==r?void 0:r.defaultMemo})).then(function(e){var n={paymentRequest:e.invoice};return t.notify(\"makeInvoice\",n),n})})}catch(e){return Promise.reject(e)}},t.lookupInvoice=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.lookupInvoice({invoice:e.paymentRequest,payment_hash:e.paymentHash})).then(function(e){var n={preimage:e.preimage,paymentRequest:e.invoice,paid:!!e.settled_at};return t.notify(\"lookupInvoice\",n),n})})}catch(e){return Promise.reject(e)}},t.listTransactions=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.listTransactions(e)).then(function(e){var n={transactions:e.transactions.map(ae)};return t.notify(\"listTransactions\",n),n})})}catch(e){return Promise.reject(e)}},t.sendMultiPayment=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.multiPayInvoice({invoices:e.map(function(e,t){return{invoice:e,id:t.toString()}})})).then(function(n){var r={payments:n.invoices.map(function(t){var n=e[parseInt(t.dTag)];if(!n)throw new Error(\"Could not find paymentRequest matching response d tag\");return{paymentRequest:n,preimage:t.preimage}}),errors:[]};return t.notify(\"sendMultiPayment\",r),r})})}catch(e){return Promise.reject(e)}},t.multiKeysend=function(e){try{var t=this;return Promise.resolve(t.checkEnabled()).then(function(){return Promise.resolve(t.client.multiPayKeysend({keysends:e.map(function(e,t){return d({},le(e),{id:t.toString()})})})).then(function(n){var r={keysends:n.keysends.map(function(t){var n=e[parseInt(t.dTag)];if(!n)throw new Error(\"Could not find keysend matching response d tag\");return{keysend:n,preimage:t.preimage}}),errors:[]};return t.notify(\"multiKeysend\",r),r})})}catch(e){return Promise.reject(e)}},t.lnurl=function(e){throw new Error(\"Method not implemented.\")},t.request=function(e,t){throw new Error(\"Method not implemented.\")},t.verifyMessage=function(e,t){throw new Error(\"Method not implemented.\")},t.checkEnabled=function(){try{if(!this._enabled)throw new Error(\"please call enable() and await the promise before calling this function\");return Promise.resolve()}catch(e){return Promise.reject(e)}},f(e,[{key:\"options\",get:function(){return this.client.options}}]),e}();function ae(e){return d({},e,{amount:Math.floor(e.amount/1e3),fees_paid:e.fees_paid?Math.floor(e.fees_paid/1e3):0})}function le(e){return{amount:1e3*+e.amount,pubkey:e.destination,tlv_records:e.customRecords?Object.entries(e.customRecords).map(function(e){return{type:parseInt(e[0]),value:I((new TextEncoder).encode(e[1]))}}):[]}}function he(e,t){try{var n=e()}catch(e){return t(!0,e)}return n&&n.then?n.then(t.bind(null,!1),t.bind(null,!0)):t(!1,n)}function fe(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}var de={__proto__:null,NostrWebLNProvider:ce,NWC:ce,OauthWeblnProvider:/*#__PURE__*/function(){function e(e){this.client=void 0,this.auth=void 0,this.oauth=void 0,this.subscribers=void 0,this.isExecuting=void 0,this.auth=e.auth,this.client=new L(e.auth),this.oauth=!0,this.subscribers={},this.isExecuting=!1}var t=e.prototype;return t.on=function(e,t){this.subscribers[e]=t},t.notify=function(e,t){var n=this.subscribers[e];n&&n(t)},t.enable=function(){try{var e,t=this;return t.isExecuting?Promise.resolve():null!=(e=t.auth.token)&&e.access_token?Promise.resolve({enabled:!0}):Promise.resolve(function(){if(\"undefined\"==typeof window||void 0===window.document)throw new Error(\"Missing access token\");var e=he(function(){return t.isExecuting=!0,Promise.resolve(t.openAuthorization()).then(function(){})},function(e,n){if(t.isExecuting=!1,e)throw n;return n});if(e&&e.then)return e.then(function(){})}())}catch(e){return Promise.reject(e)}},t.sendPayment=function(e){try{var t=this;return t.isExecuting?Promise.resolve():Promise.resolve(he(function(){return fe(function(){return t.isExecuting=!0,Promise.resolve(t.client.sendPayment({invoice:e})).then(function(e){return t.notify(\"sendPayment\",e),{preimage:e.payment_preimage}})},function(e){var t=\"Unknown Error\";throw e instanceof Error&&(t=e.message),new Error(t)})},function(e,n){if(t.isExecuting=!1,e)throw n;return n}))}catch(e){return Promise.reject(e)}},t.keysend=function(e){try{var t=this;return t.isExecuting?Promise.resolve():Promise.resolve(he(function(){return fe(function(){return t.isExecuting=!0,Promise.resolve(t.client.keysend(e)).then(function(e){return t.notify(\"keysend\",e),{preimage:e.payment_preimage}})},function(e){var t=\"Unknown Error\";throw e instanceof Error&&(t=e.message),new Error(t)})},function(e,n){if(t.isExecuting=!1,e)throw n;return n}))}catch(e){return Promise.reject(e)}},t.getInfo=function(){try{return Promise.resolve({alias:\"Alby\"})}catch(e){return Promise.reject(e)}},t.makeInvoice=function(e){try{var t=this;return t.isExecuting?Promise.resolve():Promise.resolve(he(function(){return fe(function(){return t.isExecuting=!0,Promise.resolve(t.client.createInvoice({amount:parseInt(e.amount.toString()),description:e.defaultMemo})).then(function(e){return t.notify(\"makeInvoice\",e),{paymentRequest:e.payment_request}})},function(e){var t=\"Unknown Error\";throw e instanceof Error&&(t=e.message),new Error(t)})},function(e,n){if(t.isExecuting=!1,e)throw n;return n}))}catch(e){return Promise.reject(e)}},t.openAuthorization=function(){try{var e=this,t=window.outerHeight/2+window.screenY-350,n=window.outerWidth/2+window.screenX-300;return Promise.resolve(e.auth.generateAuthURL({code_challenge_method:\"S256\"})).then(function(r){return new Promise(function(o,i){var s=window.open(r,document.title+\" - WebLN enable\",\"height=700,width=600,top=\"+t+\",left=\"+n),u=!1;window.addEventListener(\"message\",function(t){try{var n=t.data,r=function(){if(n&&\"alby:oauth:success\"===n.type&&t.origin===document.location.protocol+\"//\"+document.location.host&&!u){u=!0,console.info(\"Processing OAuth code response\");var r=n.payload.code,c=fe(function(){return Promise.resolve(e.auth.requestAccessToken(r)).then(function(){e.client=new L(e.auth),s&&s.close(),e.notify(\"enable\"),o({enabled:!0})})},function(e){console.error(e),i({enabled:!1})});if(c&&c.then)return c.then(function(){})}}();return Promise.resolve(r&&r.then?r.then(function(){}):void 0)}catch(e){return Promise.reject(e)}})})})}catch(e){return Promise.reject(e)}},e}()};function ve(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}function pe(e,t,n){if(!e.s){if(n instanceof me){if(!n.s)return void(n.o=pe.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(pe.bind(null,e,t),pe.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var me=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){var r=new e,o=this.s;if(o){var i=1&o?t:n;if(i){try{pe(r,1,i(this.v))}catch(e){pe(r,2,e)}return r}return this}return this.o=function(e){try{var o=e.v;1&e.s?pe(r,1,t?t(o):o):n?pe(r,1,n(o)):pe(r,2,o)}catch(e){pe(r,2,e)}},r},e}();function ye(e){return e instanceof me&&1&e.s}var Pe=/*#__PURE__*/function(){function t(t){if(this.options=void 0,this.appSecretKey=void 0,this.relay=void 0,this.appSecretKey=t.appSecretKey||J(s()),this.options=d({},t,{appPubkey:u(H(this.appSecretKey))}),!this.options.relayUrl)throw new Error(\"Missing relay url\");if(!this.options.requestMethods)throw new Error(\"Missing request methods\");this.relay=new e(this.options.relayUrl),void 0===globalThis.WebSocket&&console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\")}var n=t.prototype;return n.getConnectionUri=function(e){void 0===e&&(e=\"\");var t=new URLSearchParams(d({relay:this.options.relayUrl,request_methods:this.options.requestMethods.join(\" \")},this.options.name?{name:this.options.name}:{},this.options.icon?{icon:this.options.icon}:{},this.options.returnTo?{return_to:this.options.returnTo}:{},this.options.notificationTypes?{notification_types:this.options.notificationTypes.join(\" \")}:{},this.options.maxAmount?{max_amount:this.options.maxAmount.toString()}:{},this.options.budgetRenewal?{budget_renewal:this.options.budgetRenewal}:{},this.options.expiresAt?{expires_at:this.options.expiresAt.toString()}:{},this.options.isolated?{isolated:this.options.isolated.toString()}:{},this.options.metadata?{metadata:JSON.stringify(this.options.metadata)}:{}));return\"nostr+walletauth\"+(e?\"+\"+e:\"\")+\"://\"+this.options.appPubkey+\"?\"+t.toString().replace(/\\+/g,\"%20\")},t.parseWalletAuthUrl=function(e){var t,n;if(!e.startsWith(\"nostr+walletauth\"))throw new Error(\"Unexpected scheme. Should be nostr+walletauth:// or nostr+walletauth+specificapp://\");var r=e.indexOf(\":\");(e=e.substring(r+1)).startsWith(\"//\")&&(e=e.substring(2)),e=\"http://\"+e;var o=new URL(e),i=o.host;if(64!==(null==i?void 0:i.length))throw new Error(\"Incorrect app pubkey found in auth string\");var s=o.searchParams.get(\"relay\");if(!s)throw new Error(\"No relay URL found in auth string\");var u=null==(t=o.searchParams.get(\"request_methods\"))?void 0:t.split(\" \");if(null==u||!u.length)throw new Error(\"No request methods found in auth string\");var c=null==(n=o.searchParams.get(\"notification_types\"))?void 0:n.split(\" \"),a=o.searchParams.get(\"max_amount\"),l=o.searchParams.get(\"expires_at\"),h=o.searchParams.get(\"metadata\");return{name:o.searchParams.get(\"name\")||void 0,icon:o.searchParams.get(\"icon\")||void 0,returnTo:o.searchParams.get(\"return_to\")||void 0,relayUrl:s,appPubkey:i,requestMethods:u,notificationTypes:c,budgetRenewal:o.searchParams.get(\"budget_renewal\"),expiresAt:l?parseInt(l):void 0,maxAmount:a?parseInt(a):void 0,isolated:\"true\"===o.searchParams.get(\"isolated\"),metadata:h?JSON.parse(h):void 0}},n.subscribe=function(e){try{var t,n,r=this,o=!0;return function(){try{var i=function(e,t,n){for(var r;;){var o=e();if(ye(o)&&(o=o.v),!o)return i;if(o.then){r=0;break}var i=n();if(i&&i.then){if(!ye(i)){r=1;break}i=i.s}}var s=new me,u=pe.bind(null,s,2);return(0===r?o.then(a):1===r?i.then(c):(void 0).then(function(){(o=e())?o.then?o.then(a).then(void 0,u):a(o):pe(s,1,i)})).then(void 0,u),s;function c(t){i=t;do{if(!(o=e())||ye(o)&&!o.v)return void pe(s,1,i);if(o.then)return void o.then(a).then(void 0,u);ye(i=n())&&(i=i.v)}while(!i||!i.then);i.then(c).then(void 0,u)}function a(e){e?(i=n())&&i.then?i.then(c).then(void 0,u):c(i):pe(s,1,i)}}(function(){return!!o},0,function(){function i(){var e=function(){if(o)return Promise.resolve(new Promise(function(e){return setTimeout(e,1e3)})).then(function(){})}();if(e&&e.then)return e.then(function(){})}var s=ve(function(){return Promise.resolve(r._checkConnected()).then(function(){var o=r.relay.subscribe([{kinds:[13194],\"#p\":[r.options.appPubkey]}],{});return console.info(\"subscribed to relay\"),o.onevent=function(t){try{var n=function(){e.onSuccess(i),o.close(),r.relay.close()},i=new se({relayUrl:r.options.relayUrl,secret:r.appSecretKey,walletPubkey:t.pubkey}),s=ve(function(){return Promise.resolve(i.getInfo()).then(function(e){i.options.lud16=e.lud16,i.lud16=e.lud16})},function(e){console.error(\"failed to fetch get_info\",e)});return Promise.resolve(s&&s.then?s.then(n):n())}catch(e){return Promise.reject(e)}},Promise.resolve(new Promise(function(e){t=function(){e()},r.relay.onclose=n=function(){console.info(\"relay disconnected\"),null==t||t()}})).then(function(){void 0!==n&&(r.relay.onclose=null)})})},function(e){console.error(\"error subscribing to info event\",e||\"unknown relay error\")});return s&&s.then?s.then(i):i()});i&&i.then&&i.then(function(){})}catch(e){Promise.reject(e)}}(),Promise.resolve({unsub:function(){o=!1,null==t||t()}})}catch(e){return Promise.reject(e)}},n._checkConnected=function(){try{var e=this;if(!e.appSecretKey)throw new Error(\"Missing secret key\");if(!e.options.relayUrl)throw new Error(\"Missing relay url\");return Promise.resolve(ve(function(){var t=function(){if(!e.relay.connected)return Promise.resolve(e.relay.connect()).then(function(){})}();if(t&&t.then)return t.then(function(){})},function(){throw console.error(\"failed to connect to relay\",e.options.relayUrl),new D(\"Failed to connect to \"+e.options.relayUrl,\"OTHER\")}))}catch(e){return Promise.reject(e)}},f(t,[{key:\"connectionUri\",get:function(){return this.getConnectionUri()}}]),t}();function we(e,t){try{var n=e()}catch(e){return t(e)}return n&&n.then?n.then(void 0,t):n}function ge(e,t,n){if(!e.s){if(n instanceof be){if(!n.s)return void(n.o=ge.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(ge.bind(null,e,t),ge.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var be=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){var r=new e,o=this.s;if(o){var i=1&o?t:n;if(i){try{ge(r,1,i(this.v))}catch(e){ge(r,2,e)}return r}return this}return this.o=function(e){try{var o=e.v;1&e.s?ge(r,1,t?t(o):o):n?ge(r,1,n(o)):ge(r,2,o)}catch(e){ge(r,2,e)}},r},e}();function _e(e){return e instanceof be&&1&e.s}var ke=/*#__PURE__*/function(){function t(t){this.relay=void 0,this.relayUrl=void 0,this.relayUrl=t.relayUrl,this.relay=new e(this.relayUrl),void 0===globalThis.WebSocket&&console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\")}var r=t.prototype;return r.publishWalletServiceInfoEvent=function(e,t,n){try{var r=this;return Promise.resolve(we(function(){return Promise.resolve(r._checkConnected()).then(function(){var o={kind:13194,created_at:Math.floor(Date.now()/1e3),tags:[[\"encryption\",\"nip04 nip44_v2\"],[\"notifications\",n.join(\" \")]],content:t.join(\" \")};return Promise.resolve(r.signEvent(o,e)).then(function(e){return Promise.resolve(r.relay.publish(e)).then(function(){})})})},function(e){throw console.error(\"failed to publish wallet service info event\",e),e}))}catch(e){return Promise.reject(e)}},r.subscribe=function(e,t){try{var n,r,o,i=this,s=!0;return function(){try{var u=function(e,t,n){for(var r;;){var o=e();if(_e(o)&&(o=o.v),!o)return i;if(o.then){r=0;break}var i=n();if(i&&i.then){if(!_e(i)){r=1;break}i=i.s}}var s=new be,u=ge.bind(null,s,2);return(0===r?o.then(a):1===r?i.then(c):(void 0).then(function(){(o=e())?o.then?o.then(a).then(void 0,u):a(o):ge(s,1,i)})).then(void 0,u),s;function c(t){i=t;do{if(!(o=e())||_e(o)&&!o.v)return void ge(s,1,i);if(o.then)return void o.then(a).then(void 0,u);_e(i=n())&&(i=i.v)}while(!i||!i.then);i.then(c).then(void 0,u)}function a(e){e?(i=n())&&i.then?i.then(c).then(void 0,u):c(i):ge(s,1,i)}}(function(){return!!s},0,function(){function u(){var e=function(){if(s)return Promise.resolve(new Promise(function(e){return setTimeout(e,1e3)})).then(function(){})}();if(e&&e.then)return e.then(function(){})}var c=we(function(){return console.info(\"checking connection to relay\"),Promise.resolve(i._checkConnected()).then(function(){return console.info(\"subscribing to relay\"),o=i.relay.subscribe([{kinds:[23194],authors:[e.clientPubkey],\"#p\":[e.walletPubkey]}],{}),console.info(\"subscribed to relay\"),o.onevent=function(n){try{var r=we(function(){var r,o=(null==(r=n.tags.find(function(e){return\"encryption\"===e[0]}))?void 0:r[1])||\"nip04\";return Promise.resolve(i.decrypt(e,n.content,o)).then(function(r){var s,u=JSON.parse(r);switch(u.method){case\"get_info\":s=null==t.getInfo?void 0:t.getInfo();break;case\"make_invoice\":s=null==t.makeInvoice?void 0:t.makeInvoice(u.params);break;case\"pay_invoice\":s=null==t.payInvoice?void 0:t.payInvoice(u.params);break;case\"pay_keysend\":s=null==t.payKeysend?void 0:t.payKeysend(u.params);break;case\"get_balance\":s=null==t.getBalance?void 0:t.getBalance();break;case\"lookup_invoice\":s=null==t.lookupInvoice?void 0:t.lookupInvoice(u.params);break;case\"list_transactions\":s=null==t.listTransactions?void 0:t.listTransactions(u.params);break;case\"sign_message\":s=null==t.signMessage?void 0:t.signMessage(u.params)}return Promise.resolve(s).then(function(t){t||(console.warn(\"received unsupported method\",u.method),t={error:{code:\"NOT_IMPLEMENTED\",message:\"This method is not supported by the wallet service\"},result:void 0});var r=[[\"e\",n.id]],s=Math.floor(Date.now()/1e3);return Promise.resolve(i.encrypt(e,JSON.stringify(d({result_type:u.method},t)),o)).then(function(t){return Promise.resolve(i.signEvent({kind:23195,created_at:s,tags:r,content:t},e.walletSecret)).then(function(e){return Promise.resolve(i.relay.publish(e)).then(function(){})})})})})},function(e){console.error(\"Failed to parse decrypted event content\",e)});return Promise.resolve(r&&r.then?r.then(function(){}):void 0)}catch(e){return Promise.reject(e)}},Promise.resolve(new Promise(function(e){n=function(){e()},i.relay.onclose=r=function(){console.error(\"relay disconnected\"),null==n||n()}})).then(function(){void 0!==r&&(i.relay.onclose=null)})})},function(e){console.error(\"error subscribing to requests\",e||\"unknown relay error\")});return c&&c.then?c.then(u):u()});u&&u.then&&u.then(function(){})}catch(e){Promise.reject(e)}}(),Promise.resolve(function(){var e;s=!1,null==n||n(),null==(e=o)||e.close()})}catch(e){return Promise.reject(e)}},r.signEvent=function(e,t){return Promise.resolve(n(e,H(t)))},r.close=function(){return this.relay.close()},r.encrypt=function(e,t,n){try{var r,s=function(){if(\"nip04\"===n)return Promise.resolve(o.encrypt(e.walletSecret,e.clientPubkey,t)).then(function(e){r=e});var s=i.getConversationKey(H(e.walletSecret),e.clientPubkey);r=i.encrypt(t,s)}();return Promise.resolve(s&&s.then?s.then(function(){return r}):r)}catch(e){return Promise.reject(e)}},r.decrypt=function(e,t,n){try{var r,s=function(){if(\"nip04\"===n)return Promise.resolve(o.decrypt(e.walletSecret,e.clientPubkey,t)).then(function(e){r=e});var s=i.getConversationKey(H(e.walletSecret),e.clientPubkey);r=i.decrypt(t,s)}();return Promise.resolve(s&&s.then?s.then(function(){return r}):r)}catch(e){return Promise.reject(e)}},r._checkConnected=function(){try{var e=this;if(!e.relayUrl)throw new Error(\"Missing relay url\");return Promise.resolve(we(function(){var t=function(){if(!e.relay.connected)return Promise.resolve(e.relay.connect()).then(function(){})}();if(t&&t.then)return t.then(function(){})},function(){throw console.error(\"failed to connect to relay\",e.relayUrl),new D(\"Failed to connect to \"+e.relayUrl,\"OTHER\")}))}catch(e){return Promise.reject(e)}},f(t,[{key:\"connected\",get:function(){return this.relay.connected}}]),t}(),Ee={__proto__:null,Nip47Error:z,Nip47NetworkError:D,Nip47WalletError:G,Nip47TimeoutError:V,Nip47PublishTimeoutError:Y,Nip47ReplyTimeoutError:X,Nip47PublishError:Q,Nip47ResponseDecodingError:$,Nip47ResponseValidationError:Z,Nip47UnexpectedResponseError:ee,Nip47UnsupportedEncryptionError:te,NWCClient:se,NWAClient:Pe,NWCWalletServiceKeyPair:function(e,t){if(this.walletSecret=void 0,this.walletPubkey=void 0,this.clientPubkey=void 0,this.walletSecret=e,this.clientPubkey=t,!this.walletSecret)throw new Error(\"Missing wallet secret key\");if(!this.clientPubkey)throw new Error(\"Missing client pubkey\");this.walletPubkey=u(H(this.walletSecret))},NWCWalletService:ke};function Te(e,t,n){if(!e.s){if(n instanceof Ne){if(!n.s)return void(n.o=Te.bind(null,e,t));1&t&&(t=n.s),n=n.v}if(n&&n.then)return void n.then(Te.bind(null,e,t),Te.bind(null,e,2));e.s=t,e.v=n;var r=e.o;r&&r(e)}}var Ne=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,n){var r=new e,o=this.s;if(o){var i=1&o?t:n;if(i){try{Te(r,1,i(this.v))}catch(e){Te(r,2,e)}return r}return this}return this.o=function(e){try{var o=e.v;1&e.s?Te(r,1,t?t(o):o):n?Te(r,1,n(o)):Te(r,2,o)}catch(e){Te(r,2,e)}},r},e}();function je(e){return e instanceof Ne&&1&e.s}var qe=/*#__PURE__*/function(){function e(e,t){this.transaction=void 0,this.invoice=void 0,this._nwcClient=void 0,this._unsubscribeFunc=void 0,this._timeoutFunc=void 0,this._timeoutId=void 0,this.transaction=t,this.invoice=new c({pr:t.invoice}),this._nwcClient=e}var t=e.prototype;return t.onPaid=function(e){var t=this;return function(){try{var n,r=function(){var r=function(n){null==t._unsubscribeFunc||t._unsubscribeFunc(),e(n)},o=function(e){return function(){t._timeoutFunc=void 0,clearTimeout(t._timeoutId),e()}},i=function(){if(n)return Promise.resolve(t._nwcClient.subscribeNotifications(function(e){e.notification.payment_hash===t.transaction.payment_hash&&r(e.notification)},[\"payment_received\"])).then(function(e){t._unsubscribeFunc=o(e)});console.warn(\"current connection does not support notifications, falling back to polling\"),t._unsubscribeFunc=o(t._onPaidPollingFallback(r))}();if(i&&i.then)return i.then(function(){})},o=function(e,r){try{var o=Promise.resolve(t._nwcClient.getInfo()).then(function(e){var t;n=null==(t=e.notifications)?void 0:t.includes(\"payment_received\")})}catch(e){return r()}return o&&o.then?o.then(void 0,r):o}(0,function(){console.error(\"failed to fetch info, falling back to polling\")});o&&o.then?o.then(r):r()}catch(e){Promise.reject(e)}}(),this},t.onTimeout=function(e,t){var n=this;return this._timeoutFunc=function(){null==n._unsubscribeFunc||n._unsubscribeFunc(),t()},this._timeoutId=setTimeout(function(){null==n._timeoutFunc||n._timeoutFunc()},1e3*e),this},t.unsubscribe=function(){var e;null==(e=this._unsubscribeFunc)||e.call(this)},t._onPaidPollingFallback=function(e){var t=this,n=!0;return function(r){try{var o=function(e,t,n){for(var r;;){var o=e();if(je(o)&&(o=o.v),!o)return i;if(o.then){r=0;break}var i=n();if(i&&i.then){if(!je(i)){r=1;break}i=i.s}}var s=new Ne,u=Te.bind(null,s,2);return(0===r?o.then(a):1===r?i.then(c):(void 0).then(function(){(o=e())?o.then?o.then(a).then(void 0,u):a(o):Te(s,1,i)})).then(void 0,u),s;function c(t){i=t;do{if(!(o=e())||je(o)&&!o.v)return void Te(s,1,i);if(o.then)return void o.then(a).then(void 0,u);je(i=n())&&(i=i.v)}while(!i||!i.then);i.then(c).then(void 0,u)}function a(e){e?(i=n())&&i.then?i.then(c).then(void 0,u):c(i):Te(s,1,i)}}(function(){return!r&&!!n},0,function(){return Promise.resolve(t._nwcClient.lookupInvoice({payment_hash:t.transaction.payment_hash})).then(function(t){return t.settled_at&&t.preimage?(e(t),n=!1,void(r=1)):Promise.resolve(new Promise(function(e){return setTimeout(e,3e3)})).then(function(){})})});o&&o.then&&o.then(function(){})}catch(e){Promise.reject(e)}}(),function(){n=!1}},e}(),Re=function(e){try{return\"number\"==typeof e?Promise.resolve({satoshi:e,millisat:1e3*e}):Promise.resolve(Promise.resolve(e.satoshi)).then(function(e){return{satoshi:e,millisat:1e3*e}})}catch(e){return Promise.reject(e)}},Se=function(e){return{satoshi:e}},Oe=/*#__PURE__*/function(){function e(e){this.nwcClient=void 0,this.nwcClient=\"string\"==typeof e?new se({nostrWalletConnectUrl:e}):e instanceof se?e:new se(e)}var t=e.prototype;return t.pay=function(e,t,n){try{var r=function(t){function r(e){return Promise.resolve(o.nwcClient.payInvoice(d({},n||{},{invoice:i,amount:null==t?void 0:t.millisat}))).then(function(e){return d({},e,{invoice:new c({pr:i})})})}var s=function(){if(i.indexOf(\"@\")>-1){if(!t)throw new Error(\"Amount must be provided when paying to a lightning address\");var r=new a(e);return Promise.resolve(r.fetch()).then(function(){var e,o;return Promise.resolve(r.requestInvoice({satoshi:t.satoshi,comment:null==n||null==(e=n.metadata)?void 0:e.comment,payerdata:null==n||null==(o=n.metadata)?void 0:o.payer_data})).then(function(e){i=e.paymentRequest})})}}();return s&&s.then?s.then(r):r()},o=this,i=e;return Promise.resolve(t?Promise.resolve(Re(t)).then(r):r(void 0))}catch(e){return Promise.reject(e)}},t.requestPayment=function(e,t){try{var n=this;return Promise.resolve(Re(e)).then(function(e){return Promise.resolve(n.nwcClient.makeInvoice(d({},t||{},{amount:e.millisat}))).then(function(e){return new qe(n.nwcClient,e)})})}catch(e){return Promise.reject(e)}},t.close=function(){this.nwcClient.close()},e}(),Ie=function(e,t){this.satoshi=void 0,this.satoshi=l.getSatoshiValue({amount:e,currency:t})},xe=function(e){return new Ie(e,\"USD\")},Ae=function(e){return new Ie(e,\"EUR\")},Ue=function(e){return new Ie(e,\"JPY\")},Ce=function(e){return new Ie(e,\"GBP\")},Me=function(e){return new Ie(e,\"CHF\")};export{Me as CHF,Ae as EUR,Ie as FiatAmount,Ce as GBP,Ue as JPY,Oe as LN,Oe as LNClient,qe as ReceiveInvoice,Se as SATS,xe as USD,Ee as nwc,K as oauth,Re as resolveAmount,de as webln};\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\nimport { schnorr } from \"@noble/curves/secp256k1\";\nimport { bytesToHex as bytesToHex2 } from \"@noble/hashes/utils\";\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] !== \"string\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\nimport { sha256 } from \"@noble/hashes/sha256\";\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  bytesToHex: () => bytesToHex,\n  hexToBytes: () => hexToBytes,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  try {\n    if (url.indexOf(\"://\") === -1)\n      url = \"wss://\" + url;\n    let p = new URL(url);\n    p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n    if (p.pathname.endsWith(\"/\"))\n      p.pathname = p.pathname.slice(0, -1);\n    if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n      p.port = \"\";\n    p.searchParams.sort();\n    p.hash = \"\";\n    return p.toString();\n  } catch (e) {\n    throw new Error(`Invalid URL: ${url}`);\n  }\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    if (this.first) {\n      this.first.prev = null;\n    }\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return bytesToHex2(schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = bytesToHex2(schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)));\n  return bytesToHex2(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isAddressableKind: () => isAddressableKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isAddressableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isAddressableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isAddressableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar SendingOnClosedConnection = class extends Error {\n  constructor(message, relay) {\n    super(`Tried to send message '${message} on a closed connection to ${relay}.`);\n    this.name = \"SendingOnClosedConnection\";\n  }\n};\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  authPromise;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.authPromise = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        clearTimeout(this.connectionTimeoutHandle);\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        clearTimeout(this.connectionTimeoutHandle);\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = (ev) => {\n        clearTimeout(this.connectionTimeoutHandle);\n        reject(ev.message || \"websocket closed\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            clearTimeout(ep.timeout);\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new SendingOnClosedConnection(message, this.url);\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    const challenge = this.challenge;\n    if (!challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    if (this.authPromise)\n      return this.authPromise;\n    this.authPromise = new Promise(async (resolve, reject) => {\n      try {\n        let evt = await signAuthEvent(makeAuthEvent(this.url, challenge));\n        let timeout = setTimeout(() => {\n          let ep = this.openEventPublishes.get(evt.id);\n          if (ep) {\n            ep.reject(new Error(\"auth timed out\"));\n            this.openEventPublishes.delete(evt.id);\n          }\n        }, this.publishTimeout);\n        this.openEventPublishes.set(evt.id, { resolve, reject, timeout });\n        this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n      } catch (err) {\n        console.warn(\"subscribe auth function failed:\", err);\n      }\n    });\n    return this.authPromise;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(event.id);\n        if (ep) {\n          ep.reject(new Error(\"publish timed out\"));\n          this.openEventPublishes.delete(event.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(event.id, { resolve, reject, timeout });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || (params.label ? params.label + \":\" : \"sub:\") + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      try {\n        this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      } catch (err) {\n        if (err instanceof SendingOnClosedConnection) {\n        } else {\n          throw err;\n        }\n      }\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribe(relays, filter, params) {\n    params.onauth = params.onauth || params.doauth;\n    return this.subscribeMap(\n      relays.map((url) => ({ url, filter })),\n      params\n    );\n  }\n  subscribeMany(relays, filters, params) {\n    params.onauth = params.onauth || params.doauth;\n    return this.subscribeMap(\n      relays.flatMap((url) => filters.map((filter) => ({ url, filter }))),\n      params\n    );\n  }\n  subscribeMap(requests, params) {\n    params.onauth = params.onauth || params.doauth;\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === requests.length) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === requests.length) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      requests.map(async ({ url, filter }, i2) => {\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe([filter], {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required: \") && params.onauth) {\n              relay.auth(params.onauth).then(() => {\n                relay.subscribe([filter], {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close(reason) {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close(reason);\n        });\n      }\n    };\n  }\n  subscribeEose(relays, filter, params) {\n    params.onauth = params.onauth || params.doauth;\n    const subcloser = this.subscribe(relays, filter, {\n      ...params,\n      oneose() {\n        subcloser.close(\"closed automatically on eose\");\n      }\n    });\n    return subcloser;\n  }\n  subscribeManyEose(relays, filters, params) {\n    params.onauth = params.onauth || params.doauth;\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close(\"closed automatically on eose\");\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeEose(relays, filter, {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event, options) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).catch(async (err) => {\n        if (err instanceof Error && err.message.startsWith(\"auth-required: \") && options?.onauth) {\n          await r.auth(options.onauth);\n          return r.publish(event);\n        }\n        throw err;\n      }).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  decodeNostrURI: () => decodeNostrURI,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\nimport { bytesToHex as bytesToHex3, concatBytes, hexToBytes as hexToBytes2 } from \"@noble/hashes/utils\";\nimport { bech32 } from \"@scure/base\";\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decodeNostrURI(nip19code) {\n  try {\n    if (nip19code.startsWith(\"nostr:\"))\n      nip19code = nip19code.substring(6);\n    return decode(nip19code);\n  } catch (_err) {\n    return { type: \"invalid\", data: null };\n  }\n}\nfunction decode(code) {\n  let { prefix, words } = bech32.decode(code, Bech32MaxSize);\n  let data = new Uint8Array(bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: bytesToHex3(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: bytesToHex3(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? bytesToHex3(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt(bytesToHex3(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: bytesToHex3(tlv[2][0]),\n          kind: parseInt(bytesToHex3(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: bytesToHex3(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", hexToBytes2(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", hexToBytes2(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = bech32.toWords(data);\n  return bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [hexToBytes2(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [hexToBytes2(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [hexToBytes2(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [hexToBytes2(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return concatBytes(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\nimport { bytesToHex as bytesToHex4, randomBytes } from \"@noble/hashes/utils\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { cbc } from \"@noble/ciphers/aes\";\nimport { base64 } from \"@scure/base\";\nfunction encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? bytesToHex4(secretKey) : secretKey;\n  const key = secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from(randomBytes(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nfunction decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? bytesToHex4(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = base64.decode(ivb64);\n  let ciphertext = base64.decode(ctb64);\n  let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\nimport { bytesToHex as bytesToHex5 } from \"@noble/hashes/utils\";\nimport { sha256 as sha2562 } from \"@noble/hashes/sha256\";\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return bytesToHex5(\n    sha2562(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip17.ts\nvar nip17_exports = {};\n__export(nip17_exports, {\n  unwrapEvent: () => unwrapEvent2,\n  unwrapManyEvents: () => unwrapManyEvents2,\n  wrapEvent: () => wrapEvent2,\n  wrapManyEvents: () => wrapManyEvents2\n});\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\nimport { chacha20 } from \"@noble/ciphers/chacha\";\nimport { equalBytes } from \"@noble/ciphers/utils\";\nimport { secp256k1 as secp256k12 } from \"@noble/curves/secp256k1\";\nimport { extract as hkdf_extract, expand as hkdf_expand } from \"@noble/hashes/hkdf\";\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha256 as sha2563 } from \"@noble/hashes/sha256\";\nimport { concatBytes as concatBytes2, randomBytes as randomBytes2 } from \"@noble/hashes/utils\";\nimport { base64 as base642 } from \"@scure/base\";\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = secp256k12.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return hkdf_extract(sha2563, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = hkdf_expand(sha2563, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return concatBytes2(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = concatBytes2(aad, message);\n  return hmac(sha2563, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = base642.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = randomBytes2(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = chacha20(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return base642.encode(concatBytes2(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!equalBytes(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = chacha20(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip59.ts\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip17.ts\nfunction createEvent(recipients, message, conversationTitle, replyTo) {\n  const baseEvent = {\n    created_at: Math.ceil(Date.now() / 1e3),\n    kind: PrivateDirectMessage,\n    tags: [],\n    content: message\n  };\n  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];\n  recipientsArray.forEach(({ publicKey, relayUrl }) => {\n    baseEvent.tags.push(relayUrl ? [\"p\", publicKey, relayUrl] : [\"p\", publicKey]);\n  });\n  if (replyTo) {\n    baseEvent.tags.push([\"e\", replyTo.eventId, replyTo.relayUrl || \"\", \"reply\"]);\n  }\n  if (conversationTitle) {\n    baseEvent.tags.push([\"subject\", conversationTitle]);\n  }\n  return baseEvent;\n}\nfunction wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {\n  const event = createEvent(recipient, message, conversationTitle, replyTo);\n  return wrapEvent(event, senderPrivateKey, recipient.publicKey);\n}\nfunction wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {\n  if (!recipients || recipients.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  return [{ publicKey: senderPublicKey }, ...recipients].map(\n    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)\n  );\n}\nvar unwrapEvent2 = unwrapEvent;\nvar unwrapManyEvents2 = unwrapManyEvents;\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  let kind;\n  const tags = [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]];\n  if (reposted.kind === ShortTextNote) {\n    kind = Repost;\n  } else {\n    kind = GenericRepost;\n    tags.push([\"k\", String(reposted.kind)]);\n  }\n  return finalizeEvent(\n    {\n      kind,\n      tags,\n      content: t.content === \"\" || reposted.tags?.find((tag) => tag[0] === \"-\") ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (![Repost, GenericRepost].includes(event.kind)) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  parse: () => parse3\n});\nvar noCharacter = /\\W/m;\nvar noURLCharacter = /\\W |\\W$|$|,| /m;\nfunction* parse3(content) {\n  const max = content.length;\n  let prevIndex = 0;\n  let index = 0;\n  while (index < max) {\n    let u = content.indexOf(\":\", index);\n    if (u === -1) {\n      break;\n    }\n    if (content.substring(u - 5, u) === \"nostr\") {\n      const m = content.substring(u + 60).match(noCharacter);\n      const end = m ? u + 60 + m.index : max;\n      try {\n        let pointer;\n        let { data, type } = decode(content.substring(u + 1, end));\n        switch (type) {\n          case \"npub\":\n            pointer = { pubkey: data };\n            break;\n          case \"nsec\":\n          case \"note\":\n            index = end + 1;\n            continue;\n          default:\n            pointer = data;\n        }\n        if (prevIndex !== u - 5) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - 5) };\n        }\n        yield { type: \"reference\", pointer };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = u + 1;\n        continue;\n      }\n    } else if (content.substring(u - 5, u) === \"https\" || content.substring(u - 4, u) === \"http\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 5 : 4;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        if (url.pathname.endsWith(\".png\") || url.pathname.endsWith(\".jpg\") || url.pathname.endsWith(\".jpeg\") || url.pathname.endsWith(\".gif\") || url.pathname.endsWith(\".webp\")) {\n          yield { type: \"image\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp4\") || url.pathname.endsWith(\".avi\") || url.pathname.endsWith(\".webm\") || url.pathname.endsWith(\".mkv\")) {\n          yield { type: \"video\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp3\") || url.pathname.endsWith(\".aac\") || url.pathname.endsWith(\".ogg\") || url.pathname.endsWith(\".opus\")) {\n          yield { type: \"audio\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        yield { type: \"url\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else if (content.substring(u - 3, u) === \"wss\" || content.substring(u - 2, u) === \"ws\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 3 : 2;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid ws url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        yield { type: \"relay\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else {\n      index = u + 1;\n      continue;\n    }\n  }\n  if (prevIndex !== max) {\n    yield { type: \"text\", text: content.substring(prevIndex) };\n  }\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip54.ts\nvar nip54_exports = {};\n__export(nip54_exports, {\n  normalizeIdentifier: () => normalizeIdentifier\n});\nfunction normalizeIdentifier(name) {\n  name = name.trim().toLowerCase();\n  name = name.normalize(\"NFKC\");\n  return Array.from(name).map((char) => {\n    if (/\\p{Letter}/u.test(char) || /\\p{Number}/u.test(char)) {\n      return char;\n    }\n    return \"-\";\n  }).join(\"\");\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getSatoshisAmountFromBolt11: () => getSatoshisAmountFromBolt11,\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\nimport { bech32 as bech322 } from \"@scure/base\";\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = bech322.decode(lud06, 1e3);\n      let data = bech322.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event && typeof event === \"string\") {\n    zr.tags.push([\"e\", event]);\n  }\n  if (event && typeof event === \"object\") {\n    if (isReplaceableKind(event.kind)) {\n      const a = [\"a\", `${event.kind}:${event.pubkey}:`];\n      zr.tags.push(a);\n    } else if (isAddressableKind(event.kind)) {\n      let d = event.tags.find(([t, v]) => t === \"d\" && v);\n      if (!d)\n        throw new Error(\"d tag not found or is empty\");\n      const a = [\"a\", `${event.kind}:${event.pubkey}:${d[1]}`];\n      zr.tags.push(a);\n    }\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\nfunction getSatoshisAmountFromBolt11(bolt11) {\n  if (bolt11.length < 50) {\n    return 0;\n  }\n  bolt11 = bolt11.substring(0, 50);\n  const idx = bolt11.lastIndexOf(\"1\");\n  if (idx === -1) {\n    return 0;\n  }\n  const hrp = bolt11.substring(0, idx);\n  if (!hrp.startsWith(\"lnbc\")) {\n    return 0;\n  }\n  const amount = hrp.substring(4);\n  if (amount.length < 1) {\n    return 0;\n  }\n  const char = amount[amount.length - 1];\n  const digit = char.charCodeAt(0) - \"0\".charCodeAt(0);\n  const isDigit = digit >= 0 && digit <= 9;\n  let cutPoint = amount.length - 1;\n  if (isDigit) {\n    cutPoint++;\n  }\n  if (cutPoint < 1) {\n    return 0;\n  }\n  const num = parseInt(amount.substring(0, cutPoint));\n  switch (char) {\n    case \"m\":\n      return num * 1e5;\n    case \"u\":\n      return num * 100;\n    case \"n\":\n      return num / 10;\n    case \"p\":\n      return num / 1e4;\n    default:\n      return num * 1e8;\n  }\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\nimport { sha256 as sha2564 } from \"@noble/hashes/sha256\";\nimport { bytesToHex as bytesToHex6 } from \"@noble/hashes/utils\";\nimport { base64 as base643 } from \"@scure/base\";\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + base643.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(base643.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = sha2564(utf8Encoder.encode(JSON.stringify(payload)));\n  return bytesToHex6(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\nexport {\n  Relay,\n  SimplePool,\n  finalizeEvent,\n  fakejson_exports as fj,\n  generateSecretKey,\n  getEventHash,\n  getFilterLimit,\n  getPublicKey,\n  kinds_exports as kinds,\n  matchFilter,\n  matchFilters,\n  mergeFilters,\n  nip04_exports as nip04,\n  nip05_exports as nip05,\n  nip10_exports as nip10,\n  nip11_exports as nip11,\n  nip13_exports as nip13,\n  nip17_exports as nip17,\n  nip18_exports as nip18,\n  nip19_exports as nip19,\n  nip21_exports as nip21,\n  nip25_exports as nip25,\n  nip27_exports as nip27,\n  nip28_exports as nip28,\n  nip30_exports as nip30,\n  nip39_exports as nip39,\n  nip42_exports as nip42,\n  nip44_exports as nip44,\n  nip47_exports as nip47,\n  nip54_exports as nip54,\n  nip57_exports as nip57,\n  nip59_exports as nip59,\n  nip98_exports as nip98,\n  parseReferences,\n  serializeEvent,\n  sortEvents,\n  utils_exports as utils,\n  validateEvent,\n  verifiedSymbol,\n  verifyEvent\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst modular_js_1 = require(\"./abstract/modular.js\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\nconst utils_js_1 = require(\"./abstract/utils.js\");\nconst hash_to_curve_js_1 = require(\"./abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = require(\"./_shortw_utils.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\nexports.hashToCurve = (() => htf.hashToCurve)();\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nconst utils_js_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nexports.invert = invert;\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nexports.nLength = nLength;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar;\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\nexports.getFieldBytesLength = getFieldBytesLength;\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\nexports.getMinHashLength = getMinHashLength;\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\nexports.mapHashToField = mapHashToField;\n//# sourceMappingURL=modular.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject;\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nconst mod = require(\"./modular.js\");\nconst ut = require(\"./utils.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst curve_js_1 = require(\"./curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\nexports.weierstrass = weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n//# sourceMappingURL=weierstrass.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      if (this.is0()) {\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\n        // In BLS, ZERO can be serialized, so we allow it.\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y²\n      const right = weierstrassEquation(x); // x³ + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nexports.validateBasic = validateBasic;\n//# sourceMappingURL=curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = require(\"./modular.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\nexports.createHasher = createHasher;\n//# sourceMappingURL=hash-to-curve.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { Group, GroupConstructor, AffinePoint } from './curve.js';\nimport { mod, IField } from './modular.js';\nimport { bytesToNumberBE, CHash, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\nfunction validateDST(dst: UnicodeOrBytes): Uint8Array {\n  if (dst instanceof Uint8Array) return dst;\n  if (typeof dst === 'string') return utf8ToBytes(dst);\n  throw new Error('DST must be Uint8Array or string');\n}\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  if (value < 0 || value >= 1 << (8 * length)) {\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n  }\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction isBytes(item: unknown): void {\n  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\nfunction isNum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (ell > 255) throw new Error('Invalid xmd length');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  isBytes(msg);\n  isNum(count);\n  const DST = validateDST(_DST);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]) {\n  // Make same order as in spec\n  const COEFF = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\n\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  def: Opts & { encodeDST?: UnicodeOrBytes }\n) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createCurve = exports.getHash = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst weierstrass_js_1 = require(\"./abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\nexports.createCurve = createCurve;\n//# sourceMappingURL=_shortw_utils.js.map","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.hash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = require(\"./_sha2.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = wrapConstructor(() => new SHA256());\nexport const sha224 = wrapConstructor(() => new SHA224());\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA2 = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map","import assert from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    assert.exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","export function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nexport function bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nexport function bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nexport function hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nexport function exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output,\n};\n\nexport default assert;\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nexport function assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexport const utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexport const base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport const base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexport const bech32 = genBech32('bech32');\nexport const bech32m = genBech32('bech32m');\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexport const hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString;\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsafe = exports.siv = exports.gcm = exports.cfb = exports.cbc = exports.ecb = exports.ctr = exports.expandKeyDecLE = exports.expandKeyLE = void 0;\n// prettier-ignore\nconst utils_js_1 = require(\"./utils.js\");\nconst _polyval_js_1 = require(\"./_polyval.js\");\nconst _assert_js_1 = require(\"./_assert.js\");\n/*\nAES (Advanced Encryption Standard) aka Rijndael block cipher.\n\nData is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n1. **S-box**, table substitution\n2. **Shift rows**, cyclic shift left of all rows of data array\n3. **Mix columns**, multiplying every column by fixed polynomial\n4. **Add round key**, round_key xor i-th column of array\n\nResources:\n- FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n- Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\n*/\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n    let t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const box = new Uint8Array(256);\n    box[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    return box;\n})();\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst xPowers = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\nfunction expandKeyLE(key) {\n    (0, _assert_js_1.bytes)(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2 } = tableEncoding;\n    const k32 = (0, utils_js_1.u32)(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nexports.expandKeyLE = expandKeyLE;\nfunction expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = tableEncoding;\n    const { T0, T1, T2, T3 } = tableDecoding;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\nexports.expandKeyDecLE = expandKeyDecLE;\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableEncoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableDecoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction getDst(len, dst) {\n    if (!dst)\n        return new Uint8Array(len);\n    (0, _assert_js_1.bytes)(dst);\n    if (dst.length < len)\n        throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    (0, _assert_js_1.bytes)(src);\n    const srcLen = src.length;\n    dst = getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = (0, utils_js_1.u32)(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = (0, utils_js_1.u32)(src);\n    const dst32 = (0, utils_js_1.u32)(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0, utils_js_1.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    (0, _assert_js_1.bytes)(src);\n    dst = getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = (0, utils_js_1.u32)(ctr);\n    const view = (0, utils_js_1.createView)(ctr);\n    const src32 = (0, utils_js_1.u32)(src);\n    const dst32 = (0, utils_js_1.u32)(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0, utils_js_1.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexports.ctr = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function ctr(key, nonce) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = expandKeyLE(key);\n        const n = nonce.slice();\n        const out = ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    (0, _assert_js_1.bytes)(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = (0, utils_js_1.u32)(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = getDst(outLen, dst);\n    const o = (0, utils_js_1.u32)(out);\n    return { b, o, out };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = (0, utils_js_1.u32)(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexports.ecb = (0, utils_js_1.wrapCipher)({ blockSize: 16 }, function ecb(key, opts = {}) {\n    (0, _assert_js_1.bytes)(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0, utils_js_1.u32)(ciphertext);\n            const o = (0, utils_js_1.u32)(out);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexports.cbc = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cbc(key, iv, opts = {}) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = (0, utils_js_1.u32)(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const n32 = (0, utils_js_1.u32)(iv);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0, utils_js_1.u32)(ciphertext);\n            const o = (0, utils_js_1.u32)(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexports.cfb = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cfb(key, iv) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(iv, 16);\n    function processCfb(src, isEncrypt, dst) {\n        const xk = expandKeyLE(key);\n        const srcLen = src.length;\n        dst = getDst(srcLen, dst);\n        const src32 = (0, utils_js_1.u32)(src);\n        const dst32 = (0, utils_js_1.u32)(dst);\n        const next32 = isEncrypt ? dst32 : src32;\n        const n32 = (0, utils_js_1.u32)(iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= src32.length;) {\n            const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n            dst32[i + 0] = src32[i + 0] ^ e0;\n            dst32[i + 1] = src32[i + 1] ^ e1;\n            dst32[i + 2] = src32[i + 2] ^ e2;\n            dst32[i + 3] = src32[i + 3] ^ e3;\n            (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n        }\n        // leftovers (less than block)\n        const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n        if (start < srcLen) {\n            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n            const buf = (0, utils_js_1.u8)(new Uint32Array([s0, s1, s2, s3]));\n            for (let i = start, pos = 0; i < srcLen; i++, pos++)\n                dst[i] = src[i] ^ buf[pos];\n            buf.fill(0);\n        }\n        xk.fill(0);\n        return dst;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n        decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst),\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD)\n        h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = (0, utils_js_1.createView)(num);\n    if (AAD)\n        (0, utils_js_1.setBigUint64)(view, 0, BigInt(AAD.length * 8), isLE);\n    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nexports.gcm = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm(key, nonce, AAD) {\n    (0, _assert_js_1.bytes)(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0)\n        throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(_polyval_js_1.ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = (0, utils_js_1.createView)(nonceLen);\n            (0, utils_js_1.setBigUint64)(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            _polyval_js_1.ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0, _assert_js_1.bytes)(ciphertext);\n            if (ciphertext.length < tagLength)\n                throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!(0, utils_js_1.equalBytes)(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max)\n        throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexports.siv = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    (0, _assert_js_1.bytes)(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        (0, _assert_js_1.bytes)(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32)\n            throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = (0, utils_js_1.u32)(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(utils_js_1.u32)) {\n            const d32 = (0, utils_js_1.u32)(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(_polyval_js_1.polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = (0, utils_js_1.u32)(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0, _assert_js_1.bytes)(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!(0, utils_js_1.equalBytes)(tag, expectedTag))\n                throw new Error('invalid polyval tag');\n            return plaintext;\n        },\n    };\n});\nfunction isBytes32(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint32Array || a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    (0, _assert_js_1.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = (0, utils_js_1.u32)(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    (0, _assert_js_1.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = (0, utils_js_1.u32)(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nexports.unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n//# sourceMappingURL=aes.js.map","// prettier-ignore\nimport {\n  wrapCipher, Cipher, CipherWithOutput,\n  createView, setBigUint64, equalBytes, u32, u8,\n} from './utils.js';\nimport { ghash, polyval } from './_polyval.js';\nimport { bytes as abytes } from './_assert.js';\n\n/*\nAES (Advanced Encryption Standard) aka Rijndael block cipher.\n\nData is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n1. **S-box**, table substitution\n2. **Shift rows**, cyclic shift left of all rows of data array\n3. **Mix columns**, multiplying every column by fixed polynomial\n4. **Add round key**, round_key xor i-th column of array\n\nResources:\n- FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n- Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\n*/\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  let t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\nexport function expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n  const { sbox2 } = tableEncoding;\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  return xk;\n}\n\nexport function expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  encKey.fill(0);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(xk: Uint32Array, s0: number, s1: number, s2: number, s3: number) {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\nfunction decrypt(xk: Uint32Array, s0: number, s1: number, s2: number, s3: number) {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\nfunction getDst(len: number, dst?: Uint8Array) {\n  if (!dst) return new Uint8Array(len);\n  abytes(dst);\n  if (dst.length < len)\n    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n  return dst;\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk: Uint32Array, nonce: Uint8Array, src: Uint8Array, dst?: Uint8Array) {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getDst(srcLen, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n) {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getDst(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr = wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function ctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    abytes(key);\n    abytes(nonce, BLOCK_SIZE);\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      const xk = expandKeyLE(key);\n      const n = nonce.slice();\n      const out = ctrCounter(xk, n, buf, dst);\n      xk.fill(0);\n      n.fill(0);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      `aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  const out = getDst(outLen, dst);\n  const o = u32(out);\n  return { b, o, out };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error(`aes/pcks5: wrong padding`);\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb = wrapCipher(\n  { blockSize: 16 },\n  function ecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    abytes(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => {\n        abytes(plaintext);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        xk.fill(0);\n        return _out;\n      },\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        const out = getDst(ciphertext.length, dst);\n        const b = u32(ciphertext);\n        const o = u32(out);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        xk.fill(0);\n        return validatePCKS(out, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc = wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function cbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    abytes(key);\n    abytes(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const n32 = u32(iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        xk.fill(0);\n        return _out;\n      },\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        const n32 = u32(iv);\n        const out = getDst(ciphertext.length, dst);\n        const b = u32(ciphertext);\n        const o = u32(out);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        xk.fill(0);\n        return validatePCKS(out, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb = wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function cfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    abytes(key);\n    abytes(iv, 16);\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      const xk = expandKeyLE(key);\n      const srcLen = src.length;\n      dst = getDst(srcLen, dst);\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        buf.fill(0);\n      }\n      xk.fill(0);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const h = fn.create(key, data.length + (AAD?.length || 0));\n  if (AAD) h.update(AAD);\n  h.update(data);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  if (AAD) setBigUint64(view, 0, BigInt(AAD.length * 8), isLE);\n  setBigUint64(view, 8, BigInt(data.length * 8), isLE);\n  h.update(num);\n  return h.digest();\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nexport const gcm = wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16 },\n  function gcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    abytes(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0) throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        // Spec (NIST 800-38d) supports variable size nonce.\n        // Not supported for now, but can be useful.\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt: (plaintext: Uint8Array) => {\n        abytes(plaintext);\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        ctr32(xk, false, counter, plaintext, out);\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        out.set(tag, plaintext.length);\n        xk.fill(0);\n        return out;\n      },\n      decrypt: (ciphertext: Uint8Array) => {\n        abytes(ciphertext);\n        if (ciphertext.length < tagLength)\n          throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        authKey.fill(0);\n        tagMask.fill(0);\n        xk.fill(0);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max)\n    throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const siv = wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16 },\n  function siv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n      abytes(AAD);\n      AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n      const len = key.length;\n      if (len !== 16 && len !== 24 && len !== 32)\n        throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(len);\n      const authKey = new Uint8Array(16);\n      const n32 = u32(nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      xk.fill(0);\n      return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = tag.slice();\n      block[15] |= 0x80; // Force highest bit\n      return ctr32(encKey, true, block, input);\n    }\n    return {\n      encrypt: (plaintext: Uint8Array) => {\n        abytes(plaintext);\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        encKey.fill(0);\n        authKey.fill(0);\n        return out;\n      },\n      decrypt: (ciphertext: Uint8Array) => {\n        abytes(ciphertext);\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        encKey.fill(0);\n        authKey.fill(0);\n        if (!equalBytes(tag, expectedTag)) throw new Error('invalid polyval tag');\n        return plaintext;\n      },\n    };\n  }\n);\n\nfunction isBytes32(a: unknown): a is Uint8Array {\n  return (\n    a != null &&\n    typeof a === 'object' &&\n    (a instanceof Uint32Array || a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array) {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array) {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nexport const unsafe = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.u64Lengths = exports.setBigUint64 = exports.wrapCipher = exports.Hash = exports.equalBytes = exports.checkOpts = exports.concatBytes = exports.toBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.numberToBytesBE = exports.bytesToNumberBE = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.createView = exports.u32 = exports.u16 = exports.u8 = void 0;\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nconst _assert_js_1 = require(\"./_assert.js\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexports.u16 = u16;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`string expected, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToUtf8 = bytesToUtf8;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if ((0, _assert_js_1.isBytes)(data))\n        data = data.slice();\n    else\n        throw new Error(`Uint8Array expected, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\nfunction checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\nexports.equalBytes = equalBytes;\n// For runtime check if class implements interface\nclass Hash {\n}\nexports.Hash = Hash;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nconst wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\nexports.wrapCipher = wrapCipher;\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexports.setBigUint64 = setBigUint64;\nfunction u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = (0, exports.createView)(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\nexports.u64Lengths = u64Lengths;\n//# sourceMappingURL=utils.js.map","/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nimport { bytes as abytes, isBytes } from './_assert.js';\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u16 = (arr: TypedArray) =>\n  new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`string expected, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = data.slice();\n  else throw new Error(`Uint8Array expected, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n// Params is outside return type, so it is accessible before calling constructor\n// If function support multiple nonceLength's, we return best one\nexport type CipherParams = { blockSize: number; nonceLength?: number; tagLength?: number };\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  c: C\n): C & P => {\n  Object.assign(c, params);\n  return c as C & P;\n};\n\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n// Polyfill for Safari 14\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(ciphertext: Uint8Array, AAD?: Uint8Array) {\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(ciphertext.length), true);\n  return num;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexports.bool = bool;\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`positive integer expected, not ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\n\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('hash must be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.polyval = exports.ghash = exports._toGHASHKey = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = (0, utils_js_1.u32)(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nfunction _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nexports._toGHASHKey = _toGHASHKey;\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = (0, utils_js_1.toBytes)(key);\n        (0, _assert_js_1.bytes)(key, 16);\n        const kView = (0, utils_js_1.createView)(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = (0, utils_js_1.toBytes)(data);\n        (0, _assert_js_1.exists)(this);\n        const b32 = (0, utils_js_1.u32)(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0, utils_js_1.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = (0, utils_js_1.toBytes)(key);\n        const ghKey = _toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = (0, utils_js_1.toBytes)(data);\n        (0, _assert_js_1.exists)(this);\n        const b32 = (0, utils_js_1.u32)(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0, utils_js_1.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update((0, utils_js_1.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\nexports.ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\nexports.polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n//# sourceMappingURL=_polyval.js.map","import { createView, toBytes, Input, Hash, u32 } from './utils.js';\nimport { bytes as abytes, exists as aexists, output as aoutput } from './_assert.js';\n\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      ZEROS32.fill(0); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    const ghKey = _toGHASHKey(key.slice());\n    super(ghKey, expectedLength);\n    ghKey.fill(0);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      ZEROS32.fill(0); // clean tmp buffer\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n) {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\nexport const ghash = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\nexport const polyval = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = exports.hchacha = void 0;\n// prettier-ignore\nconst utils_js_1 = require(\"./utils.js\");\nconst _poly1305_js_1 = require(\"./_poly1305.js\");\nconst _arx_js_1 = require(\"./_arx.js\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\nexports.hchacha = hchacha;\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexports.chacha20orig = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexports.chacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexports.xchacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexports.chacha8 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexports.chacha12 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = _poly1305_js_1.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0, utils_js_1.createView)(num);\n    (0, utils_js_1.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    (0, _assert_js_1.bytes)(key, 32);\n    (0, _assert_js_1.bytes)(nonce);\n    return {\n        encrypt: (plaintext, output) => {\n            const plength = plaintext.length;\n            const clength = plength + tagLength;\n            if (output) {\n                (0, _assert_js_1.bytes)(output, clength);\n            }\n            else {\n                output = new Uint8Array(clength);\n            }\n            xorStream(key, nonce, plaintext, output, 1);\n            const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n            output.set(tag, plength); // append tag\n            return output;\n        },\n        decrypt: (ciphertext, output) => {\n            const clength = ciphertext.length;\n            const plength = clength - tagLength;\n            if (clength < tagLength)\n                throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n            if (output) {\n                (0, _assert_js_1.bytes)(output, plength);\n            }\n            else {\n                output = new Uint8Array(plength);\n            }\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0, utils_js_1.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            xorStream(key, nonce, data, output, 1);\n            return output;\n        },\n    };\n};\nexports._poly1305_aead = _poly1305_aead;\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexports.chacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports._poly1305_aead)(exports.chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexports.xchacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports._poly1305_aead)(exports.xchacha20));\n//# sourceMappingURL=chacha.js.map","// prettier-ignore\nimport {\n  wrapCipher, CipherWithOutput, XorStream, createView, equalBytes, setBigUint64,\n} from './utils.js';\nimport { poly1305 } from './_poly1305.js';\nimport { createCipher, rotl } from './_arx.js';\nimport { bytes as abytes } from './_assert.js';\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n      y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n      y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n      y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, o32: Uint32Array\n) {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  o32[oi++] = x00; o32[oi++] = x01;\n  o32[oi++] = x02; o32[oi++] = x03;\n  o32[oi++] = x12; o32[oi++] = x13;\n  o32[oi++] = x14; o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexport const chacha20orig = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexport const xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexport const chacha8 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexport const chacha12 = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const left = msg.length % 16;\n  if (left) h.update(ZEROS16.subarray(left));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const authKey = fn(key, nonce, ZEROS32);\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, data);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n  setBigUint64(view, 8, BigInt(data.length), true);\n  h.update(num);\n  const res = h.digest();\n  authKey.fill(0);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    abytes(key, 32);\n    abytes(nonce);\n    return {\n      encrypt: (plaintext: Uint8Array, output?: Uint8Array) => {\n        const plength = plaintext.length;\n        const clength = plength + tagLength;\n        if (output) {\n          abytes(output, clength);\n        } else {\n          output = new Uint8Array(clength);\n        }\n        xorStream(key, nonce, plaintext, output, 1);\n        const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n        output.set(tag, plength); // append tag\n        return output;\n      },\n      decrypt: (ciphertext: Uint8Array, output?: Uint8Array) => {\n        const clength = ciphertext.length;\n        const plength = clength - tagLength;\n        if (clength < tagLength)\n          throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n        if (output) {\n          abytes(output, plength);\n        } else {\n          output = new Uint8Array(plength);\n        }\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        xorStream(key, nonce, data, output, 1);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexport const chacha20poly1305 = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexport const xchacha20poly1305 = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.poly1305 = exports.wrapConstructorWithKey = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0, utils_js_1.toBytes)(key);\n        (0, _assert_js_1.bytes)(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update((0, utils_js_1.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\nexports.wrapConstructorWithKey = wrapConstructorWithKey;\nexports.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map","import { exists as aexists, bytes as abytes, output as aoutput } from './_assert.js';\nimport { Input, toBytes, Hash } from './utils.js';\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a: Uint8Array, i: number) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 implements Hash<Poly1305> {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10);\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  constructor(key: Input) {\n    key = toBytes(key);\n    abytes(key, 32);\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy() {\n    this.h.fill(0);\n    this.r.fill(0);\n    this.buffer.fill(0);\n    this.pad.fill(0);\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      // buffer.subarray(pos).fill(0);\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends Hash<H>>(hashCons: (key: Input) => Hash<H>) {\n  const hashC = (msg: Input, key: Input): Uint8Array => hashCons(key).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(32));\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input) => hashCons(key);\n  return hashC;\n}\n\nexport const poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createCipher = exports.rotl = exports.sigma = void 0;\n// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = (0, utils_js_1.u32)(sigma16);\nconst sigma32_32 = (0, utils_js_1.u32)(sigma32);\nexports.sigma = sigma32_32.slice();\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\nexports.rotl = rotl;\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0, utils_js_1.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0, utils_js_1.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0, utils_js_1.u32)(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_js_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    (0, _assert_js_1.number)(counterLength);\n    (0, _assert_js_1.number)(rounds);\n    (0, _assert_js_1.bool)(counterRight);\n    (0, _assert_js_1.bool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        (0, _assert_js_1.bytes)(key);\n        (0, _assert_js_1.bytes)(nonce);\n        (0, _assert_js_1.bytes)(data);\n        const len = data.length;\n        if (!output)\n            output = new Uint8Array(len);\n        (0, _assert_js_1.bytes)(output);\n        (0, _assert_js_1.number)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            k = key.slice();\n            toClean.push(k);\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce)) {\n            nonce = nonce.slice();\n            toClean.push(nonce);\n        }\n        const k32 = (0, utils_js_1.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0, utils_js_1.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0, utils_js_1.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        while (toClean.length > 0)\n            toClean.pop().fill(0);\n        return output;\n    };\n}\nexports.createCipher = createCipher;\n//# sourceMappingURL=_arx.js.map","// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\nimport { number as anumber, bytes as abytes, bool as abool } from './_assert.js';\nimport { XorStream, checkOpts, u32 } from './utils.js';\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str: string) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\nexport const sigma = sigma32_32.slice();\n\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean; // right: nonce|counter; left: counter|nonce\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key);\n    abytes(nonce);\n    abytes(data);\n    const len = data.length;\n    if (!output) output = new Uint8Array(len);\n    abytes(output);\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length,\n      k: Uint8Array,\n      sigma: Uint32Array;\n    if (l === 32) {\n      k = key.slice();\n      toClean.push(k);\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) {\n      nonce = nonce.slice();\n      toClean.push(nonce);\n    }\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    while (toClean.length > 0) toClean.pop()!.fill(0);\n    return output;\n  };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hkdf = exports.expand = exports.extract = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst hmac_js_1 = require(\"./hmac.js\");\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js_1.default.hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0, hmac_js_1.hmac)(hash, (0, utils_js_1.toBytes)(salt), (0, utils_js_1.toBytes)(ikm));\n}\nexports.extract = extract;\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js_1.default.hash(hash);\n    _assert_js_1.default.number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac_js_1.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\nexports.expand = expand;\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\nexports.hkdf = hkdf;\n//# sourceMappingURL=hkdf.js.map","import assert from './_assert.js';\nimport { CHash, Input, toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input) {\n  assert.hash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32) {\n  assert.hash(hash);\n  assert.number(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n) => expand(hash, extract(hash, ikm, salt), info, length);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js_1.default.hash(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js_1.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","import assert from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assert.hash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assert.exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","var e,t,r=(e=function(e,t){function r(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function n(...e){const t=(e,t)=>r=>e(t(r));return{encode:Array.from(e).reverse().reduce((e,r)=>e?t(e,r.encode):r.encode,void 0),decode:e.reduce((e,r)=>e?t(e,r.decode):r.decode,void 0)}}function o(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&\"number\"!=typeof t[0])throw new Error(\"alphabet.encode input should be an array of numbers\");return t.map(t=>{if(r(t),t<0||t>=e.length)throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);return e[t]})},decode:t=>{if(!Array.isArray(t)||t.length&&\"string\"!=typeof t[0])throw new Error(\"alphabet.decode input should be array of strings\");return t.map(t=>{if(\"string\"!=typeof t)throw new Error(`alphabet.decode: not string element=${t}`);const r=e.indexOf(t);if(-1===r)throw new Error(`Unknown letter: \"${t}\". Allowed: ${e}`);return r})}}}function i(e=\"\"){if(\"string\"!=typeof e)throw new Error(\"join separator should be string\");return{encode:t=>{if(!Array.isArray(t)||t.length&&\"string\"!=typeof t[0])throw new Error(\"join.encode input should be array of strings\");for(let e of t)if(\"string\"!=typeof e)throw new Error(`join.encode: non-string input=${e}`);return t.join(e)},decode:t=>{if(\"string\"!=typeof t)throw new Error(\"join.decode input should be string\");return t.split(e)}}}function s(e,t=\"=\"){if(r(e),\"string\"!=typeof t)throw new Error(\"padding chr should be string\");return{encode(r){if(!Array.isArray(r)||r.length&&\"string\"!=typeof r[0])throw new Error(\"padding.encode input should be array of strings\");for(let e of r)if(\"string\"!=typeof e)throw new Error(`padding.encode: non-string input=${e}`);for(;r.length*e%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&\"string\"!=typeof r[0])throw new Error(\"padding.encode input should be array of strings\");for(let e of r)if(\"string\"!=typeof e)throw new Error(`padding.decode: non-string input=${e}`);let n=r.length;if(n*e%8)throw new Error(\"Invalid padding: string should have whole number of bytes\");for(;n>0&&r[n-1]===t;n--)if(!((n-1)*e%8))throw new Error(\"Invalid padding: string has too much padding\");return r.slice(0,n)}}}function a(e){if(\"function\"!=typeof e)throw new Error(\"normalize fn should be function\");return{encode:e=>e,decode:t=>e(t)}}function c(e,t,n){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error(\"convertRadix: data should be array\");if(!e.length)return[];let o=0;const i=[],s=Array.from(e);for(s.forEach(e=>{if(r(e),e<0||e>=t)throw new Error(`Wrong integer: ${e}`)});;){let e=0,r=!0;for(let i=o;i<s.length;i++){const a=s[i],c=t*e+a;if(!Number.isSafeInteger(c)||t*e/t!==e||c-a!=t*e)throw new Error(\"convertRadix: carry overflow\");if(e=c%n,s[i]=Math.floor(c/n),!Number.isSafeInteger(s[i])||s[i]*n+e!==c)throw new Error(\"convertRadix: carry overflow\");r&&(s[i]?r=!1:o=i)}if(i.push(e),r)break}for(let t=0;t<e.length-1&&0===e[t];t++)i.push(0);return i.reverse()}Object.defineProperty(t,\"__esModule\",{value:!0}),t.bytes=t.stringToBytes=t.str=t.bytesToString=t.hex=t.utf8=t.bech32m=t.bech32=t.base58check=t.base58xmr=t.base58xrp=t.base58flickr=t.base58=t.base64url=t.base64=t.base32crockford=t.base32hex=t.base32=t.base16=t.utils=t.assertNumber=void 0,t.assertNumber=r;const u=(e,t)=>t?u(t,e%t):e,h=(e,t)=>e+(t-u(e,t));function l(e,t,n,o){if(!Array.isArray(e))throw new Error(\"convertRadix2: data should be array\");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(h(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${h(t,n)}`);let i=0,s=0;const a=2**n-1,c=[];for(const o of e){if(r(o),o>=2**t)throw new Error(`convertRadix2: invalid data word=${o} from=${t}`);if(i=i<<t|o,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)c.push((i>>s-n&a)>>>0);i&=2**s-1}if(i=i<<n-s&a,!o&&s>=t)throw new Error(\"Excess padding\");if(!o&&i)throw new Error(`Non-zero padding: ${i}`);return o&&s>0&&c.push(i>>>0),c}function f(e){return r(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error(\"radix.encode input should be Uint8Array\");return c(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&\"number\"!=typeof t[0])throw new Error(\"radix.decode input should be array of strings\");return Uint8Array.from(c(t,e,256))}}}function d(e,t=!1){if(r(e),e<=0||e>32)throw new Error(\"radix2: bits should be in (0..32]\");if(h(8,e)>32||h(e,8)>32)throw new Error(\"radix2: carry overflow\");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error(\"radix2.encode input should be Uint8Array\");return l(Array.from(r),8,e,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&\"number\"!=typeof r[0])throw new Error(\"radix2.decode input should be array of strings\");return Uint8Array.from(l(r,e,8,t))}}}function p(e){if(\"function\"!=typeof e)throw new Error(\"unsafeWrapper fn should be function\");return function(...t){try{return e.apply(null,t)}catch(e){}}}function m(e,t){if(r(e),\"function\"!=typeof t)throw new Error(\"checksum fn should be function\");return{encode(r){if(!(r instanceof Uint8Array))throw new Error(\"checksum.encode: input should be Uint8Array\");const n=t(r).slice(0,e),o=new Uint8Array(r.length+e);return o.set(r),o.set(n,r.length),o},decode(r){if(!(r instanceof Uint8Array))throw new Error(\"checksum.decode: input should be Uint8Array\");const n=r.slice(0,-e),o=t(n).slice(0,e),i=r.slice(-e);for(let t=0;t<e;t++)if(o[t]!==i[t])throw new Error(\"Invalid checksum\");return n}}}t.utils={alphabet:o,chain:n,checksum:m,radix:f,radix2:d,join:i,padding:s},t.base16=n(d(4),o(\"0123456789ABCDEF\"),i(\"\")),t.base32=n(d(5),o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"),s(5),i(\"\")),t.base32hex=n(d(5),o(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"),s(5),i(\"\")),t.base32crockford=n(d(5),o(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"),i(\"\"),a(e=>e.toUpperCase().replace(/O/g,\"0\").replace(/[IL]/g,\"1\"))),t.base64=n(d(6),o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"),s(6),i(\"\")),t.base64url=n(d(6),o(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"),s(6),i(\"\"));const y=e=>n(f(58),o(e),i(\"\"));t.base58=y(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"),t.base58flickr=y(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"),t.base58xrp=y(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");const w=[0,2,3,5,6,7,9,10,11];t.base58xmr={encode(e){let r=\"\";for(let n=0;n<e.length;n+=8){const o=e.subarray(n,n+8);r+=t.base58.encode(o).padStart(w[o.length],\"1\")}return r},decode(e){let r=[];for(let n=0;n<e.length;n+=11){const o=e.slice(n,n+11),i=w.indexOf(o.length),s=t.base58.decode(o);for(let e=0;e<s.length-i;e++)if(0!==s[e])throw new Error(\"base58xmr: wrong padding\");r=r.concat(Array.from(s.slice(s.length-i)))}return Uint8Array.from(r)}},t.base58check=e=>n(m(4,t=>e(e(t))),t.base58);const g=n(o(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"),i(\"\")),v=[996825010,642813549,513874426,1027748829,705979059];function b(e){const t=e>>25;let r=(33554431&e)<<5;for(let e=0;e<v.length;e++)1==(t>>e&1)&&(r^=v[e]);return r}function E(e,t,r=1){const n=e.length;let o=1;for(let t=0;t<n;t++){const r=e.charCodeAt(t);if(r<33||r>126)throw new Error(`Invalid prefix (${e})`);o=b(o)^r>>5}o=b(o);for(let t=0;t<n;t++)o=b(o)^31&e.charCodeAt(t);for(let e of t)o=b(o)^e;for(let e=0;e<6;e++)o=b(o);return o^=r,g.encode(l([o%2**30],30,5,!1))}function x(e){const t=\"bech32\"===e?1:734539939,r=d(5),n=r.decode,o=r.encode,i=p(n);function s(e,r=90){if(\"string\"!=typeof e)throw new Error(\"bech32.decode input should be string, not \"+typeof e);if(e.length<8||!1!==r&&e.length>r)throw new TypeError(`Wrong string length: ${e.length} (${e}). Expected (8..${r})`);const n=e.toLowerCase();if(e!==n&&e!==e.toUpperCase())throw new Error(\"String must be lowercase or uppercase\");const o=(e=n).lastIndexOf(\"1\");if(0===o||-1===o)throw new Error('Letter \"1\" must be present between prefix and data only');const i=e.slice(0,o),s=e.slice(o+1);if(s.length<6)throw new Error(\"Data must be at least 6 characters long\");const a=g.decode(s).slice(0,-6),c=E(i,a,t);if(!s.endsWith(c))throw new Error(`Invalid checksum in ${e}: expected \"${c}\"`);return{prefix:i,words:a}}return{encode:function(e,r,n=90){if(\"string\"!=typeof e)throw new Error(\"bech32.encode prefix should be string, not \"+typeof e);if(!Array.isArray(r)||r.length&&\"number\"!=typeof r[0])throw new Error(\"bech32.encode words should be array of numbers, not \"+typeof r);const o=e.length+7+r.length;if(!1!==n&&o>n)throw new TypeError(`Length ${o} exceeds limit ${n}`);return`${e=e.toLowerCase()}1${g.encode(r)}${E(e,r,t)}`},decode:s,decodeToBytes:function(e){const{prefix:t,words:r}=s(e,!1);return{prefix:t,words:r,bytes:n(r)}},decodeUnsafe:p(s),fromWords:n,fromWordsUnsafe:i,toWords:o}}t.bech32=x(\"bech32\"),t.bech32m=x(\"bech32m\"),t.utf8={encode:e=>(new TextDecoder).decode(e),decode:e=>(new TextEncoder).encode(e)},t.hex=n(d(4),o(\"0123456789abcdef\"),i(\"\"),a(e=>{if(\"string\"!=typeof e||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()}));const P={utf8:t.utf8,hex:t.hex,base16:t.base16,base32:t.base32,base64:t.base64,base64url:t.base64url,base58:t.base58,base58xmr:t.base58xmr},A=`Invalid encoding type. Available types: ${Object.keys(P).join(\", \")}`;t.bytesToString=(e,t)=>{if(\"string\"!=typeof e||!P.hasOwnProperty(e))throw new TypeError(A);if(!(t instanceof Uint8Array))throw new TypeError(\"bytesToString() expects Uint8Array\");return P[e].encode(t)},t.str=t.bytesToString,t.stringToBytes=(e,t)=>{if(!P.hasOwnProperty(e))throw new TypeError(A);if(\"string\"!=typeof t)throw new TypeError(\"stringToBytes() expects string\");return P[e].decode(t)},t.bytes=t.stringToBytes},e(t={exports:{}},t.exports),t.exports);const{bech32:n,hex:o,utf8:i}=r,s={bech32:\"bc\",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},a={bech32:\"tb\",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},c={bech32:\"tbs\",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},u={bech32:\"bcrt\",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},h={bech32:\"sb\",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},l=[\"option_data_loss_protect\",\"initial_routing_sync\",\"option_upfront_shutdown_script\",\"gossip_queries\",\"var_onion_optin\",\"gossip_queries_ex\",\"option_static_remotekey\",\"payment_secret\",\"basic_mpp\",\"option_support_large_channel\"],f={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},d=BigInt(\"2100000000000000000\"),p=BigInt(1e11),m={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},y={};for(let e=0,t=Object.keys(m);e<t.length;e++){const r=t[e],n=m[t[e]].toString();y[n]=r}const w={1:e=>o.encode(n.fromWordsUnsafe(e)),16:e=>o.encode(n.fromWordsUnsafe(e)),13:e=>i.encode(n.fromWordsUnsafe(e)),19:e=>o.encode(n.fromWordsUnsafe(e)),23:e=>o.encode(n.fromWordsUnsafe(e)),27:e=>o.encode(n.fromWordsUnsafe(e)),6:v,24:v,3:function(e){const t=[];let r,i,s,a,c,u=n.fromWordsUnsafe(e);for(;u.length>0;)r=o.encode(u.slice(0,33)),i=o.encode(u.slice(33,41)),s=parseInt(o.encode(u.slice(41,45)),16),a=parseInt(o.encode(u.slice(45,49)),16),c=parseInt(o.encode(u.slice(49,51)),16),u=u.slice(51),t.push({pubkey:r,short_channel_id:i,fee_base_msat:s,fee_proportional_millionths:a,cltv_expiry_delta:c});return t},5:function(e){const t=e.slice().reverse().map(e=>[!!(1&e),!!(2&e),!!(4&e),!!(8&e),!!(16&e)]).reduce((e,t)=>e.concat(t),[]);for(;t.length<2*l.length;)t.push(!1);const r={};l.forEach((e,n)=>{let o;o=t[2*n]?\"required\":t[2*n+1]?\"supported\":\"unsupported\",r[e]=o});const n=t.slice(2*l.length);return r.extra_bits={start_bit:2*l.length,bits:n,has_required:n.reduce((e,t,r)=>r%2!=0?e||!1:e||t,!1)},r}};function g(e){return t=>({tagCode:parseInt(e),words:n.encode(\"unknown\",t,Number.MAX_SAFE_INTEGER)})}function v(e){return e.reverse().reduce((e,t,r)=>e+t*Math.pow(32,r),0)}var b=function(e){return Uint8Array.from(e.match(/.{1,2}/g).map(function(e){return parseInt(e,16)}))},E=function(e){if(!e)return null;try{var t=function(e,t){if(\"string\"!=typeof e)throw new Error(\"Lightning Payment Request must be string\");if(\"ln\"!==e.slice(0,2).toLowerCase())throw new Error(\"Not a proper lightning payment request\");const r=[],i=n.decode(e,Number.MAX_SAFE_INTEGER);e=e.toLowerCase();const l=i.prefix;let b=i.words,E=e.slice(l.length+1),x=b.slice(-104);b=b.slice(0,-104);let P=l.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/);if(P&&!P[2]&&(P=l.match(/^ln(\\S+)$/)),!P)throw new Error(\"Not a proper lightning payment request\");r.push({name:\"lightning_network\",letters:\"ln\"});const A=P[1];let k;switch(A){case s.bech32:k=s;break;case a.bech32:k=a;break;case c.bech32:k=c;break;case u.bech32:k=u;break;case h.bech32:k=h}if(!k||k.bech32!==A)throw new Error(\"Unknown coin bech32 prefix\");r.push({name:\"coin_network\",letters:A,value:k});const _=P[2];let U;_?(U=function(e,t){let r,n;if(e.slice(-1).match(/^[munp]$/))r=e.slice(-1),n=e.slice(0,-1);else{if(e.slice(-1).match(/^[^munp0-9]$/))throw new Error(\"Not a valid multiplier for the amount\");n=e}if(!n.match(/^\\d+$/))throw new Error(\"Not a valid human readable amount\");const o=BigInt(n),i=r?o*p/f[r]:o*p;if(\"p\"===r&&o%BigInt(10)!==BigInt(0)||i>d)throw new Error(\"Amount is outside of valid range\");return i.toString()}(_+P[3]),r.push({name:\"amount\",letters:P[2]+P[3],value:U})):U=null,r.push({name:\"separator\",letters:\"1\"});const L=v(b.slice(0,7));let D,N,I,j;for(b=b.slice(7),r.push({name:\"timestamp\",letters:E.slice(0,7),value:L}),E=E.slice(7);b.length>0;){const e=b[0].toString();D=y[e]||\"unknown_tag\",N=w[e]||g(e),b=b.slice(1),I=v(b.slice(0,2)),b=b.slice(2),j=b.slice(0,I),b=b.slice(I),r.push({name:D,tag:E[0],letters:E.slice(0,3+I),value:N(j)}),E=E.slice(3+I)}r.push({name:\"signature\",letters:E.slice(0,104),value:o.encode(n.fromWordsUnsafe(x))}),E=E.slice(104),r.push({name:\"checksum\",letters:E});let S={paymentRequest:e,sections:r,get expiry(){let e=r.find(e=>\"expiry\"===e.name);if(e)return R(\"timestamp\")+e.value},get route_hints(){return r.filter(e=>\"route_hint\"===e.name).map(e=>e.value)}};for(let e in m)\"route_hint\"!==e&&Object.defineProperty(S,e,{get:()=>R(e)});return S;function R(e){let t=r.find(t=>t.name===e);return t?t.value:void 0}}(e);if(!t||!t.sections)return null;var r=t.sections.find(function(e){return\"payment_hash\"===e.name});if(\"payment_hash\"!==(null==r?void 0:r.name)||!r.value)return null;var i=r.value,l=0,b=t.sections.find(function(e){return\"amount\"===e.name});\"amount\"===(null==b?void 0:b.name)&&b.value&&(l=parseInt(b.value)/1e3);var E=t.sections.find(function(e){return\"timestamp\"===e.name});if(\"timestamp\"!==(null==E?void 0:E.name)||!E.value)return null;var x,P=E.value,A=t.sections.find(function(e){return\"expiry\"===e.name});\"expiry\"===(null==A?void 0:A.name)&&(x=A.value);var k=t.sections.find(function(e){return\"description\"===e.name});return{paymentHash:i,satoshi:l,timestamp:P,expiry:x,description:\"description\"===(null==k?void 0:k.name)?null==k?void 0:k.value:void 0}}catch(e){return null}};function x(e,t=!0){if(e.destroyed)throw new Error(\"Hash instance has been destroyed\");if(t&&e.finished)throw new Error(\"Hash#digest() has already been called\")}const P=e=>e instanceof Uint8Array,A=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),k=(e,t)=>e<<32-t|e>>>t;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error(\"Non little-endian hardware is not supported\");const _=/* @__PURE__ */Array.from({length:256},(e,t)=>t.toString(16).padStart(2,\"0\"));function U(e){if(!P(e))throw new Error(\"Uint8Array expected\");let t=\"\";for(let r=0;r<e.length;r++)t+=_[e[r]];return t}function L(e){if(\"string\"==typeof e&&(e=function(e){if(\"string\"!=typeof e)throw new Error(\"utf8ToBytes expected string, got \"+typeof e);return new Uint8Array((new TextEncoder).encode(e))}(e)),!P(e))throw new Error(\"expected Uint8Array, got \"+typeof e);return e}class D{clone(){return this._cloneInto()}}function N(e){const t=t=>e().update(L(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}class I extends D{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=A(this.buffer)}update(e){x(this);const{view:t,buffer:r,blockLen:n}=this,o=(e=L(e)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s!==n)r.set(e.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=A(e);for(;n<=o-i;i+=n)this.process(t,i)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){x(this),function(e,t){!function(e,...t){if(!(e instanceof Uint8Array))throw new Error(\"Expected Uint8Array\");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;t[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let e=i;e<n;e++)t[e]=0;!function(e,t,r,n){if(\"function\"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?0:4;e.setUint32(t+(n?4:0),s,n),e.setUint32(t+c,a,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const s=A(e),a=this.outputLen;if(a%4)throw new Error(\"_sha2: outputLen should be aligned to 32bit\");const c=a/4,u=this.get();if(c>u.length)throw new Error(\"_sha2: outputLen bigger than state\");for(let e=0;e<c;e++)s.setUint32(4*e,u[e],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return e.length=n,e.pos=s,e.finished=o,e.destroyed=i,n%t&&e.buffer.set(r),e}}const j=(e,t,r)=>e&t^e&r^t&r,S=/* @__PURE__ */new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),R=/* @__PURE__ */new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),$=/* @__PURE__ */new Uint32Array(64);class T extends I{constructor(){super(64,32,8,!1),this.A=0|R[0],this.B=0|R[1],this.C=0|R[2],this.D=0|R[3],this.E=0|R[4],this.F=0|R[5],this.G=0|R[6],this.H=0|R[7]}get(){const{A:e,B:t,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[e,t,r,n,o,i,s,a]}set(e,t,r,n,o,i,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)$[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=$[e-15],r=$[e-2],n=k(t,7)^k(t,18)^t>>>3,o=k(r,17)^k(r,19)^r>>>10;$[e]=o+$[e-7]+n+$[e-16]|0}let{A:r,B:n,C:o,D:i,E:s,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(k(s,6)^k(s,11)^k(s,25))+((h=s)&a^~h&c)+S[e]+$[e]|0,l=(k(r,2)^k(r,13)^k(r,22))+j(r,n,o)|0;u=c,c=a,a=s,s=i+t|0,i=o,o=n,n=r,r=t+l|0}var h;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,o,i,s,a,c,u)}roundClean(){$.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const W=/* @__PURE__ */N(()=>new T);var B=/*#__PURE__*/function(){function e(e){var t,r,n,o;if(this.paymentRequest=void 0,this.paymentHash=void 0,this.preimage=void 0,this.verify=void 0,this.satoshi=void 0,this.expiry=void 0,this.timestamp=void 0,this.createdDate=void 0,this.expiryDate=void 0,this.description=void 0,this.successAction=void 0,this.paymentRequest=e.pr,!this.paymentRequest)throw new Error(\"Invalid payment request\");var i=E(this.paymentRequest);if(!i)throw new Error(\"Failed to decode payment request\");this.paymentHash=i.paymentHash,this.satoshi=i.satoshi,this.timestamp=i.timestamp,this.expiry=i.expiry,this.createdDate=new Date(1e3*this.timestamp),this.expiryDate=this.expiry?new Date(1e3*(this.timestamp+this.expiry)):void 0,this.description=null!=(t=i.description)?t:null,this.verify=null!=(r=e.verify)?r:null,this.preimage=null!=(n=e.preimage)?n:null,this.successAction=null!=(o=e.successAction)?o:null}var t=e.prototype;return t.isPaid=function(){try{var e=this;if(e.preimage)return Promise.resolve(e.validatePreimage(e.preimage));if(e.verify)return Promise.resolve(e.verifyPayment());throw new Error(\"Could not verify payment\")}catch(e){return Promise.reject(e)}},t.validatePreimage=function(e){if(!e||!this.paymentHash)return!1;try{var t=U(W(b(e)));return this.paymentHash===t}catch(e){return!1}},t.verifyPayment=function(){try{var e=this;return Promise.resolve(function(t,r){try{var n=function(){if(!e.verify)throw new Error(\"LNURL verify not available\");return Promise.resolve(fetch(e.verify)).then(function(t){if(!t.ok)throw new Error(\"Verification request failed: \"+t.status+\" \"+t.statusText);return Promise.resolve(t.json()).then(function(t){return t.preimage&&(e.preimage=t.preimage),t.settled})})}()}catch(e){return r(e)}return n&&n.then?n.then(void 0,r):n}(0,function(e){return console.error(\"Failed to check LNURL-verify\",e),!1}))}catch(e){return Promise.reject(e)}},t.hasExpired=function(){var e=this.expiryDate;return!!e&&e.getTime()<Date.now()},e}(),H=function(e,t){var r=e.satoshi,n=e.comment,o=e.p,i=e.e,s=e.relays;void 0===t&&(t={});try{var a=t.nostr||globalThis.nostr;if(!a)throw new Error(\"nostr option or window.nostr is not available\");var c=[[\"relays\"].concat(s),[\"amount\",r.toString()]];return o&&c.push([\"p\",o]),i&&c.push([\"e\",i]),Promise.resolve(a.getPublicKey()).then(function(e){var t={pubkey:e,created_at:Math.floor(Date.now()/1e3),kind:9734,tags:c,content:null!=n?n:\"\"};return t.id=F(t),Promise.resolve(a.signEvent(t))})}catch(i){return Promise.reject(i)}},O=function(e){if(\"keysend\"!==e.tag)throw new Error(\"Invalid keysend params\");if(\"OK\"!==e.status)throw new Error(\"Keysend status not OK\");if(!e.pubkey)throw new Error(\"Pubkey does not exist\");var t,r;return e.customData&&e.customData[0]&&(t=e.customData[0].customKey,r=e.customData[0].customValue),{destination:e.pubkey,customKey:t,customValue:r}};function C(e){if(\"string\"!=typeof e.content)return!1;if(\"number\"!=typeof e.created_at)return!1;if(!Array.isArray(e.tags))return!1;for(var t=0;t<e.tags.length;t++){var r=e.tags[t];if(!Array.isArray(r))return!1;for(var n=0;n<r.length;n++)if(\"object\"==typeof r[n])return!1}return!0}function K(e){if(!C(e))throw new Error(\"can't serialize event with wrong or missing properties\");return JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content])}function F(e){return U(W(K(e)))}function V(e,t){var r,n,o,i;return t&&e&&(n=(r=null==(o=e.names)?void 0:o[t])?null==(i=e.relays)?void 0:i[r]:void 0),[e,r,n]}var q=/((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=+$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[+~%/.\\w-_]*)?\\??(?:[-+=&;%@.\\w_]*)#?(?:[\\w]*))?)/,z=function(e){return!!e&&q.test(e)},M=function(e){var t=e.amount;return t>0&&t>=e.min&&t<=e.max},G=function(e){try{if(\"payRequest\"!==e.tag)throw new Error(\"Invalid pay service params\");var t=(e.callback+\"\").trim();if(!z(t))throw new Error(\"Callback must be a valid url\");var r,n,o=Math.ceil(Number(e.minSendable||0)),i=Math.floor(Number(e.maxSendable));if(!o||!i||o>i)throw new Error(\"Invalid pay service params\");try{r=JSON.parse(e.metadata+\"\"),n=U(W(e.metadata+\"\"))}catch(e){r=[],n=U(W(\"[]\"))}for(var s=\"\",a=\"\",c=\"\",u=\"\",h=0;h<r.length;h++){var l=r[h],f=l[0],d=l[1];switch(f){case\"text/plain\":c=d;break;case\"text/identifier\":u=d;break;case\"text/email\":s=d;break;case\"image/png;base64\":case\"image/jpeg;base64\":a=\"data:\"+f+\",\"+d}}var p,m=e.payerData;try{p=new URL(t).hostname}catch(e){}return Promise.resolve({callback:t,fixed:o===i,min:o,max:i,domain:p,metadata:r,metadataHash:n,identifier:u,email:s,description:c,image:a,payerData:m,commentAllowed:Number(e.commentAllowed)||0,rawData:e,allowsNostr:e.allowsNostr||!1})}catch(e){return Promise.reject(e)}};function J(){return J=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},J.apply(this,arguments)}var Z=function(e,t){try{var r=e.boost;t||(t={});var n=t.webln||globalThis.webln;if(!n)throw new Error(\"WebLN not available\");if(!n.keysend)throw new Error(\"Keysend not available in current WebLN provider\");var o=e.amount||Math.floor(r.value_msat/1e3),i={destination:e.destination,amount:o,customRecords:{7629169:JSON.stringify(r)}};return e.customKey&&e.customValue&&(i.customRecords[e.customKey]=e.customValue),Promise.resolve(n.enable()).then(function(){return Promise.resolve(n.keysend(i))})}catch(e){return Promise.reject(e)}},X=/^((?:[^<>()[\\]\\\\.,;:\\s@\"]+(?:\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(?:\".+\"))@((?:\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(?:(?:[a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,Q=\"https://api.getalby.com/lnurl\",Y=/*#__PURE__*/function(){function e(e,t){this.address=void 0,this.options=void 0,this.username=void 0,this.domain=void 0,this.pubkey=void 0,this.lnurlpData=void 0,this.keysendData=void 0,this.nostrData=void 0,this.nostrPubkey=void 0,this.nostrRelays=void 0,this.webln=void 0,this.address=e,this.options={proxy:\"https://api.getalby.com/lnurl\"},this.options=Object.assign(this.options,t),this.parse(),this.webln=this.options.webln}var t=e.prototype;return t.parse=function(){var e=X.exec(this.address.toLowerCase());e&&(this.username=e[1],this.domain=e[2])},t.getWebLN=function(){return this.webln||globalThis.webln},t.fetch=function(){try{var e=this;return Promise.resolve(e.options.proxy?e.fetchWithProxy():e.fetchWithoutProxy())}catch(e){return Promise.reject(e)}},t.fetchWithProxy=function(){try{var e=this;return Promise.resolve(fetch(e.options.proxy+\"/lightning-address-details?\"+new URLSearchParams({ln:e.address}).toString())).then(function(t){if(!t.ok)throw new Error(\"Failed to fetch lnurl info: \"+t.status+\" \"+t.statusText);return Promise.resolve(t.json()).then(function(t){return Promise.resolve(e.parseLnUrlPayResponse(t.lnurlp)).then(function(){e.parseKeysendResponse(t.keysend),e.parseNostrResponse(t.nostr)})})})}catch(e){return Promise.reject(e)}},t.fetchWithoutProxy=function(){try{var e=this;return e.domain&&e.username?Promise.resolve(Promise.all([e.fetchLnurlData(),e.fetchKeysendData(),e.fetchNostrData()])).then(function(){}):Promise.resolve()}catch(e){return Promise.reject(e)}},t.fetchLnurlData=function(){try{var e=this;return Promise.resolve(fetch(e.lnurlpUrl())).then(function(t){var r=function(){if(t.ok)return Promise.resolve(t.json()).then(function(t){return Promise.resolve(e.parseLnUrlPayResponse(t)).then(function(){})})}();if(r&&r.then)return r.then(function(){})})}catch(e){return Promise.reject(e)}},t.fetchKeysendData=function(){try{var e=this;return Promise.resolve(fetch(e.keysendUrl())).then(function(t){var r=function(){if(t.ok)return Promise.resolve(t.json()).then(function(t){e.parseKeysendResponse(t)})}();if(r&&r.then)return r.then(function(){})})}catch(e){return Promise.reject(e)}},t.fetchNostrData=function(){try{var e=this;return Promise.resolve(fetch(e.nostrUrl())).then(function(t){var r=function(){if(t.ok)return Promise.resolve(t.json()).then(function(t){e.parseNostrResponse(t)})}();if(r&&r.then)return r.then(function(){})})}catch(e){return Promise.reject(e)}},t.lnurlpUrl=function(){return\"https://\"+this.domain+\"/.well-known/lnurlp/\"+this.username},t.keysendUrl=function(){return\"https://\"+this.domain+\"/.well-known/keysend/\"+this.username},t.nostrUrl=function(){return\"https://\"+this.domain+\"/.well-known/nostr.json?name=\"+this.username},t.generateInvoice=function(e){try{var t,r=function(e){var r=t&&t.pr&&t.pr.toString();if(!r)throw new Error(\"Invalid pay service invoice\");var n={pr:r};if(t&&t.verify&&(n.verify=t.verify.toString()),t&&t.successAction&&\"object\"==typeof t.successAction){var o=t.successAction,i=o.tag,s=o.description,a=o.url;\"message\"===i?n.successAction={tag:i,message:o.message}:\"url\"===i&&(n.successAction={tag:i,description:s,url:a})}return new B(n)},n=this,o=function(){if(n.options.proxy)return Promise.resolve(fetch(n.options.proxy+\"/generate-invoice?\"+new URLSearchParams(J({ln:n.address},e)).toString())).then(function(e){if(!e.ok)throw new Error(\"Failed to generate invoice: \"+e.status+\" \"+e.statusText);return Promise.resolve(e.json()).then(function(e){t=e.invoice})});if(!n.lnurlpData)throw new Error(\"No lnurlpData available. Please call fetch() first.\");if(!n.lnurlpData.callback||!z(n.lnurlpData.callback))throw new Error(\"Valid callback does not exist in lnurlpData\");var r=new URL(n.lnurlpData.callback);return r.search=new URLSearchParams(e).toString(),Promise.resolve(fetch(r.toString())).then(function(e){if(!e.ok)throw new Error(\"Failed to generate invoice: \"+e.status+\" \"+e.statusText);return Promise.resolve(e.json()).then(function(e){t=e})})}();return Promise.resolve(o&&o.then?o.then(r):r())}catch(e){return Promise.reject(e)}},t.requestInvoice=function(e){try{var t=this;if(!t.lnurlpData)throw new Error(\"No lnurlpData available. Please call fetch() first.\");var r=1e3*e.satoshi,n=t.lnurlpData,o=n.commentAllowed;if(!M({amount:r,min:n.min,max:n.max}))throw new Error(\"Invalid amount\");if(e.comment&&o&&o>0&&e.comment.length>o)throw new Error(\"The comment length must be \"+o+\" characters or fewer\");var i={amount:r.toString()};return e.comment&&(i.comment=e.comment),e.payerdata&&(i.payerdata=JSON.stringify(e.payerdata)),Promise.resolve(t.generateInvoice(i))}catch(e){return Promise.reject(e)}},t.boost=function(e,t){void 0===t&&(t=0);try{var r=this;if(!r.keysendData)throw new Error(\"No keysendData available. Please call fetch() first.\");var n=r.keysendData,o=n.destination,i=n.customKey,s=n.customValue,a=r.getWebLN();if(!a)throw new Error(\"WebLN not available\");return Promise.resolve(Z({destination:o,customKey:i,customValue:s,amount:t,boost:e},{webln:a}))}catch(e){return Promise.reject(e)}},t.zapInvoice=function(e,t){var r=e.satoshi,n=e.comment,o=e.relays,i=e.e;void 0===t&&(t={});try{var s=this;if(!s.lnurlpData)throw new Error(\"No lnurlpData available. Please call fetch() first.\");if(!s.nostrPubkey)throw new Error(\"Nostr Pubkey is missing\");var a=s.nostrPubkey,c=1e3*r,u=s.lnurlpData,h=u.allowsNostr;if(!M({amount:c,min:u.min,max:u.max}))throw new Error(\"Invalid amount\");if(!h)throw new Error(\"Your provider does not support zaps\");return Promise.resolve(H({satoshi:c,comment:n,p:a,e:i,relays:o},t)).then(function(e){var t={amount:c.toString(),nostr:JSON.stringify(e)};return Promise.resolve(s.generateInvoice(t))})}catch(i){return Promise.reject(i)}},t.zap=function(e,t){void 0===t&&(t={});try{var r=this.zapInvoice(e,t),n=this.getWebLN();if(!n)throw new Error(\"WebLN not available\");return Promise.resolve(n.enable()).then(function(){var e=n.sendPayment;return Promise.resolve(r).then(function(t){return e.call(n,t.paymentRequest)})})}catch(e){return Promise.reject(e)}},t.parseLnUrlPayResponse=function(e){try{var t=this,r=function(){if(e)return Promise.resolve(G(e)).then(function(e){t.lnurlpData=e})}();return Promise.resolve(r&&r.then?r.then(function(){}):void 0)}catch(e){return Promise.reject(e)}},t.parseKeysendResponse=function(e){e&&(this.keysendData=O(e))},t.parseNostrResponse=function(e){if(e){var t=V(e,this.username);this.nostrData=t[0],this.nostrPubkey=t[1],this.nostrRelays=t[2]}},e}(),ee=/*#__PURE__*/function(){function e(e){this.storage=void 0,this.storage=e||{}}var t=e.prototype;return t.getItem=function(e){return this.storage[e]},t.setItem=function(e,t){this.storage[e]=t},e}(),te=/*#__PURE__*/function(){function e(e){}var t=e.prototype;return t.getItem=function(e){return null},t.setItem=function(e,t){},e}(),re=function(e){for(var t,r=e.replace(\"L402\",\"\").replace(\"LSAT\",\"\").trim(),n={},o=/(\\w+)=(\"([^\"]*)\"|'([^']*)'|([^,]*))/g;null!==(t=o.exec(r));)n[t[1]]=t[3]||t[4]||t[5];return n},ne=new ee,oe=function(e,t,r){try{var n,o=function(r){return n?r:(t.headers[\"Accept-Authenticate\"]=i,Promise.resolve(fetch(e,t)).then(function(r){var n=r.headers.get(\"www-authenticate\");if(!n)return r;var o=re(n),c=o.token||o.macaroon,u=o.invoice;return Promise.resolve(s.enable()).then(function(){return Promise.resolve(s.sendPayment(u)).then(function(r){return a.setItem(e,JSON.stringify({token:c,preimage:r.preimage})),t.headers.Authorization=i+\" \"+c+\":\"+r.preimage,Promise.resolve(fetch(e,t))})})}))};r||(r={});var i=r.headerKey||\"L402\",s=r.webln||globalThis.webln;if(!s)throw new Error(\"WebLN is missing\");var a=r.store||ne;t||(t={}),t.cache=\"no-store\",t.mode=\"cors\",t.headers||(t.headers={});var c=a.getItem(e),u=function(){if(c){var r=JSON.parse(c);return t.headers.Authorization=i+\" \"+r.token+\":\"+r.preimage,Promise.resolve(fetch(e,t)).then(function(e){return n=1,e})}}();return Promise.resolve(u&&u.then?u.then(o):o(u))}catch(e){return Promise.reject(e)}},ie={__proto__:null,fetchWithL402:oe,MemoryStorage:ee,NoStorage:te,parseL402:re},se=function(e){try{var t=\"https://getalby.com/api/rates/\"+e.toLowerCase()+\".json\";return Promise.resolve(fetch(t)).then(function(e){if(!e.ok)throw new Error(\"Failed to fetch rate: \"+e.status+\" \"+e.statusText);return Promise.resolve(e.json()).then(function(e){return e.rate_float/1e8})})}catch(e){return Promise.reject(e)}},ae=function(e){var t=e.satoshi;return Promise.resolve(se(e.currency)).then(function(e){return Number(t)*e})},ce=function(e){var t=e.amount;return Promise.resolve(se(e.currency)).then(function(e){return Math.floor(Number(t)/e)})},ue=function(e){var t=e.currency,r=e.locale;return r||(r=\"en\"),Promise.resolve(ae({satoshi:e.satoshi,currency:t})).then(function(e){return e.toLocaleString(r,{style:\"currency\",currency:t})})},he={__proto__:null,getFiatBtcRate:se,getFiatValue:ae,getSatoshiValue:ce,getFormattedFiatValue:ue};export{Q as DEFAULT_PROXY,B as Invoice,X as LN_ADDRESS_REGEX,Y as LightningAddress,ee as MemoryStorage,te as NoStorage,E as decodeInvoice,oe as fetchWithL402,he as fiat,b as fromHexString,H as generateZapEvent,F as getEventHash,se as getFiatBtcRate,ae as getFiatValue,ue as getFormattedFiatValue,ce as getSatoshiValue,z as isUrl,M as isValidAmount,ie as l402,O as parseKeysendResponse,re as parseL402,G as parseLnUrlPayResponse,V as parseNostrResponse,Z as sendBoostagram,K as serializeEvent,C as validateEvent};\n","import { LN, nwc } from '@getalby/sdk';\nimport { WalletManager } from './wallet-manager.js';\nimport { PriceManager } from './price-manager.js';\nimport { StabilizationManager } from './stabilization-manager.js';\n\n// Main Application Class\nclass NWCApp {\n    constructor() {\n        this.walletManager = new WalletManager();\n        this.priceManager = new PriceManager();\n        this.stabilizationManager = new StabilizationManager(this.walletManager);\n\n        this.setupEventListeners();\n        this.makeGlobalFunctions();\n    }\n\n    setupEventListeners() {\n        // Listen for wallet connection changes to update stabilization UI\n        window.addEventListener('walletConnectionChanged', () => {\n            this.stabilizationManager.updateStabilizationUI();\n            this.stabilizationManager.updateWalletStabilizationDisplay();\n        });\n\n        // Setup currency selection handler\n        const currencySelect = document.getElementById('stabilization-currency');\n        if (currencySelect) {\n            currencySelect.addEventListener('change', () => {\n                this.stabilizationManager.updateStabilizationUI();\n            });\n        }\n\n        // Handle page load\n        window.addEventListener('load', () => {\n            this.initialize();\n        });\n    }\n\n    initialize() {\n        this.walletManager.log('NWC Demo page loaded');\n        this.walletManager.log('REAL NWC INTEGRATION with local dependencies - Use real wallet connection strings!');\n        this.walletManager.log('Supported wallets: Alby Hub, Coinos, Primal, lnwallet.app, Yakihonne...');\n\n        // Start Bitcoin price updates\n        this.priceManager.startPriceUpdates();\n\n        // Initialize stabilization UI\n        this.stabilizationManager.updateStabilizationUI();\n\n        // Load saved connection strings\n        this.walletManager.loadSavedConnectionStrings();\n\n        // Initialize price chart\n        this.priceManager.initializePriceChart();\n\n        // Load historical prices on first load if no data exists\n        const existingHistory = this.priceManager.getPriceHistory();\n        if (existingHistory.length === 0) {\n            this.priceManager.fetchHistoricalPrices();\n        }\n    }\n\n    // Make functions globally available for HTML onclick handlers\n    makeGlobalFunctions() {\n        // Wallet functions\n        window.connectWallet = (walletId) => this.walletManager.connectWallet(walletId);\n        window.disconnectWallet = (walletId) => this.walletManager.disconnectWallet(walletId);\n        window.getWalletInfo = (walletId) => this.walletManager.getWalletInfo(walletId);\n        window.getBalance = (walletId) => this.walletManager.getBalance(walletId);\n        window.createInvoice = (walletId) => this.walletManager.createInvoice(walletId);\n        window.payInvoice = (walletId) => this.walletManager.payInvoice(walletId);\n        window.listTransactions = (walletId) => this.walletManager.listTransactions(walletId);\n        window.payKeysend = (walletId) => this.walletManager.payKeysend(walletId);\n        window.saveConnectionString = (walletId) => this.walletManager.saveConnectionString(walletId);\n        window.clearConnectionString = (walletId) => this.walletManager.clearConnectionString(walletId);\n        window.toggleConnectionVisibility = (walletId) => this.walletManager.toggleConnectionVisibility(walletId);\n        window.clearLog = () => this.walletManager.clearLog();\n\n        // Price functions\n        window.fetchBitcoinPrice = () => this.priceManager.fetchBitcoinPrice();\n        window.startPriceUpdates = () => this.priceManager.startPriceUpdates();\n        window.stopPriceUpdates = () => this.priceManager.stopPriceUpdates();\n        window.fetchHistoricalPrices = () => this.priceManager.fetchHistoricalPrices();\n        window.updatePriceChart = () => this.priceManager.updatePriceChart();\n        window.clearAndReloadPriceData = () => this.priceManager.clearAndReloadPriceData();\n\n        // Stabilization functions\n        window.startStabilization = () => this.stabilizationManager.startStabilization();\n        window.stopStabilization = () => this.stabilizationManager.stopStabilization();\n    }\n}\n\n// Initialize the application\nnew NWCApp();","import { nwc } from '@getalby/sdk';\n\n// Wallet Management Module\nexport class WalletManager {\n    constructor() {\n        this.wallets = {\n            1: { isConnected: false, nwcClient: null, connectionData: null, transactionsSupported: null },\n            2: { isConnected: false, nwcClient: null, connectionData: null, transactionsSupported: null }\n        };\n    }\n\n    // Local Storage Functions\n    saveNWCString(walletId, nwcUrl) {\n        localStorage.setItem(`nwc-wallet-${walletId}`, nwcUrl);\n        this.log(`Wallet ${walletId}: NWC string saved`);\n    }\n\n    loadNWCString(walletId) {\n        return localStorage.getItem(`nwc-wallet-${walletId}`) || '';\n    }\n\n    clearNWCString(walletId) {\n        localStorage.removeItem(`nwc-wallet-${walletId}`);\n        this.log(`Wallet ${walletId}: Saved NWC string deleted`);\n    }\n\n    log(message) {\n        const logElement = document.getElementById('debug-log');\n        const timestamp = new Date().toLocaleTimeString();\n        logElement.textContent += `[${timestamp}] ${message}\\n`;\n        logElement.scrollTop = logElement.scrollHeight;\n    }\n\n    updateConnectionStatus(walletId, status, message) {\n        const statusElement = document.getElementById(`connection-status-${walletId}`);\n        const badgeClass = status === 'connected' ? 'bg-success' :\n                          status === 'connecting' ? 'bg-warning' : 'bg-secondary';\n        statusElement.className = `badge ${badgeClass} status-badge`;\n        statusElement.textContent = message;\n    }\n\n    toggleConnectionVisibility(walletId) {\n        const textarea = document.getElementById(`nwc-url-${walletId}`);\n        const toggleBtn = document.getElementById(`toggle-visibility-${walletId}`);\n\n        const isHidden = textarea.style.webkitTextSecurity === 'disc';\n\n        if (isHidden) {\n            // Show text\n            textarea.style.webkitTextSecurity = 'none';\n            toggleBtn.textContent = '🙈';\n            toggleBtn.title = 'Connection String verstecken';\n        } else {\n            // Hide text\n            textarea.style.webkitTextSecurity = 'disc';\n            toggleBtn.textContent = '👁️';\n            toggleBtn.title = 'Connection String anzeigen';\n        }\n    }\n\n    async connectWallet(walletId) {\n        const nwcUrl = document.getElementById(`nwc-url-${walletId}`).value;\n\n        if (!nwcUrl) {\n            alert('Please enter a valid NWC connection string');\n            return;\n        }\n\n        if (!nwcUrl.startsWith('nostr+walletconnect://')) {\n            alert('Invalid NWC connection string. Must start with \"nostr+walletconnect://\"');\n            return;\n        }\n\n        this.log(`Wallet ${walletId}: Attempting to connect real wallet...`);\n        this.updateConnectionStatus(walletId, 'connecting', 'Connecting...');\n\n        try {\n            // Create new NWC client with credentials\n            this.wallets[walletId].nwcClient = new nwc.NWCClient({ nostrWalletConnectUrl: nwcUrl });\n\n            // Test connection by getting wallet info\n            const info = await this.wallets[walletId].nwcClient.getInfo();\n\n            this.wallets[walletId].isConnected = true;\n            this.wallets[walletId].connectionData = { url: nwcUrl };\n            this.updateConnectionStatus(walletId, 'connected', 'Connected');\n\n            // Disable connection form when connected\n            document.getElementById(`nwc-url-${walletId}`).disabled = true;\n            document.getElementById(`toggle-visibility-${walletId}`).disabled = true;\n            document.getElementById(`connect-btn-${walletId}`).disabled = true;\n            document.getElementById(`disconnect-btn-${walletId}`).disabled = false;\n\n            // Auto-save connection string\n            this.saveNWCString(walletId, nwcUrl);\n\n            this.log(`Wallet ${walletId}: Successfully connected!`);\n            this.log(`Wallet ${walletId}: Alias: ${info.alias || 'N/A'}`);\n            this.log(`Wallet ${walletId}: Pubkey: ${info.pubkey ? info.pubkey.substring(0, 20) + '...' : 'N/A'}`);\n            this.log(`Wallet ${walletId}: Methods: ${info.methods ? info.methods.join(', ') : 'N/A'}`);\n\n            // Display initial wallet info\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(info, null, 2);\n\n            // Trigger stabilization UI update\n            window.dispatchEvent(new CustomEvent('walletConnectionChanged'));\n\n        } catch (error) {\n            this.updateConnectionStatus(walletId, 'disconnected', 'Connection failed');\n            this.log(`Wallet ${walletId}: Error connecting: ${error.message}`);\n            console.error(`Wallet ${walletId} NWC Connection Error:`, error);\n        }\n    }\n\n    disconnectWallet(walletId) {\n        this.log(`Wallet ${walletId}: Disconnecting...`);\n        this.wallets[walletId].isConnected = false;\n        this.wallets[walletId].nwcClient = null;\n        this.wallets[walletId].connectionData = null;\n        this.wallets[walletId].transactionsSupported = null;\n        this.updateConnectionStatus(walletId, 'disconnected', 'Not connected');\n\n        // Re-enable connection form when disconnected\n        document.getElementById(`nwc-url-${walletId}`).disabled = false;\n        document.getElementById(`toggle-visibility-${walletId}`).disabled = false;\n        document.getElementById(`connect-btn-${walletId}`).disabled = false;\n        document.getElementById(`disconnect-btn-${walletId}`).disabled = true;\n        document.getElementById(`wallet-info-${walletId}`).textContent = '';\n        document.getElementById(`payment-result-${walletId}`).textContent = '';\n        this.log(`Wallet ${walletId}: Successfully disconnected`);\n\n        // Trigger stabilization UI update\n        window.dispatchEvent(new CustomEvent('walletConnectionChanged'));\n    }\n\n    async getWalletInfo(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        try {\n            this.log(`Wallet ${walletId}: get_info request sent...`);\n            const info = await this.wallets[walletId].nwcClient.getInfo();\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(info, null, 2);\n            this.log(`Wallet ${walletId}: get_info response received`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error in get_info: ${error.message}`);\n            document.getElementById(`wallet-info-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n\n    async getBalance(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        try {\n            this.log(`Wallet ${walletId}: get_balance request sent...`);\n            const balance = await this.wallets[walletId].nwcClient.getBalance();\n\n            // Convert balance display to show correct sats\n            const displayBalance = {\n                ...balance,\n                balance_sats: Math.round(balance.balance / 1000),\n                balance_millisats: balance.balance\n            };\n\n            document.getElementById(`wallet-info-${walletId}`).textContent = JSON.stringify(displayBalance, null, 2);\n            this.log(`Wallet ${walletId}: Balance: ${Math.round(balance.balance / 1000)} sats (${balance.balance} millisats)`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error in get_balance: ${error.message}`);\n            document.getElementById(`wallet-info-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n\n    async createInvoice(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        const amount = prompt('Enter amount in Satoshis:', '1000');\n        if (!amount) return;\n\n        const description = prompt('Description (optional):', `NWC Demo Invoice - Wallet ${walletId}`);\n\n        try {\n            this.log(`Wallet ${walletId}: make_invoice request for ${amount} sats...`);\n            const invoice = await this.wallets[walletId].nwcClient.makeInvoice({\n                amount: parseInt(amount) * 1000, // Convert to millisats\n                description: description || `NWC Demo Invoice - Wallet ${walletId}`\n            });\n\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(invoice, null, 2);\n            this.log(`Wallet ${walletId}: Invoice created successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error creating invoice: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n\n    async payInvoice(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        const invoice = prompt('Enter Lightning Invoice:', 'lnbc...');\n        if (!invoice) return;\n\n        try {\n            this.log(`Wallet ${walletId}: pay_invoice request sent...`);\n            const result = await this.wallets[walletId].nwcClient.payInvoice({ invoice: invoice });\n\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(result, null, 2);\n            this.log(`Wallet ${walletId}: Payment sent successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error paying invoice: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n\n    async listTransactions(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        try {\n            this.log(`Wallet ${walletId}: list_transactions request sent...`);\n\n            const transactions = await this.wallets[walletId].nwcClient.listTransactions({\n                from: 0,\n                until: Math.floor(Date.now() / 1000),\n                limit: 50,\n                offset: 0,\n                unpaid: false,\n                type: undefined\n            });\n\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(transactions, null, 2);\n            this.log(`Wallet ${walletId}: ${transactions.transactions ? transactions.transactions.length : 0} transactions retrieved`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error retrieving transactions: ${error.message}`);\n            console.error(`Wallet ${walletId} listTransactions error:`, error);\n\n            // Fallback: Try without parameters\n            try {\n                this.log(`Wallet ${walletId}: Trying listTransactions without parameters...`);\n                const transactions = await this.wallets[walletId].nwcClient.listTransactions({});\n                document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(transactions, null, 2);\n                this.log(`Wallet ${walletId}: Transactions retrieved with fallback method`);\n            } catch (fallbackError) {\n                this.log(`Wallet ${walletId}: Fallback also failed: ${fallbackError.message}`);\n                document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}\\nFallback Error: ${fallbackError.message}`;\n            }\n        }\n    }\n\n    async payKeysend(walletId) {\n        if (!this.wallets[walletId].isConnected || !this.wallets[walletId].nwcClient) {\n            alert(`Please connect Wallet ${walletId} first`);\n            return;\n        }\n\n        const pubkey = prompt('Recipient Pubkey:', '02...');\n        const amount = prompt('Amount in Satoshis:', '1000');\n\n        if (!pubkey || !amount) return;\n\n        try {\n            this.log(`Wallet ${walletId}: pay_keysend request for ${amount} sats to ${pubkey.substring(0, 10)}...`);\n\n            const result = await this.wallets[walletId].nwcClient.payKeysend({\n                pubkey: pubkey,\n                amount: parseInt(amount) * 1000 // Convert to millisats\n            });\n\n            document.getElementById(`payment-result-${walletId}`).textContent = JSON.stringify(result, null, 2);\n            this.log(`Wallet ${walletId}: Keysend payment sent successfully`);\n        } catch (error) {\n            this.log(`Wallet ${walletId}: Error sending keysend: ${error.message}`);\n            document.getElementById(`payment-result-${walletId}`).textContent = `Error: ${error.message}`;\n        }\n    }\n\n    saveConnectionString(walletId) {\n        const nwcUrl = document.getElementById(`nwc-url-${walletId}`).value;\n        if (!nwcUrl) {\n            alert('No connection string to save');\n            return;\n        }\n        this.saveNWCString(walletId, nwcUrl);\n    }\n\n    clearConnectionString(walletId) {\n        this.clearNWCString(walletId);\n        document.getElementById(`nwc-url-${walletId}`).value = '';\n    }\n\n    loadSavedConnectionStrings() {\n        // Load saved connection strings for both wallets\n        for (let walletId = 1; walletId <= 2; walletId++) {\n            const savedUrl = this.loadNWCString(walletId);\n            if (savedUrl) {\n                const textarea = document.getElementById(`nwc-url-${walletId}`);\n                textarea.value = savedUrl;\n                // Ensure the text is properly masked\n                textarea.style.webkitTextSecurity = 'disc';\n                this.log(`Wallet ${walletId}: Saved NWC string loaded`);\n            }\n        }\n    }\n\n    clearLog() {\n        document.getElementById('debug-log').textContent = 'Debug messages will be displayed here...\\n';\n    }\n}","// Bitcoin Price Management Module\nexport class PriceManager {\n    constructor() {\n        this.priceUpdateInterval = null;\n        this.priceChart = null;\n        this.PRICE_STORAGE_KEY = 'nwc-price-history';\n        this.MAX_PRICE_HISTORY = 10000; // Keep last 10,000 price points\n        this.PRICE_CHANGE_THRESHOLD = 0.5; // Minimum 0.5% price change to store point\n    }\n\n    // Price Storage Functions\n    savePriceHistory(priceData) {\n        try {\n            const history = this.getPriceHistory();\n            const timestamp = Date.now();\n\n            // Check if we should save this point\n            if (history.length > 0) {\n                const lastPoint = history[history.length - 1];\n                const timeDiff = timestamp - lastPoint.timestamp;\n\n                // Minimum interval: 1 hour (to match historical data pattern)\n                const minInterval = 60 * 60 * 1000; // 1 hour in milliseconds\n\n                // Check for significant price change\n                const shouldSave = Object.keys(priceData).some(currency => {\n                    const oldPrice = lastPoint.prices[currency];\n                    const newPrice = priceData[currency];\n                    const changePercent = Math.abs((newPrice - oldPrice) / oldPrice * 100);\n                    return changePercent >= this.PRICE_CHANGE_THRESHOLD;\n                });\n\n                // Only save if significant change or enough time has passed\n                const hoursPassed = timeDiff / (1000 * 60 * 60);\n\n                if (hoursPassed < 1) {\n                    // Too soon, just update timestamp of last point\n                    lastPoint.timestamp = timestamp;\n                    localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n                    return;\n                } else if (hoursPassed < 2 && !shouldSave) {\n                    // Between 1-2 hours but no significant change, skip\n                    lastPoint.timestamp = timestamp;\n                    localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n                    return;\n                }\n            }\n\n            // Add new price point\n            history.push({\n                timestamp: timestamp,\n                prices: { ...priceData }\n            });\n\n            // Keep only last MAX_PRICE_HISTORY points\n            if (history.length > this.MAX_PRICE_HISTORY) {\n                history.splice(0, history.length - this.MAX_PRICE_HISTORY);\n            }\n\n            localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(history));\n            console.log(`💾 Neuer Preispunkt gespeichert (${history.length} total)`);\n        } catch (error) {\n            console.error('Error saving price history:', error);\n        }\n    }\n\n    getPriceHistory() {\n        try {\n            const stored = localStorage.getItem(this.PRICE_STORAGE_KEY);\n            return stored ? JSON.parse(stored) : [];\n        } catch (error) {\n            console.error('Error loading price history:', error);\n            return [];\n        }\n    }\n\n    getFilteredPriceHistory(timeRange) {\n        const history = this.getPriceHistory();\n        if (history.length === 0) return [];\n\n        const now = Date.now();\n        let timeWindow;\n\n        switch (timeRange) {\n            case '12h':\n                timeWindow = 12 * 60 * 60 * 1000; // 12 hours\n                break;\n            case '24h':\n                timeWindow = 24 * 60 * 60 * 1000; // 24 hours\n                break;\n            case '2d':\n                timeWindow = 2 * 24 * 60 * 60 * 1000; // 2 days\n                break;\n            case '4d':\n                timeWindow = 4 * 24 * 60 * 60 * 1000; // 4 days\n                break;\n            case '7d':\n                timeWindow = 7 * 24 * 60 * 60 * 1000; // 7 days\n                break;\n            default:\n                timeWindow = 12 * 60 * 60 * 1000; // Default to 12 hours\n        }\n\n        const cutoffTime = now - timeWindow;\n        return history.filter(point => point.timestamp >= cutoffTime);\n    }\n\n    clearPriceHistory() {\n        localStorage.removeItem(this.PRICE_STORAGE_KEY);\n        this.log('Price history cleared');\n    }\n\n    async clearAndReloadPriceData() {\n        try {\n            this.log('🗑️ Clearing all price data...');\n\n            // Clear existing price history\n            localStorage.removeItem(this.PRICE_STORAGE_KEY);\n\n            // Clear chart\n            if (this.priceChart) {\n                this.priceChart.data.labels = [];\n                this.priceChart.data.datasets.forEach(dataset => {\n                    dataset.data = [];\n                });\n                this.priceChart.update();\n            }\n\n            this.log('✅ Price data cleared');\n\n            // Reload fresh historical data\n            await this.fetchHistoricalPrices();\n\n            this.log('✅ Fresh price data loaded');\n\n        } catch (error) {\n            this.log(`❌ Error reloading price data: ${error.message}`);\n            console.error('Error clearing and reloading price data:', error);\n        }\n    }\n\n    log(message) {\n        const logElement = document.getElementById('debug-log');\n        if (logElement) {\n            const timestamp = new Date().toLocaleTimeString();\n            logElement.textContent += `[${timestamp}] ${message}\\n`;\n            logElement.scrollTop = logElement.scrollHeight;\n        }\n    }\n\n    // Historical Price Functions\n    async fetchHistoricalPrices() {\n        try {\n            this.log('📈 Loading real historical prices from mempool.space...');\n\n            const response = await fetch('https://mempool.space/api/v1/historical-price');\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const data = await response.json();\n            this.log(`📈 ${data.prices.length} historical data points received from API`);\n\n            // Convert mempool.space data to our format\n            const convertedHistory = data.prices.map(item => ({\n                timestamp: item.time * 1000, // Convert Unix timestamp to milliseconds\n                prices: {\n                    USD: item.USD,\n                    EUR: item.EUR,\n                    GBP: item.GBP,\n                    CHF: item.CHF,\n                    CAD: item.CAD,\n                    JPY: item.JPY,\n                    AUD: item.AUD // Also include AUD if we want to expand later\n                }\n            }));\n\n            // Sort by timestamp (oldest first) and limit to our storage limit\n            const sortedHistory = convertedHistory\n                .sort((a, b) => a.timestamp - b.timestamp)\n                .slice(-this.MAX_PRICE_HISTORY);\n\n            // Save to localStorage\n            localStorage.setItem(this.PRICE_STORAGE_KEY, JSON.stringify(sortedHistory));\n\n            this.log(`📈 ${sortedHistory.length} real historical price points saved`);\n\n            // Update chart if it exists\n            if (this.priceChart) {\n                this.updatePriceChart();\n            }\n\n        } catch (error) {\n            this.log(`📈 Error loading historical prices: ${error.message}`);\n            console.error('Historical price fetch error:', error);\n\n            // Fallback: Log that we're using existing data\n            const existingHistory = this.getPriceHistory();\n            if (existingHistory.length > 0) {\n                this.log(`📈 Using ${existingHistory.length} existing price points`);\n            } else {\n                this.log('📈 No historical data available');\n            }\n        }\n    }\n\n    // Bitcoin Price Functions\n    async fetchBitcoinPrice() {\n        try {\n            this.log('Fetching Bitcoin price...');\n\n            const response = await fetch('https://mempool.space/api/v1/prices');\n\n            if (!response.ok) {\n                throw new Error(`HTTP error! status: ${response.status}`);\n            }\n\n            const priceData = await response.json();\n\n            // Update price displays\n            this.updatePriceDisplay(priceData);\n\n            // Update live price in chart\n            this.updateLivePriceInChart(priceData);\n\n            this.log('Bitcoin price updated successfully');\n\n        } catch (error) {\n            this.log(`Error fetching Bitcoin price: ${error.message}`);\n            console.error('Bitcoin price fetch error:', error);\n\n            // Update displays with error\n            const currencies = ['usd', 'eur', 'gbp', 'chf', 'cad', 'jpy'];\n            currencies.forEach(currency => {\n                const priceEl = document.getElementById(`price-${currency}`);\n                const satsEl = document.getElementById(`sats-${currency}`);\n                if (priceEl) priceEl.textContent = 'Error';\n                if (satsEl) satsEl.textContent = 'Error';\n            });\n            const updatedEl = document.getElementById('price-updated');\n            if (updatedEl) updatedEl.textContent = 'Last Update: Error';\n        }\n    }\n\n    updateLivePriceInChart(priceData) {\n        if (!this.priceChart) return;\n\n        const now = Date.now();\n        const selectedRange = document.querySelector('input[name=\"timeRange\"]:checked')?.value || '12h';\n\n        // Get current history\n        const history = this.getPriceHistory();\n\n        // Create current price point\n        const currentPricePoint = {\n            timestamp: now,\n            prices: {\n                USD: priceData.USD,\n                EUR: priceData.EUR,\n                GBP: priceData.GBP,\n                CHF: priceData.CHF,\n                CAD: priceData.CAD,\n                JPY: priceData.JPY\n            }\n        };\n\n        // Create temporary history with current price\n        const liveHistory = [...history, currentPricePoint];\n\n        // Filter for selected time range\n        const filteredHistory = this.filterHistoryByRange(liveHistory, selectedRange);\n\n        if (filteredHistory.length === 0) return;\n\n        // Update chart with live data\n        const labels = filteredHistory.map(item => item.timestamp);\n        const currencies = ['USD', 'EUR', 'GBP', 'CHF', 'CAD', 'JPY'];\n\n        this.priceChart.data.labels = labels;\n\n        currencies.forEach((currency, index) => {\n            const dataPoints = filteredHistory.map((item) => ({\n                x: item.timestamp,\n                y: item.prices[currency]\n            }));\n            this.priceChart.data.datasets[index].data = dataPoints;\n        });\n\n        // Update chart with no animation for smooth live updates\n        this.priceChart.update('none');\n\n        // Save to persistent history only according to our rules\n        this.savePriceHistory(priceData);\n    }\n\n    filterHistoryByRange(history, timeRange) {\n        if (history.length === 0) return [];\n\n        const now = Date.now();\n        let timeWindow;\n\n        switch (timeRange) {\n            case '12h':\n                timeWindow = 12 * 60 * 60 * 1000;\n                break;\n            case '24h':\n                timeWindow = 24 * 60 * 60 * 1000;\n                break;\n            case '2d':\n                timeWindow = 2 * 24 * 60 * 60 * 1000;\n                break;\n            case '4d':\n                timeWindow = 4 * 24 * 60 * 60 * 1000;\n                break;\n            case '7d':\n                timeWindow = 7 * 24 * 60 * 60 * 1000;\n                break;\n            default:\n                timeWindow = 12 * 60 * 60 * 1000;\n        }\n\n        const cutoffTime = now - timeWindow;\n        return history.filter(point => point.timestamp >= cutoffTime);\n    }\n\n    updatePriceDisplay(priceData) {\n        // Format and display prices\n        const currencies = {\n            usd: { symbol: '$', value: priceData.USD, unit: '$1' },\n            eur: { symbol: '€', value: priceData.EUR, unit: '€1' },\n            gbp: { symbol: '£', value: priceData.GBP, unit: '£1' },\n            chf: { symbol: '₣', value: priceData.CHF, unit: '₣1' },\n            cad: { symbol: 'C$', value: priceData.CAD, unit: 'C$1' },\n            jpy: { symbol: '¥', value: priceData.JPY, unit: '¥1' }\n        };\n\n        Object.entries(currencies).forEach(([currency, data]) => {\n            const priceElement = document.getElementById(`price-${currency}`);\n            const satsElement = document.getElementById(`sats-${currency}`);\n\n            if (priceElement && satsElement && data.value) {\n                // Format Bitcoin price\n                const formattedValue = currency === 'jpy' ?\n                    Math.round(data.value).toLocaleString() :\n                    data.value.toLocaleString('de-DE', {\n                        minimumFractionDigits: 0,\n                        maximumFractionDigits: 0\n                    });\n\n                priceElement.textContent = `${data.symbol} ${formattedValue}`;\n\n                // Calculate satoshis for 1 unit of currency\n                const satoshisPerUnit = Math.round(100000000 / data.value);\n                const formattedSats = satoshisPerUnit.toLocaleString('de-DE');\n\n                satsElement.textContent = `${formattedSats} sats = ${data.unit}`;\n            }\n        });\n\n        // Update timestamp\n        const now = new Date();\n        const timeString = now.toLocaleTimeString('en-US');\n        const updatedEl = document.getElementById('price-updated');\n        if (updatedEl) updatedEl.textContent = `Last Update: ${timeString}`;\n    }\n\n    startPriceUpdates() {\n        // Clear existing interval\n        if (this.priceUpdateInterval) {\n            clearInterval(this.priceUpdateInterval);\n        }\n\n        // Fetch price immediately\n        this.fetchBitcoinPrice();\n\n        // Set up auto-refresh every 30 seconds\n        this.priceUpdateInterval = setInterval(() => this.fetchBitcoinPrice(), 30000);\n\n        this.log('Bitcoin price auto-update started (every 30 seconds)');\n    }\n\n    stopPriceUpdates() {\n        if (this.priceUpdateInterval) {\n            clearInterval(this.priceUpdateInterval);\n            this.priceUpdateInterval = null;\n            this.log('Bitcoin price auto-update stopped');\n        }\n    }\n\n    // Chart Functions\n    initializePriceChart() {\n        const ctx = document.getElementById('priceChart')?.getContext('2d');\n        if (!ctx) return;\n\n        this.priceChart = new Chart(ctx, {\n            type: 'line',\n            data: {\n                labels: [],\n                datasets: [\n                    {\n                        label: 'USD ($)',\n                        data: [],\n                        borderColor: '#0066cc',\n                        backgroundColor: 'rgba(0, 102, 204, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'EUR (€)',\n                        data: [],\n                        borderColor: '#dc3545',\n                        backgroundColor: 'rgba(220, 53, 69, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'GBP (£)',\n                        data: [],\n                        borderColor: '#28a745',\n                        backgroundColor: 'rgba(40, 167, 69, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'CHF',\n                        data: [],\n                        borderColor: '#ffc107',\n                        backgroundColor: 'rgba(255, 193, 7, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'CAD',\n                        data: [],\n                        borderColor: '#6f42c1',\n                        backgroundColor: 'rgba(111, 66, 193, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y'\n                    },\n                    {\n                        label: 'JPY (¥)',\n                        data: [],\n                        borderColor: '#fd7e14',\n                        backgroundColor: 'rgba(253, 126, 20, 0.1)',\n                        borderWidth: 2,\n                        fill: false,\n                        tension: 0.4,\n                        pointRadius: 1,\n                        yAxisID: 'y1'\n                    }\n                ]\n            },\n            options: {\n                responsive: true,\n                maintainAspectRatio: false,\n                interaction: {\n                    mode: 'index',\n                    intersect: false\n                },\n                plugins: {\n                    legend: {\n                        display: true,\n                        position: 'top',\n                        onClick: function(e, legendItem, legend) {\n                            const index = legendItem.datasetIndex;\n                            const chart = legend.chart;\n                            const isVisible = chart.isDatasetVisible(index);\n                            chart.setDatasetVisibility(index, !isVisible);\n                            chart.update('none');\n                        }\n                    },\n                    tooltip: {\n                        mode: 'index',\n                        intersect: false,\n                        callbacks: {\n                            title: function(context) {\n                                return 'Bitcoin Preis';\n                            },\n                            label: function(context) {\n                                const currency = context.dataset.label;\n                                const value = context.parsed.y;\n                                return `${currency}: ${value.toLocaleString('de-DE')}`;\n                            }\n                        }\n                    }\n                },\n                scales: {\n                    x: {\n                        type: 'linear',\n                        position: 'bottom',\n                        min: function(context) {\n                            const data = context.chart.data.labels;\n                            return data.length > 0 ? Math.min(...data) : 0;\n                        },\n                        max: function(context) {\n                            const data = context.chart.data.labels;\n                            return data.length > 0 ? Math.max(...data) : 0;\n                        },\n                        grid: {\n                            color: 'rgba(0, 0, 0, 0.1)'\n                        },\n                        ticks: {\n                            callback: function(value) {\n                                const date = new Date(value);\n                                return date.toLocaleTimeString('de-DE', {\n                                    hour: '2-digit',\n                                    minute: '2-digit'\n                                });\n                            },\n                            maxTicksLimit: 8\n                        }\n                    },\n                    y: {\n                        type: 'linear',\n                        display: true,\n                        position: 'left',\n                        beginAtZero: false,\n                        title: {\n                            display: true,\n                            text: 'USD/EUR/GBP/CHF/CAD'\n                        },\n                        grid: {\n                            color: 'rgba(0, 0, 0, 0.1)'\n                        }\n                    },\n                    y1: {\n                        type: 'linear',\n                        display: true,\n                        position: 'right',\n                        beginAtZero: false,\n                        title: {\n                            display: true,\n                            text: 'JPY (¥)'\n                        },\n                        grid: {\n                            drawOnChartArea: false\n                        }\n                    }\n                }\n            }\n        });\n\n        // Update chart initially\n        this.updatePriceChart();\n    }\n\n    updatePriceChart() {\n        if (!this.priceChart) return;\n\n        // Get selected time range\n        const selectedRange = document.querySelector('input[name=\"timeRange\"]:checked')?.value || '12h';\n        const history = this.getFilteredPriceHistory(selectedRange);\n\n        if (history.length === 0) {\n            this.priceChart.data.labels = [];\n            this.priceChart.data.datasets.forEach(dataset => {\n                dataset.data = [];\n            });\n            this.priceChart.update();\n            return;\n        }\n\n        // Prepare data for chart\n        const labels = history.map(item => item.timestamp);\n        const currencies = ['USD', 'EUR', 'GBP', 'CHF', 'CAD', 'JPY'];\n\n        // Update chart data\n        this.priceChart.data.labels = labels;\n\n        currencies.forEach((currency, index) => {\n            const dataPoints = history.map((item) => ({\n                x: item.timestamp,\n                y: item.prices[currency]\n            }));\n            this.priceChart.data.datasets[index].data = dataPoints;\n        });\n\n        // Update chart\n        this.priceChart.update('none'); // No animation for smoother updates\n    }\n}","// Balance Stabilization Manager Module\nexport class StabilizationManager {\n    constructor(walletManager) {\n        this.walletManager = walletManager;\n        this.stabilizationData = {\n            active: false,\n            currency: null,\n            initialBalance: 0,\n            targetValue: 0,\n            initialPrice: 0,\n            checkInterval: null,\n            threshold: 1, // minimum sats difference to trigger rebalancing\n            lastRebalanceTime: 0,\n            rebalanceMinInterval: 5000, // minimum 5 seconds between rebalances\n            errorCount: 0,\n            maxErrors: 5\n        };\n    }\n\n    log(message) {\n        this.walletManager.log(message);\n    }\n\n    async startStabilization() {\n        const currency = document.getElementById('stabilization-currency').value;\n\n        if (!currency) {\n            alert('Please select a currency');\n            return;\n        }\n\n        if (!this.walletManager.wallets[2].isConnected || !this.walletManager.wallets[2].nwcClient) {\n            alert('Stability Receiver must be connected for stabilization');\n            return;\n        }\n\n        if (!this.walletManager.wallets[1].isConnected || !this.walletManager.wallets[1].nwcClient) {\n            alert('Stability Provider must be connected for rebalancing');\n            return;\n        }\n\n        try {\n            this.log(`💱 Starting stabilization for ${currency.toUpperCase()}...`);\n\n            // Get current balance of Stability Receiver\n            const balanceResponse = await this.walletManager.wallets[2].nwcClient.getBalance();\n            // Convert from millisats to sats\n            const currentBalance = Math.round(balanceResponse.balance / 1000);\n\n            // Get current Bitcoin prices\n            const response = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await response.json();\n\n            const currentPrice = priceData[currency.toUpperCase()];\n            if (!currentPrice) {\n                throw new Error(`Price for ${currency.toUpperCase()} not available`);\n            }\n\n            // Calculate target value in selected currency\n            const targetValue = (currentBalance / 100000000) * currentPrice;\n\n            // Store stabilization data\n            this.stabilizationData = {\n                active: true,\n                currency: currency,\n                initialBalance: currentBalance,\n                targetValue: targetValue,\n                initialPrice: currentPrice,\n                checkInterval: null,\n                threshold: 1,\n                lastRebalanceTime: 0,\n                rebalanceMinInterval: 5000,\n                errorCount: 0,\n                maxErrors: 5\n            };\n\n            // Update UI\n            this.updateStabilizationUI();\n\n            // Start monitoring with longer interval to reduce timeout issues\n            this.stabilizationData.checkInterval = setInterval(() => this.checkRebalancing(), 15000); // every 15 seconds\n\n            this.log(`💱 Stabilization active: ${currentBalance} sats = ${targetValue.toFixed(2)} ${currency.toUpperCase()}`);\n            this.log(`💱 Monitoring started (every 15 seconds with timeout protection)`);\n\n        } catch (error) {\n            this.log(`💱 Error starting stabilization: ${error.message}`);\n            console.error('Stabilization start error:', error);\n        }\n    }\n\n    async stopStabilization() {\n        if (!this.stabilizationData.active) return;\n\n        this.log('💱 Stopping stabilization...');\n\n        // Clear monitoring interval\n        if (this.stabilizationData.checkInterval) {\n            clearInterval(this.stabilizationData.checkInterval);\n        }\n\n        // Reset stabilization data\n        this.stabilizationData = {\n            active: false,\n            currency: null,\n            initialBalance: 0,\n            targetValue: 0,\n            initialPrice: 0,\n            checkInterval: null,\n            threshold: 1,\n            lastRebalanceTime: 0,\n            rebalanceMinInterval: 5000,\n            errorCount: 0,\n            maxErrors: 5\n        };\n\n        // Update UI\n        this.updateStabilizationUI();\n\n        this.log('💱 Stabilization stopped');\n    }\n\n    async checkRebalancing() {\n        if (!this.stabilizationData.active) return;\n\n        try {\n            // Get current prices\n            const response = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await response.json();\n            const currentPrice = priceData[this.stabilizationData.currency.toUpperCase()];\n\n            // Get current balance of Stability Receiver\n            const balanceResponse = await this.walletManager.wallets[2].nwcClient.getBalance();\n            // Convert from millisats to sats\n            const currentBalance = Math.round(balanceResponse.balance / 1000);\n\n            // Calculate current value in target currency\n            const currentValue = (currentBalance / 100000000) * currentPrice;\n\n            // Calculate required balance to maintain target value\n            const requiredBalance = Math.round((this.stabilizationData.targetValue / currentPrice) * 100000000);\n            const difference = currentBalance - requiredBalance;\n\n            // Update status display\n            this.updateStabilizationStatus(currentBalance, currentValue, requiredBalance, difference);\n\n            // Update wallet displays\n            this.updateWalletStabilizationDisplay();\n\n            // Check if rebalancing is needed and allowed\n            const now = Date.now();\n            const timeSinceLastRebalance = now - this.stabilizationData.lastRebalanceTime;\n\n            // Debug logging\n            this.log(`💱 Debug: difference=${difference}, abs=${Math.abs(difference)}, lastRebalance=${this.stabilizationData.lastRebalanceTime}, timeSince=${timeSinceLastRebalance}`);\n\n            // Get current threshold from UI\n            const currentThreshold = parseInt(document.getElementById('rebalance-threshold').value) || 1;\n            this.stabilizationData.threshold = currentThreshold;\n\n            if (Math.abs(difference) >= this.stabilizationData.threshold) {\n                if (timeSinceLastRebalance >= this.stabilizationData.rebalanceMinInterval) {\n                    this.log(`💱 Rebalancing needed: ${difference > 0 ? '+' : ''}${difference} sats difference`);\n                    await this.performRebalancing(difference);\n                } else {\n                    const waitTime = Math.round((this.stabilizationData.rebalanceMinInterval - timeSinceLastRebalance) / 1000);\n                    if (!isNaN(waitTime) && waitTime > 0) {\n                        this.log(`💱 Rebalancing required (${difference > 0 ? '+' : ''}${difference} sats), but waiting ${waitTime}s (cooldown)`);\n                    } else {\n                        this.log(`💱 Rebalancing required (${difference > 0 ? '+' : ''}${difference} sats), starting immediately`);\n                        await this.performRebalancing(difference);\n                    }\n                }\n            } else {\n                // Log when difference is below threshold\n                if (Math.abs(difference) > 0) {\n                    this.log(`💱 Small difference: ${difference > 0 ? '+' : ''}${difference} sats (below ${this.stabilizationData.threshold} sats threshold)`);\n                }\n            }\n\n            // Reset error counter on successful check\n            this.stabilizationData.errorCount = 0;\n\n        } catch (error) {\n            this.stabilizationData.errorCount++;\n            this.log(`💱 Error in rebalancing check (${this.stabilizationData.errorCount}/${this.stabilizationData.maxErrors}): ${error.message}`);\n            console.error('Rebalancing check error:', error);\n\n            // Stop stabilization if too many errors\n            if (this.stabilizationData.errorCount >= this.stabilizationData.maxErrors) {\n                this.log(`💱 Too many errors (${this.stabilizationData.maxErrors}), stopping stabilization`);\n                this.stopStabilization();\n            }\n        }\n    }\n\n    async performRebalancing(difference) {\n        const amount = Math.abs(difference);\n\n        try {\n            this.log(`💱 Starte Rebalancing: ${amount} sats (${difference > 0 ? 'Receiver → Provider' : 'Provider → Receiver'})`);\n\n            // Add timeout wrapper for all operations\n            const timeoutPromise = new Promise((_, reject) =>\n                setTimeout(() => reject(new Error('Operation timed out after 30 seconds')), 30000)\n            );\n\n            if (difference > 0) {\n                // Stability Receiver has too much -> send excess to Stability Provider\n\n                // Create invoice on Stability Provider with timeout\n                const invoicePromise = this.walletManager.wallets[1].nwcClient.makeInvoice({\n                    amount: amount * 1000, // Convert sats to millisats\n                    description: `Stabilization: excess ${amount} sats (${this.stabilizationData.currency.toUpperCase()})`\n                });\n\n                const invoice = await Promise.race([invoicePromise, timeoutPromise]);\n                this.log(`💱 Invoice erstellt: ${amount} sats`);\n\n                // Pay invoice from Stability Receiver with timeout\n                const paymentPromise = this.walletManager.wallets[2].nwcClient.payInvoice({\n                    invoice: invoice.invoice\n                });\n\n                const payment = await Promise.race([paymentPromise, timeoutPromise]);\n                this.log(`💱 Rebalancing erfolgreich: ${amount} sats übertragen (Receiver → Provider)`);\n\n            } else {\n                // Stability Receiver has too little -> receive from Stability Provider\n\n                // Create invoice on Stability Receiver with timeout\n                const invoicePromise = this.walletManager.wallets[2].nwcClient.makeInvoice({\n                    amount: amount * 1000, // Convert sats to millisats\n                    description: `Stabilization: deficit ${amount} sats (${this.stabilizationData.currency.toUpperCase()})`\n                });\n\n                const invoice = await Promise.race([invoicePromise, timeoutPromise]);\n                this.log(`💱 Invoice erstellt: ${amount} sats`);\n\n                // Pay invoice from Stability Provider with timeout\n                const paymentPromise = this.walletManager.wallets[1].nwcClient.payInvoice({\n                    invoice: invoice.invoice\n                });\n\n                const payment = await Promise.race([paymentPromise, timeoutPromise]);\n                this.log(`💱 Rebalancing erfolgreich: ${amount} sats übertragen (Provider → Receiver)`);\n            }\n\n            // Update last rebalance time\n            this.stabilizationData.lastRebalanceTime = Date.now();\n            this.stabilizationData.errorCount = 0; // Reset error counter on success\n\n        } catch (error) {\n            this.stabilizationData.errorCount++;\n\n            if (error.message.includes('timed out')) {\n                this.log(`💱 Rebalancing Timeout: ${error.message}`);\n                this.log(`💱 Möglicherweise Relay-Verbindungsprobleme. Versuche beim nächsten Zyklus erneut.`);\n            } else if (error.message.includes('insufficient')) {\n                this.log(`💱 Rebalancing fehlgeschlagen: Unzureichende Balance`);\n            } else {\n                this.log(`💱 Rebalancing fehlgeschlagen: ${error.message}`);\n            }\n\n            console.error('Rebalancing error:', error);\n\n            // If too many consecutive errors, pause rebalancing for longer\n            if (this.stabilizationData.errorCount >= 3) {\n                this.stabilizationData.lastRebalanceTime = Date.now();\n                this.log(`💱 Pausiere Rebalancing für 2 Minuten nach ${this.stabilizationData.errorCount} Fehlern`);\n                setTimeout(() => {\n                    this.stabilizationData.lastRebalanceTime = 0;\n                    this.log(`💱 Rebalancing wieder bereit`);\n                }, 120000); // 2 minutes pause\n            }\n        }\n    }\n\n    updateStabilizationUI() {\n        const currencySelect = document.getElementById('stabilization-currency');\n        const startBtn = document.getElementById('start-stabilization');\n        const stopBtn = document.getElementById('stop-stabilization');\n        const thresholdInput = document.getElementById('rebalance-threshold');\n\n        if (this.stabilizationData.active) {\n            currencySelect.disabled = true;\n            thresholdInput.disabled = true;\n            startBtn.disabled = true;\n            stopBtn.disabled = false;\n        } else {\n            currencySelect.disabled = false;\n            thresholdInput.disabled = false;\n            startBtn.disabled = !currencySelect.value || !this.walletManager.wallets[1].isConnected || !this.walletManager.wallets[2].isConnected;\n            stopBtn.disabled = true;\n        }\n    }\n\n    updateStabilizationStatus(currentBalance, currentValue, requiredBalance, difference) {\n        const statusElement = document.getElementById('stabilization-status');\n        const infoElement = document.getElementById('stabilization-info');\n\n        if (this.stabilizationData.active) {\n            const currency = this.stabilizationData.currency.toUpperCase();\n            const targetValue = this.stabilizationData.targetValue;\n\n            statusElement.className = 'alert alert-success py-2 px-3 mb-2';\n            statusElement.innerHTML = `Status: Aktiv (${currency})`;\n\n            infoElement.innerHTML = `\n                <div><strong>Zielwert:</strong> ${targetValue.toFixed(2)} ${currency}</div>\n                <div><strong>Aktueller Wert:</strong> ${currentValue.toFixed(2)} ${currency}</div>\n                <div><strong>Balance:</strong> ${currentBalance.toLocaleString()} sats</div>\n                <div><strong>Soll-Balance:</strong> ${requiredBalance.toLocaleString()} sats</div>\n                <div><strong>Differenz:</strong> ${difference > 0 ? '+' : ''}${difference.toLocaleString()} sats</div>\n            `;\n        } else {\n            statusElement.className = 'alert alert-secondary py-2 px-3 mb-2';\n            statusElement.innerHTML = 'Status: Nicht aktiv';\n            infoElement.innerHTML = '';\n        }\n    }\n\n    async updateWalletStabilizationDisplay() {\n        // Update Stability Provider display\n        await this.updateSingleWalletDisplay(1);\n        // Update Stability Receiver display\n        await this.updateSingleWalletDisplay(2);\n        // Update transaction displays\n        await this.updateWalletTransactions(1);\n        await this.updateWalletTransactions(2);\n    }\n\n    async updateSingleWalletDisplay(walletId) {\n        const infoElement = document.getElementById(`wallet${walletId}-stabilization-info`);\n\n        if (!this.walletManager.wallets[walletId].isConnected) {\n            infoElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <i class=\"fas fa-info-circle\"></i>\n                    <div>Wallet ${walletId} verbinden um Daten anzuzeigen</div>\n                </div>\n            `;\n            return;\n        }\n\n        try {\n            // Get wallet balance\n            const balanceResponse = await this.walletManager.wallets[walletId].nwcClient.getBalance();\n            const balanceSats = Math.round(balanceResponse.balance / 1000);\n\n            // Get current Bitcoin price\n            const priceResponse = await fetch('https://mempool.space/api/v1/prices');\n            const priceData = await priceResponse.json();\n\n            // Calculate values for different currencies\n            const currencies = {\n                USD: { symbol: '$', value: priceData.USD },\n                EUR: { symbol: '€', value: priceData.EUR },\n                GBP: { symbol: '£', value: priceData.GBP },\n                CHF: { symbol: '₣', value: priceData.CHF },\n                CAD: { symbol: 'C$', value: priceData.CAD },\n                JPY: { symbol: '¥', value: priceData.JPY }\n            };\n\n            let currencyDisplays = '';\n            Object.entries(currencies).forEach(([code, data]) => {\n                const value = (balanceSats / 100000000) * data.value;\n                currencyDisplays += `\n                    <div class=\"d-flex justify-content-between mb-1\">\n                        <span class=\"small\">${code}:</span>\n                        <span class=\"small fw-bold\">${data.symbol}${value.toFixed(2)}</span>\n                    </div>\n                `;\n            });\n\n            // Show stabilization status for Stability Receiver\n            let stabilizationStatus = '';\n            if (walletId === 2 && this.stabilizationData.active) {\n                const targetCurrency = this.stabilizationData.currency.toUpperCase();\n                const currentValue = (balanceSats / 100000000) * currencies[targetCurrency].value;\n                const targetValue = this.stabilizationData.targetValue;\n                const difference = currentValue - targetValue;\n\n                stabilizationStatus = `\n                    <div class=\"border-top pt-2 mt-2\">\n                        <div class=\"small text-success\">\n                            <strong>🎯 Stabilisierung aktiv (${targetCurrency})</strong>\n                        </div>\n                        <div class=\"d-flex justify-content-between\">\n                            <span class=\"small\">Zielwert:</span>\n                            <span class=\"small\">${currencies[targetCurrency].symbol}${targetValue.toFixed(2)}</span>\n                        </div>\n                        <div class=\"d-flex justify-content-between\">\n                            <span class=\"small\">Differenz:</span>\n                            <span class=\"small ${difference >= 0 ? 'text-success' : 'text-danger'}\">\n                                ${difference >= 0 ? '+' : ''}${currencies[targetCurrency].symbol}${difference.toFixed(2)}\n                            </span>\n                        </div>\n                    </div>\n                `;\n            }\n\n            infoElement.innerHTML = `\n                <div class=\"mb-2\">\n                    <div class=\"d-flex justify-content-between mb-2\">\n                        <span class=\"fw-bold\">Balance:</span>\n                        <span class=\"fw-bold text-primary\">${balanceSats.toLocaleString()} sats</span>\n                    </div>\n                    <div class=\"border-top pt-2\">\n                        <div class=\"small text-muted mb-1\">Währungswerte:</div>\n                        ${currencyDisplays}\n                    </div>\n                    ${stabilizationStatus}\n                </div>\n            `;\n\n        } catch (error) {\n            infoElement.innerHTML = `\n                <div class=\"text-center text-danger py-3\">\n                    <i class=\"fas fa-exclamation-triangle\"></i>\n                    <div>Fehler beim Laden der Wallet-Daten</div>\n                    <small>${error.message}</small>\n                </div>\n            `;\n        }\n    }\n\n    async updateWalletTransactions(walletId) {\n        const transactionsElement = document.getElementById(`wallet${walletId}-transactions`);\n\n        if (!this.walletManager.wallets[walletId].isConnected) {\n            transactionsElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <i class=\"fas fa-info-circle\"></i>\n                    <div>Wallet ${walletId} verbinden um Transaktionen anzuzeigen</div>\n                </div>\n            `;\n            return;\n        }\n\n        // Check if we already know transactions are not supported\n        if (this.walletManager.wallets[walletId].transactionsSupported === false) {\n            transactionsElement.innerHTML = `\n                <div class=\"text-center text-warning py-3\">\n                    <i class=\"fas fa-clock\"></i>\n                    <div>Transaktionen nicht verfügbar</div>\n                    <small class=\"text-muted\">NWC Provider unterstützt diese Funktion nicht</small>\n                </div>\n            `;\n            return;\n        }\n\n        // Show loading state only on first attempt\n        if (this.walletManager.wallets[walletId].transactionsSupported === null) {\n            transactionsElement.innerHTML = `\n                <div class=\"text-center text-muted py-3\">\n                    <div class=\"spinner-border spinner-border-sm me-2\" role=\"status\"></div>\n                    <div>Transaktionen werden geladen...</div>\n                </div>\n            `;\n        }\n\n        try {\n            // Use the existing working listTransactions logic\n            const transactionResponse = await this.walletManager.wallets[walletId].nwcClient.listTransactions({\n                from: 0,\n                until: Math.floor(Date.now() / 1000),\n                limit: 10, // Only get last 10 for the UI\n                offset: 0,\n                unpaid: false,\n                type: undefined\n            });\n\n            let transactions = transactionResponse.transactions || transactionResponse;\n\n            // If that fails, try without parameters as fallback\n            if (!transactions || transactions.length === 0) {\n                const fallbackResponse = await this.walletManager.wallets[walletId].nwcClient.listTransactions({});\n                transactions = fallbackResponse.transactions || fallbackResponse;\n            }\n\n            // Mark as supported if we get here\n            this.walletManager.wallets[walletId].transactionsSupported = true;\n\n            if (!transactions || transactions.length === 0) {\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-muted py-3\">\n                        <i class=\"fas fa-inbox\"></i>\n                        <div>Keine Transaktionen gefunden</div>\n                    </div>\n                `;\n                return;\n            }\n\n            // Sort transactions by date (newest first) and limit to last 10\n            const sortedTransactions = transactions\n                .sort((a, b) => b.created_at - a.created_at)\n                .slice(0, 10);\n\n            let transactionHtml = '';\n            sortedTransactions.forEach(tx => {\n                const date = new Date(tx.created_at * 1000);\n                const amountSats = Math.round(tx.amount / 1000); // Convert millisats to sats\n                const txType = tx.type || 'payment';\n\n                // Determine if transaction is incoming or outgoing\n                let isIncoming = false;\n                let icon = '💸';\n                let colorClass = 'text-danger';\n                let typeText = 'Ausgehend';\n\n                // Check transaction type first, then amount as fallback\n                if (txType === 'incoming') {\n                    isIncoming = true;\n                    icon = '📥';\n                    colorClass = 'text-success';\n                    typeText = 'Empfangen';\n                } else if (txType === 'outgoing') {\n                    isIncoming = false;\n                    icon = '📤';\n                    colorClass = 'text-danger';\n                    typeText = 'Gesendet';\n                } else {\n                    // Fallback: use amount sign to determine direction\n                    isIncoming = amountSats > 0;\n                    if (isIncoming) {\n                        icon = '💰';\n                        colorClass = 'text-success';\n                        typeText = 'Eingehend';\n                    }\n                }\n\n                // Format description\n                let description = tx.description || tx.memo || 'Keine Beschreibung';\n                if (description.length > 40) {\n                    description = description.substring(0, 40) + '...';\n                }\n\n                transactionHtml += `\n                    <div class=\"border-bottom px-3 py-2\">\n                        <div class=\"d-flex justify-content-between align-items-start mb-1\">\n                            <div class=\"d-flex align-items-center\">\n                                <span class=\"me-2\">${icon}</span>\n                                <div>\n                                    <div class=\"small fw-bold ${colorClass}\">\n                                        ${isIncoming ? '+' : '-'}${Math.abs(amountSats).toLocaleString()} sats\n                                    </div>\n                                    <div class=\"text-muted\" style=\"font-size: 0.75rem;\">\n                                        ${typeText}\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"text-end\">\n                                <div class=\"text-muted small\">\n                                    ${date.toLocaleString('de-DE', {\n                                        day: '2-digit',\n                                        month: '2-digit',\n                                        hour: '2-digit',\n                                        minute: '2-digit'\n                                    })}\n                                </div>\n                            </div>\n                        </div>\n                        <div class=\"small text-muted\" style=\"font-size: 0.75rem;\">\n                            ${description}\n                        </div>\n                    </div>\n                `;\n            });\n\n            transactionsElement.innerHTML = transactionHtml;\n\n        } catch (error) {\n            console.warn(`Wallet ${walletId} transactions error:`, error.message);\n\n            // Determine if it's a timeout or other error\n            const isTimeout = error.message.includes('Timeout') || error.message.includes('reply timeout');\n\n            if (isTimeout) {\n                // Mark transactions as unsupported for this wallet\n                this.walletManager.wallets[walletId].transactionsSupported = false;\n\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-warning py-3\">\n                        <i class=\"fas fa-clock\"></i>\n                        <div>Transaktionen nicht verfügbar</div>\n                        <small class=\"text-muted\">NWC Provider unterstützt diese Funktion nicht</small>\n                    </div>\n                `;\n            } else {\n                // For non-timeout errors, still mark as unsupported to avoid retries\n                this.walletManager.wallets[walletId].transactionsSupported = false;\n\n                transactionsElement.innerHTML = `\n                    <div class=\"text-center text-danger py-3\">\n                        <i class=\"fas fa-exclamation-triangle\"></i>\n                        <div>Fehler beim Laden der Transaktionen</div>\n                        <small class=\"text-muted\">${error.message}</small>\n                    </div>\n                `;\n            }\n        }\n    }\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Ee","$fS6LT","$imRk1","h","t","length","r","writable","key","f","prototype","d","assign","bind","arguments","hasOwnProperty","apply","create","m","p","setPrototypeOf","getPrototypeOf","__proto__","P","y","Reflect","construct","sham","Proxy","Boolean","valueOf","push","o","Function","w","Map","toString","indexOf","TypeError","has","value","Uint8Array","Uint32Array","buffer","B","Array","from","padStart","J","H","i","Number","parseInt","slice","isNaN","z","D","G","V","Y","X","Q","$","Z","ee","te","ne","then","re","oe","ie","se","c","relay","relayUrl","secret","lud16","walletPubkey","options","_encryptionType","nostrWalletConnectUrl","parseWalletConnectUrl","Relay","toLowerCase","startsWith","nip19","decode","data","WebSocket","console","error","URL","replace","searchParams","host","a","getNostrWalletConnectUrl","publicKey","getPublicKey","Promise","resolve","signEvent","finalizeEvent","getEventHash","close","encrypt","encryptionType","nip04","nip44","getConversationKey","reject","decrypt","getAuthorizationUrl","name","returnTo","budgetRenewal","expiresAt","Math","floor","getTime","maxAmount","requestMethods","join","notificationTypes","isolated","metadata","JSON","stringify","fromAuthorizationUrl","generateSecretKey","document","location","window","outerHeight","screenY","outerWidth","screenX","open","title","u","type","origin","protocol","clearInterval","removeEventListener","setInterval","closed","addEventListener","getWalletServiceInfo","_checkConnected","subscribe","kinds","limit","authors","eoseTimeout","onevent","oneose","content","tags","find","includes","split","encryptions","capabilities","notifications","getInfo","executeNip47Request","methods","replyTimeout","getBudget","getBalance","balance","payInvoice","payKeysend","preimage","signMessage","message","signature","createConnection","wallet_pubkey","multiPayInvoice","executeMultiNip47Request","invoices","errors","multiPayKeysend","keysends","makeInvoice","amount","invoice","makeHoldInvoice","payment_hash","settleHoldInvoice","cancelHoldInvoice","lookupInvoice","listTransactions","transactions","subscribeNotifications","setTimeout","_selectEncryptionType","concat","info","parse","notification","notification_type","onclose","method","params","kind","created_at","Date","now","clearTimeout","result","publishTimeout","publish","l","dTag","connected","connect","_findPreferredEncryptionType","warn","ve","pe","me","ye","Pe","appSecretKey","appPubkey","getConnectionUri","URLSearchParams","request_methods","icon","return_to","notification_types","max_amount","budget_renewal","expires_at","parseWalletAuthUrl","substring","onSuccess","pubkey","unsub","we","ge","be","_e","ke","publishWalletServiceInfoEvent","clientPubkey","result_type","walletSecret","Nip47Error","Nip47NetworkError","Nip47WalletError","Nip47TimeoutError","Nip47PublishTimeoutError","Nip47ReplyTimeoutError","Nip47PublishError","Nip47ResponseDecodingError","Nip47ResponseValidationError","Nip47UnexpectedResponseError","Nip47UnsupportedEncryptionError","NWCClient","NWAClient","NWCWalletServiceKeyPair","NWCWalletService","Te","Ne","je","$b8e126da42a4b9e3$export$11a838ad4e557e0e","$b8e126da42a4b9e3$export$16ca411381fc81c8","$b8e126da42a4b9e3$export$889def73691f9837","$b8e126da42a4b9e3$export$bc33d3bdc1ddcd20","$b8e126da42a4b9e3$export$325be0d991c73dc2","$b8e126da42a4b9e3$export$10660ae21dbef115","$b8e126da42a4b9e3$export$4793e42c2cc9b120","$b8e126da42a4b9e3$export$7f3384dd63301b54","$b8e126da42a4b9e3$var$_WebSocket","$b8e126da42a4b9e3$var$_fetch","$b8e126da42a4b9e3$var$_fetch3","$b8e126da42a4b9e3$var$_fetch4","$5r7db","$3Bcdj","$6XnWx","$4Dsex","$3RPiR","$lAjhr","$38xio","$aN9nT","$70Xw9","$b8e126da42a4b9e3$var$__defProp","$b8e126da42a4b9e3$var$__export","target","all","$b8e126da42a4b9e3$export$31a1b605a7b8e0bf","Symbol","$b8e126da42a4b9e3$export$d08d852dd562b1ce","event","obj","match","isArray","i2","tag","j","Queue","$b8e126da42a4b9e3$var$Queue","QueueNode","$b8e126da42a4b9e3$var$QueueNode","binarySearch","$b8e126da42a4b9e3$var$binarySearch","bytesToHex","hexToBytes","insertEventIntoAscendingList","$b8e126da42a4b9e3$var$insertEventIntoAscendingList","insertEventIntoDescendingList","$b8e126da42a4b9e3$var$insertEventIntoDescendingList","normalizeURL","$b8e126da42a4b9e3$var$normalizeURL","utf8Decoder","$b8e126da42a4b9e3$var$utf8Decoder","utf8Encoder","$b8e126da42a4b9e3$var$utf8Encoder","TextDecoder","TextEncoder","url","pathname","endsWith","port","sort","hash","sortedArray","idx","found","b","splice","arr","compare","start","end","mid","cmp","next","prev","first","last","enqueue","newNode","dequeue","target2","eventHash","sha256","encode","$b8e126da42a4b9e3$export$d32d86987f616a9e","evt","$b8e126da42a4b9e3$var$i","schnorr","utils","randomPrivateKey","secretKey","sig","sign","verifyEvent","valid","verify","$b8e126da42a4b9e3$export$909d658b5069e986","$b8e126da42a4b9e3$var$isRegularKind","$b8e126da42a4b9e3$var$isReplaceableKind","$b8e126da42a4b9e3$var$isEphemeralKind","$b8e126da42a4b9e3$var$isAddressableKind","$b8e126da42a4b9e3$var$classifyKind","$b8e126da42a4b9e3$var$isKind","kindAsArray","Application","$b8e126da42a4b9e3$var$Application","BadgeAward","$b8e126da42a4b9e3$var$BadgeAward","BadgeDefinition","$b8e126da42a4b9e3$var$BadgeDefinition","BlockedRelaysList","$b8e126da42a4b9e3$var$BlockedRelaysList","BookmarkList","$b8e126da42a4b9e3$var$BookmarkList","Bookmarksets","$b8e126da42a4b9e3$var$Bookmarksets","Calendar","$b8e126da42a4b9e3$var$Calendar","CalendarEventRSVP","$b8e126da42a4b9e3$var$CalendarEventRSVP","ChannelCreation","$b8e126da42a4b9e3$var$ChannelCreation","ChannelHideMessage","$b8e126da42a4b9e3$var$ChannelHideMessage","ChannelMessage","$b8e126da42a4b9e3$var$ChannelMessage","ChannelMetadata","$b8e126da42a4b9e3$var$ChannelMetadata","ChannelMuteUser","$b8e126da42a4b9e3$var$ChannelMuteUser","ClassifiedListing","$b8e126da42a4b9e3$var$ClassifiedListing","ClientAuth","$b8e126da42a4b9e3$var$ClientAuth","CommunitiesList","$b8e126da42a4b9e3$var$CommunitiesList","CommunityDefinition","$b8e126da42a4b9e3$var$CommunityDefinition","CommunityPostApproval","$b8e126da42a4b9e3$var$CommunityPostApproval","Contacts","$b8e126da42a4b9e3$var$Contacts","CreateOrUpdateProduct","$b8e126da42a4b9e3$var$CreateOrUpdateProduct","CreateOrUpdateStall","$b8e126da42a4b9e3$var$CreateOrUpdateStall","Curationsets","$b8e126da42a4b9e3$var$Curationsets","$b8e126da42a4b9e3$var$Date2","DirectMessageRelaysList","$b8e126da42a4b9e3$var$DirectMessageRelaysList","DraftClassifiedListing","$b8e126da42a4b9e3$var$DraftClassifiedListing","DraftLong","$b8e126da42a4b9e3$var$DraftLong","Emojisets","$b8e126da42a4b9e3$var$Emojisets","EncryptedDirectMessage","$b8e126da42a4b9e3$var$EncryptedDirectMessage","EventDeletion","$b8e126da42a4b9e3$var$EventDeletion","FileMetadata","$b8e126da42a4b9e3$var$FileMetadata","FileServerPreference","$b8e126da42a4b9e3$var$FileServerPreference","Followsets","$b8e126da42a4b9e3$var$Followsets","GenericRepost","$b8e126da42a4b9e3$var$GenericRepost","Genericlists","$b8e126da42a4b9e3$var$Genericlists","GiftWrap","$b8e126da42a4b9e3$var$GiftWrap","HTTPAuth","$b8e126da42a4b9e3$var$HTTPAuth","Handlerinformation","$b8e126da42a4b9e3$var$Handlerinformation","Handlerrecommendation","$b8e126da42a4b9e3$var$Handlerrecommendation","Highlights","$b8e126da42a4b9e3$var$Highlights","InterestsList","$b8e126da42a4b9e3$var$InterestsList","Interestsets","$b8e126da42a4b9e3$var$Interestsets","JobFeedback","$b8e126da42a4b9e3$var$JobFeedback","JobRequest","$b8e126da42a4b9e3$var$JobRequest","JobResult","$b8e126da42a4b9e3$var$JobResult","Label","$b8e126da42a4b9e3$var$Label","LightningPubRPC","$b8e126da42a4b9e3$var$LightningPubRPC","LiveChatMessage","$b8e126da42a4b9e3$var$LiveChatMessage","LiveEvent","$b8e126da42a4b9e3$var$LiveEvent","LongFormArticle","$b8e126da42a4b9e3$var$LongFormArticle","Metadata","$b8e126da42a4b9e3$var$Metadata","Mutelist","$b8e126da42a4b9e3$var$Mutelist","NWCWalletInfo","$b8e126da42a4b9e3$var$NWCWalletInfo","NWCWalletRequest","$b8e126da42a4b9e3$var$NWCWalletRequest","NWCWalletResponse","$b8e126da42a4b9e3$var$NWCWalletResponse","NostrConnect","$b8e126da42a4b9e3$var$NostrConnect","OpenTimestamps","$b8e126da42a4b9e3$var$OpenTimestamps","Pinlist","$b8e126da42a4b9e3$var$Pinlist","PrivateDirectMessage","$b8e126da42a4b9e3$var$PrivateDirectMessage","ProblemTracker","$b8e126da42a4b9e3$var$ProblemTracker","ProfileBadges","$b8e126da42a4b9e3$var$ProfileBadges","PublicChatsList","$b8e126da42a4b9e3$var$PublicChatsList","Reaction","$b8e126da42a4b9e3$var$Reaction","RecommendRelay","$b8e126da42a4b9e3$var$RecommendRelay","RelayList","$b8e126da42a4b9e3$var$RelayList","Relaysets","$b8e126da42a4b9e3$var$Relaysets","Report","$b8e126da42a4b9e3$var$Report","Reporting","$b8e126da42a4b9e3$var$Reporting","Repost","$b8e126da42a4b9e3$var$Repost","Seal","$b8e126da42a4b9e3$var$Seal","SearchRelaysList","$b8e126da42a4b9e3$var$SearchRelaysList","ShortTextNote","$b8e126da42a4b9e3$var$ShortTextNote","Time","$b8e126da42a4b9e3$var$Time","UserEmojiList","$b8e126da42a4b9e3$var$UserEmojiList","UserStatuses","$b8e126da42a4b9e3$var$UserStatuses","Zap","$b8e126da42a4b9e3$var$Zap","ZapGoal","$b8e126da42a4b9e3$var$ZapGoal","ZapRequest","$b8e126da42a4b9e3$var$ZapRequest","classifyKind","isAddressableKind","isEphemeralKind","isKind","isRegularKind","isReplaceableKind","$b8e126da42a4b9e3$var$getHex64","json","field","len","$b8e126da42a4b9e3$var$getInt","sliced","min","$b8e126da42a4b9e3$var$getSubscriptionId","pstart","pend","$b8e126da42a4b9e3$var$matchEventId","$b8e126da42a4b9e3$var$matchEventPubkey","$b8e126da42a4b9e3$var$matchEventKind","$b8e126da42a4b9e3$var$makeAuthEvent","relayURL","challenge","$b8e126da42a4b9e3$var$yieldThread","ch","MessageChannel","handler","port1","port2","postMessage","getHex64","getInt","getSubscriptionId","matchEventId","matchEventKind","matchEventPubkey","makeAuthEvent","$b8e126da42a4b9e3$var$SendingOnClosedConnection","$b8e126da42a4b9e3$var$AbstractRelay","_connected","onnotice","msg","debug","baseEoseTimeout","connectionTimeout","openSubs","connectionTimeoutHandle","connectionPromise","openCountRequests","openEventPublishes","ws","incomingMessageQueue","queueRunning","authPromise","serial","_WebSocket","opts","websocketImplementation","closeAllSubscriptions","reason","_","sub","ep","clear","cr","onopen","onerror","ev","onmessage","_onmessage","runQueue","handleNext","subid","so","alreadyHave","alreadyHaveEvent","receivedEvent","$b8e126da42a4b9e3$export$4bbf3f173cb9a4eb","filters","$b8e126da42a4b9e3$export$c6f8482e724e56c5","filter","ids","tagName","values","since","until","payload","count","delete","receivedEose","ok","timeout","send","auth","signAuthEvent","ret","subscription","prepareSubscription","fire","label","$b8e126da42a4b9e3$var$Subscription","eosed","eoseTimeoutHandle","BECH32_REGEX","$b8e126da42a4b9e3$var$BECH32_REGEX","Bech32MaxSize","$b8e126da42a4b9e3$var$Bech32MaxSize","NostrTypeGuard","$b8e126da42a4b9e3$var$NostrTypeGuard","$b8e126da42a4b9e3$var$decode","decodeNostrURI","$b8e126da42a4b9e3$var$decodeNostrURI","encodeBytes","$b8e126da42a4b9e3$var$encodeBytes","naddrEncode","$b8e126da42a4b9e3$var$naddrEncode","neventEncode","$b8e126da42a4b9e3$var$neventEncode","noteEncode","$b8e126da42a4b9e3$var$noteEncode","nprofileEncode","$b8e126da42a4b9e3$var$nprofileEncode","npubEncode","$b8e126da42a4b9e3$var$npubEncode","nsecEncode","$b8e126da42a4b9e3$var$nsecEncode","isNProfile","test","isNEvent","isNAddr","isNSec","isNPub","isNote","isNcryptsec","nip19code","_err","prefix","words","bech32","fromWords","tlv","$b8e126da42a4b9e3$var$parseTLV","relays","map","author","identifier","rest","$b8e126da42a4b9e3$var$encodeBech32","hex","toWords","bytes","profile","$b8e126da42a4b9e3$var$encodeTLV","kindArray","$b8e126da42a4b9e3$var$integerToUint8Array","number","uint8Array","addr","ArrayBuffer","DataView","setUint32","entries","reverse","forEach","vs","entry","concatBytes","$b8e126da42a4b9e3$var$encrypt","text","privkey","normalizedKey","$b8e126da42a4b9e3$var$getNormalizedX","secp256k1","getSharedSecret","iv","randomBytes","plaintext","ciphertext","cbc","ctb64","base64","ivb64","$b8e126da42a4b9e3$var$decrypt","NIP05_REGEX","$b8e126da42a4b9e3$var$NIP05_REGEX","isNip05","$b8e126da42a4b9e3$var$isNip05","isValid","$b8e126da42a4b9e3$var$isValid","queryProfile","$b8e126da42a4b9e3$var$queryProfile","searchDomain","$b8e126da42a4b9e3$var$searchDomain","useFetchImplementation","$b8e126da42a4b9e3$var$useFetchImplementation","fetch","fetchImplementation","domain","query","res","redirect","status","names","fullname","nip05","$b8e126da42a4b9e3$var$parse","maybeParent","maybeRoot","reply","root","mentions","profiles","quotes","eTagEventId","eTagRelayUrl","eTagMarker","eTagAuthor","eventPointer","ref","fetchRelayInformation","$b8e126da42a4b9e3$var$fetchRelayInformation","$b8e126da42a4b9e3$var$useFetchImplementation2","headers","Accept","$b8e126da42a4b9e3$var$getPow","nibble","clz32","$b8e126da42a4b9e3$var$minePow","unsigned","difficulty","now2","$b8e126da42a4b9e3$var$fastEventHash","fastEventHash","getPow","minePow","unwrapEvent","$b8e126da42a4b9e3$var$unwrapEvent2","unwrapManyEvents","$b8e126da42a4b9e3$var$unwrapManyEvents2","wrapEvent","$b8e126da42a4b9e3$var$wrapEvent2","wrapManyEvents","$b8e126da42a4b9e3$var$wrapManyEvents2","createRumor","$b8e126da42a4b9e3$var$createRumor","createSeal","$b8e126da42a4b9e3$var$createSeal","createWrap","$b8e126da42a4b9e3$var$createWrap","$b8e126da42a4b9e3$var$unwrapEvent","$b8e126da42a4b9e3$var$unwrapManyEvents","$b8e126da42a4b9e3$var$wrapEvent","$b8e126da42a4b9e3$var$wrapManyEvents","$b8e126da42a4b9e3$var$getConversationKey","privkeyA","pubkeyB","sharedX","subarray","extract","$b8e126da42a4b9e3$var$getMessageKeys","conversationKey","nonce","keys","expand","chacha_key","chacha_nonce","hmac_key","$b8e126da42a4b9e3$var$calcPaddedLen","isSafeInteger","nextPower","log2","chunk","$b8e126da42a4b9e3$var$hmacAad","aad","combined","hmac","$b8e126da42a4b9e3$var$encrypt2","padded","$b8e126da42a4b9e3$var$pad","unpadded","unpaddedLen","$b8e126da42a4b9e3$var$writeU16BE","num","setUint16","suffix","chacha20","mac","$b8e126da42a4b9e3$var$decrypt2","$b8e126da42a4b9e3$var$decodePayload","plen","dlen","vers","calculatedMac","equalBytes","getUint16","v2","$b8e126da42a4b9e3$var$v2","calcPaddedLen","$b8e126da42a4b9e3$var$now","round","$b8e126da42a4b9e3$var$randomNow","random","$b8e126da42a4b9e3$var$nip44ConversationKey","privateKey","$b8e126da42a4b9e3$var$nip44Encrypt","$b8e126da42a4b9e3$var$nip44Decrypt","rumor","recipientPublicKey","seal","randomKey","senderPrivateKey","recipientsPublicKeys","senderPublicKey","wrappeds","wrap","recipientPrivateKey","unwrappedSeal","wrappedEvents","unwrappedEvents","recipient","conversationTitle","replyTo","$b8e126da42a4b9e3$var$createEvent","recipients","baseEvent","ceil","recipientsArray","eventId","$b8e126da42a4b9e3$var$finishRepostEvent","reposted","String","$b8e126da42a4b9e3$var$getRepostedEventPointer","lastETag","lastPTag","x","$b8e126da42a4b9e3$var$getRepostedEvent","skipVerification","repostedEvent","pointer","finishRepostEvent","getRepostedEvent","getRepostedEventPointer","NOSTR_URI_REGEX","$b8e126da42a4b9e3$var$NOSTR_URI_REGEX","$b8e126da42a4b9e3$var$parse2","$b8e126da42a4b9e3$var$test","RegExp","source","uri","decoded","$b8e126da42a4b9e3$var$finishReactionEvent","reacted","inheritedTags","$b8e126da42a4b9e3$var$getReactedEventPointer","finishReactionEvent","getReactedEventPointer","$b8e126da42a4b9e3$var$parse3","$b8e126da42a4b9e3$var$noCharacter","$b8e126da42a4b9e3$var$noURLCharacter","max","prevIndex","index","prefixLen","hostname","channelCreateEvent","$b8e126da42a4b9e3$var$channelCreateEvent","channelHideMessageEvent","$b8e126da42a4b9e3$var$channelHideMessageEvent","channelMessageEvent","$b8e126da42a4b9e3$var$channelMessageEvent","channelMetadataEvent","$b8e126da42a4b9e3$var$channelMetadataEvent","channelMuteUserEvent","$b8e126da42a4b9e3$var$channelMuteUserEvent","channel_create_event_id","relay_url","reply_to_channel_message_event_id","channel_message_event_id","pubkey_to_mute","EMOJI_SHORTCODE_REGEX","$b8e126da42a4b9e3$var$EMOJI_SHORTCODE_REGEX","matchAll","$b8e126da42a4b9e3$var$matchAll","regex","$b8e126da42a4b9e3$var$regex","replaceAll","$b8e126da42a4b9e3$var$replaceAll","shortcode","replacer","$b8e126da42a4b9e3$var$useFetchImplementation3","validateGithub","$b8e126da42a4b9e3$var$validateGithub","username","proof","$b8e126da42a4b9e3$var$parseConnectionString","connectionString","$b8e126da42a4b9e3$var$makeNwcRequestEvent","encryptedContent","$b8e126da42a4b9e3$var$normalizeIdentifier","trim","normalize","char","makeNwcRequestEvent","parseConnectionString","normalizeIdentifier","getSatoshisAmountFromBolt11","$b8e126da42a4b9e3$var$getSatoshisAmountFromBolt11","getZapEndpoint","$b8e126da42a4b9e3$var$getZapEndpoint","makeZapReceipt","$b8e126da42a4b9e3$var$makeZapReceipt","makeZapRequest","$b8e126da42a4b9e3$var$makeZapRequest","$b8e126da42a4b9e3$var$useFetchImplementation4","validateZapRequest","$b8e126da42a4b9e3$var$validateZapRequest","lnurl","lud06","body","allowsNostr","nostrPubkey","callback","comment","zr","zapRequestString","zapRequest","bolt11","paidAt","tagsFromZapRequest","zap","lastIndexOf","hrp","digit","charCodeAt","cutPoint","isDigit","getToken","$b8e126da42a4b9e3$var$getToken","hashPayload","$b8e126da42a4b9e3$var$hashPayload","unpackEventFromToken","$b8e126da42a4b9e3$var$unpackEventFromToken","validateEvent","$b8e126da42a4b9e3$var$validateEvent2","validateEventKind","$b8e126da42a4b9e3$var$validateEventKind","validateEventMethodTag","$b8e126da42a4b9e3$var$validateEventMethodTag","validateEventPayloadTag","$b8e126da42a4b9e3$var$validateEventPayloadTag","validateEventTimestamp","$b8e126da42a4b9e3$var$validateEventTimestamp","validateEventUrlTag","$b8e126da42a4b9e3$var$validateEventUrlTag","validateToken","$b8e126da42a4b9e3$var$validateToken","$b8e126da42a4b9e3$var$_authorizationScheme","loginUrl","httpMethod","includeAuthorizationScheme","signedEvent","authorizationScheme","token","catch","eventB64","urlTag","methodTag","payloadTag","payloadHash","encodeToCurve","hashToCurve","$jYfwB","$9BbKC","$2D9sF","$gNPqy","$esaJO","$rkPJ6","$7OcHe","$3f551179096121b9$var$secp256k1P","BigInt","$3f551179096121b9$var$secp256k1N","$3f551179096121b9$var$_1n","$3f551179096121b9$var$_2n","$3f551179096121b9$var$divNearest","$3f551179096121b9$var$sqrtMod","_3n","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","$3f551179096121b9$var$Fp","eql","sqr","Field","undefined","sqrt","createCurve","Fp","Gx","Gy","lowS","endo","beta","splitScalar","k","a1","b1","a2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","$3f551179096121b9$var$_0n","$3f551179096121b9$var$fe","$3f551179096121b9$var$TAGGED_HASH_PREFIXES","$3f551179096121b9$var$taggedHash","messages","tagP","tagH","$3f551179096121b9$var$pointToBytes","point","toRawBytes","$3f551179096121b9$var$numTo32b","numberToBytesBE","$3f551179096121b9$var$modP","$3f551179096121b9$var$modN","$3f551179096121b9$var$Point","ProjectivePoint","$3f551179096121b9$var$schnorrGetExtPubKey","priv","d_","normPrivateKeyToScalar","fromPrivateKey","scalar","hasEvenY","$3f551179096121b9$var$lift_x","xx","assertValidity","$3f551179096121b9$var$challenge","args","bytesToNumberBE","$3f551179096121b9$var$schnorrVerify","ensureBytes","pub","R","BASE","multiplyAndAddUnsafe","toAffine","auxRand","px","rand","k_","rx","lift_x","pointToBytes","taggedHash","$3f551179096121b9$var$isoMap","isogenyMap","$3f551179096121b9$var$mapSWU","mapToCurveSimpleSWU","A","$3f551179096121b9$var$htf","createHasher","scalars","DST","encodeDST","ORDER","sha224","$fwPy5","$e89fa9d0527b0915$var$Chi","$e89fa9d0527b0915$var$Maj","$e89fa9d0527b0915$var$SHA256_K","$e89fa9d0527b0915$var$IV","$e89fa9d0527b0915$var$SHA256_W","$e89fa9d0527b0915$var$SHA256","SHA2","C","E","F","process","view","offset","getUint32","W15","W2","s0","rotr","s1","T1","T2","sigma0","roundClean","fill","destroy","$e89fa9d0527b0915$var$SHA224","outputLen","wrapConstructor","$dAIf1","$b4e1d4aa1af05b71$var$SHA2","Hash","blockLen","padOffset","isLE","finished","pos","destroyed","createView","update","exists","toBytes","take","dataView","digestInto","out","output","$b4e1d4aa1af05b71$var$setBigUint64","byteOffset","setBigUint64","_32n","_u32_max","wh","wl","oview","outLen","state","digest","_cloneInto","to","$9e50f49469d56a92$var$number","$9e50f49469d56a92$var$bool","$9e50f49469d56a92$var$bytes","lengths","$9e50f49469d56a92$var$hash","$9e50f49469d56a92$var$exists","instance","checkFinished","$9e50f49469d56a92$var$output","bool","default","wrapXOFConstructorWithOpts","wrapConstructorWithOpts","checkOpts","utf8ToBytes","asyncLoop","nextTick","u32","u8","$gEhde","byteLength","word","shift","$6fd0af385bc5ccc9$var$hexes","array","byte","$6fd0af385bc5ccc9$var$nextTick","$6fd0af385bc5ccc9$var$asyncLoop","iters","tick","cb","ts","diff","$6fd0af385bc5ccc9$var$utf8ToBytes","str","$6fd0af385bc5ccc9$var$toBytes","arrays","reduce","sum","pad","clone","$6fd0af385bc5ccc9$var$toStr","defaults","hashCons","hashC","tmp","bytesLength","crypto","getRandomValues","mapHashToField","getMinHashLength","getFieldBytesLength","hashToPrivateScalar","FpSqrtEven","FpSqrtOdd","nLength","FpIsSquare","FpDiv","FpInvertBatch","FpPow","validateField","isNegativeLE","FpSqrt","tonelliShanks","invert","pow","$1ea6901afdde618b$var$_0n","$1ea6901afdde618b$var$_1n","$1ea6901afdde618b$var$_2n","$1ea6901afdde618b$var$_3n","$1ea6901afdde618b$var$_4n","$1ea6901afdde618b$var$_5n","$1ea6901afdde618b$var$_8n","$1ea6901afdde618b$var$mod","$1ea6901afdde618b$var$pow","power","modulo","$1ea6901afdde618b$var$invert","q","gcd","$1ea6901afdde618b$var$tonelliShanks","S","legendreC","p1div4","Q1div2","neg","ONE","g","mul","ZERO","$1ea6901afdde618b$var$FpSqrt","n2","nv","$1ea6901afdde618b$var$FIELD_FIELDS","$1ea6901afdde618b$var$FpPow","$1ea6901afdde618b$var$FpInvertBatch","nums","lastMultiplied","acc","is0","inverted","inv","reduceRight","$1ea6901afdde618b$var$nLength","nBitLength","_nBitLength","nByteLength","$1ea6901afdde618b$var$getFieldBytesLength","fieldOrder","bitLength","$1ea6901afdde618b$var$getMinHashLength","val","MASK","BYTES","BITS","validateObject","lhs","rhs","legendreConst","bitLen","redef","sqrtP","freeze","bitMask","isOdd","add","div","sqrN","addN","subN","mulN","invertBatch","lst","cmov","numberToBytesLE","fromBytes","bytesToNumberLE","elm","groupOrder","hashLen","minLen","fieldLen","reduced","createHmacDrbg","bitSet","bitGet","numberToVarBytesBE","hexToNumber","numberToHexUnpadded","$a85c028f110aa8ce$var$_0n","$a85c028f110aa8ce$var$_1n","$a85c028f110aa8ce$var$_2n","$a85c028f110aa8ce$var$hexes","$a85c028f110aa8ce$var$bytesToHex","$a85c028f110aa8ce$var$numberToHexUnpadded","$a85c028f110aa8ce$var$hexToNumber","$a85c028f110aa8ce$var$hexToBytes","$a85c028f110aa8ce$var$numberToBytesBE","$a85c028f110aa8ce$var$concatBytes","expectedLength","$a85c028f110aa8ce$var$u8n","$a85c028f110aa8ce$var$u8fr","qByteLen","hmacFn","reset","reseed","seed","gen","sl","pred","$a85c028f110aa8ce$var$validatorFns","bigint","function","boolean","string","stringOrUint8Array","object","validators","optValidators","checkField","fieldName","isOptional","checkVal","SWUFpSqrtRatio","weierstrass","weierstrassPoints","DER","$lkFCe","$c3b91d553ab14e64$var$b2n","$c3b91d553ab14e64$var$h2b","Err","_parseInt","toSig","sBytes","rBytesLeft","hexFromSig","shl","rhl","rl","$c3b91d553ab14e64$var$_0n","$c3b91d553ab14e64$var$_1n","$c3b91d553ab14e64$var$_2n","$c3b91d553ab14e64$var$_3n","$c3b91d553ab14e64$var$_4n","$c3b91d553ab14e64$var$weierstrassPoints","CURVE","$c3b91d553ab14e64$var$validatePointOpts","curve","validateBasic","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","_c","_isCompressed","tail","weierstrassEquation","x2","x3","isWithinCurveOrder","assertGE","pointPrecomputes","assertPrjPoint","other","Point","py","pz","fromAffine","normalizeZ","points","toInv","fromHex","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","left","right","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","double","X3","Y3","Z3","t0","t3","t4","t5","subtract","wNAF","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1p","k2p","fake","f1p","f2p","constTimeNegate","iz","ax","ay","zz","cofactor","isCompressed","toHex","_bits","$c3b91d553ab14e64$var$SWUFpSqrtRatio","_2n_pow_c1_1","_2n_pow_c1","c3","c4","c6","c7","sqrtRatio","tv1","tv2","tv3","tv5","tv4","isQR","tvv5","e1","y1","y2","curveDef","$c3b91d553ab14e64$var$validateOpts","bits2int","bits2int_modN","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","cat","head","isHeadOdd","numToNByteStr","slcNum","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","ir","u1","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","isProbPub","item","delta","ORDER_MASK","int2octets","defaultSigOpts","prehash","defaultVerOpts","privateA","publicB","privKey","k2sig","prepSig","some","extraEntropy","ent","h1int","seedArgs","kBytes","ik","normS","isBiggerThanHalfOrder","drbg","_sig","sg","derError","is","isValidPrivateKey","precompute","tv6","_0n","_1n","bits","condition","W","windows","precomputeWindow","base","precomputes","mask","maxNumber","shiftBy","wbits","offset2","abs","cond1","cond2","precomputesMap","transform","hash_to_field","expand_message_xof","expand_message_xmd","$0522aeca5769187c$var$os2ip","$0522aeca5769187c$var$i2osp","$0522aeca5769187c$var$isBytes","$0522aeca5769187c$var$isNum","$0522aeca5769187c$var$expand_message_xmd","lenInBytes","b_in_bytes","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","$0522aeca5769187c$var$strxor","pseudo_random_bytes","$0522aeca5769187c$var$expand_message_xof","dkLen","$0522aeca5769187c$var$hash_to_field","prb","_DST","$0522aeca5769187c$var$validateDST","dst","L","log2p","len_in_bytes","elm_offset","tv","COEFF","xNum","xDen","yNum","yDen","mapToCurve","def","u0","getHash","$1EIgu","$5af70d1c5fca3e4e$var$getHash","msgs","defHash","HMAC","$134bdcf9c481be10$var$HMAC","_key","iHash","oHash","buf","$dUxV2","$29ee4d3171d9809b$var$hexes","$29ee4d3171d9809b$var$nextTick","$29ee4d3171d9809b$var$asyncLoop","$29ee4d3171d9809b$var$utf8ToBytes","$29ee4d3171d9809b$var$toBytes","$g9W9K","$510ad3657d73a9d2$var$Chi","$510ad3657d73a9d2$var$Maj","$510ad3657d73a9d2$var$SHA256_K","$510ad3657d73a9d2$var$IV","$510ad3657d73a9d2$var$SHA256_W","$510ad3657d73a9d2$var$SHA256","$510ad3657d73a9d2$var$SHA224","$dNiq9","$bc3a993d7d38a7a0$var$SHA2","$bc3a993d7d38a7a0$var$setBigUint64","$a0ae23f5901291b4$var$number","$a0ae23f5901291b4$var$bool","$a0ae23f5901291b4$var$bytes","$a0ae23f5901291b4$var$hash","$a0ae23f5901291b4$var$exists","$a0ae23f5901291b4$var$output","$3600b4829dff8fa9$export$dfbcecb440255e4a","$3600b4829dff8fa9$var$chain","$3600b4829dff8fa9$var$alphabet","alphabet","digits","input","letter","$3600b4829dff8fa9$var$join","separator","$3600b4829dff8fa9$var$padding","chr","$3600b4829dff8fa9$var$normalize","fn","$3600b4829dff8fa9$var$convertRadix","carry","done","digitBase","$3600b4829dff8fa9$export$b3b2de96497acc47","$3600b4829dff8fa9$export$27c42482533637da","$3600b4829dff8fa9$var$gcd","$3600b4829dff8fa9$var$radix2carry","$3600b4829dff8fa9$var$convertRadix2","padding","$3600b4829dff8fa9$var$radix2","revPadding","$3600b4829dff8fa9$var$unsafeWrapper","toUpperCase","$3600b4829dff8fa9$var$genBase58","abc","$3600b4829dff8fa9$var$BECH_ALPHABET","$3600b4829dff8fa9$var$POLYMOD_GENERATORS","$3600b4829dff8fa9$var$bech32Polymod","pre","chk","$3600b4829dff8fa9$var$bechChecksum","encodingConst","$3600b4829dff8fa9$var$genBech32","encoding","ENCODING_CONST","_words","fromWordsUnsafe","lowered","sepIndex","decodeUnsafe","actualLength","decodeToBytes","unsafe","siv","gcm","cfb","ecb","ctr","expandKeyDecLE","expandKeyLE","$8wowT","$87adI","$2d0e1e19edfeea80$var$EMPTY_BLOCK","$2d0e1e19edfeea80$var$mul2","$2d0e1e19edfeea80$var$POLY","$2d0e1e19edfeea80$var$mul","$2d0e1e19edfeea80$var$sbox","box","$2d0e1e19edfeea80$var$invSbox","$2d0e1e19edfeea80$var$rotr32_8","$2d0e1e19edfeea80$var$rotl32_8","$2d0e1e19edfeea80$var$genTtable","sbox","T0","T3","T01","T23","sbox2","Uint16Array","$2d0e1e19edfeea80$var$tableEncoding","$2d0e1e19edfeea80$var$tableDecoding","$2d0e1e19edfeea80$var$xPowers","$2d0e1e19edfeea80$var$expandKeyLE","k32","Nk","subByte","$2d0e1e19edfeea80$var$applySbox","xk","$2d0e1e19edfeea80$var$expandKeyDecLE","encKey","$2d0e1e19edfeea80$var$apply0123","s2","s3","$2d0e1e19edfeea80$var$encrypt","rounds","$2d0e1e19edfeea80$var$decrypt","$2d0e1e19edfeea80$var$getDst","$2d0e1e19edfeea80$var$ctrCounter","src","srcLen","c32","src32","dst32","$2d0e1e19edfeea80$var$BLOCK_SIZE","b32","$2d0e1e19edfeea80$var$ctr32","ctrPos","ctrNum","$2d0e1e19edfeea80$var$validateBlockDecrypt","$2d0e1e19edfeea80$var$validateBlockEncrypt","pcks5","remaining","$2d0e1e19edfeea80$var$validatePCKS","lastByte","$2d0e1e19edfeea80$var$padPCKS","tmp32","paddingByte","$2d0e1e19edfeea80$var$computeTag","AAD","wrapCipher","blockSize","nonceLength","processCtr","disablePadding","_out","n32","ps0","ps1","ps2","ps3","o0","o1","o2","o3","processCfb","isEncrypt","next32","e0","e2","e3","tagLength","_computeTag","authKey","tagMask","ghash","deriveKeys","counter","nonceLen","passedTag","$2d0e1e19edfeea80$var$limit","$2d0e1e19edfeea80$var$isBytes32","AAD_LIMIT","PLAIN_LIMIT","NONCE_LIMIT","CIPHER_LIMIT","derivedKey","d32","polyval","t32","processSiv","block","expectedTag","encryptBlock","decryptBlock","ctrCounter","ctr32","u64Lengths","bytesToUtf8","u16","$248bf24903c02b9f$var$hexes","$248bf24903c02b9f$var$bytesToHex","$248bf24903c02b9f$var$asciiToBase16","$248bf24903c02b9f$var$asciis","$248bf24903c02b9f$var$hexToBytes","hl","al","ai","hi","n1","$248bf24903c02b9f$var$hexToNumber","$248bf24903c02b9f$var$nextTick","$248bf24903c02b9f$var$asyncLoop","$248bf24903c02b9f$var$utf8ToBytes","$248bf24903c02b9f$var$setBigUint64","isBytes","$5e86e7af933ab8a1$var$number","$5e86e7af933ab8a1$var$bool","$5e86e7af933ab8a1$var$isBytes","$5e86e7af933ab8a1$var$bytes","$5e86e7af933ab8a1$var$hash","$5e86e7af933ab8a1$var$exists","$5e86e7af933ab8a1$var$output","_toGHASHKey","$634456ee3058786c$var$ZEROS16","$634456ee3058786c$var$ZEROS32","$634456ee3058786c$var$mul2","$634456ee3058786c$var$POLY","hiBit","$634456ee3058786c$var$swapLE","$634456ee3058786c$var$_toGHASHKey","$634456ee3058786c$var$GHASH","kView","k0","k3","doubles","items","d0","d1","d2","d3","_updateBlock","bytePos","bitPos","blocks","o32","$634456ee3058786c$var$Polyval","ghKey","$634456ee3058786c$var$wrapConstructorWithKey","xchacha20poly1305","chacha20poly1305","_poly1305_aead","chacha12","chacha8","xchacha20","chacha20orig","hchacha","$byidz","$8niJx","$040e20af249c8886$var$chachaCore","cnt","y00","y01","y02","y03","y04","y05","y06","y07","y08","y09","y10","y11","y13","y14","y15","x00","x01","x02","x03","x04","x05","x06","x07","x08","x09","x10","x11","x12","x13","x14","x15","rotl","oi","y12","$040e20af249c8886$var$hchacha","createCipher","counterRight","counterLength","allowShortKeys","extendNonceFn","$040e20af249c8886$var$ZEROS16","$040e20af249c8886$var$updatePadded","$040e20af249c8886$var$ZEROS32","$040e20af249c8886$var$computeTag","poly1305","xorStream","plength","clength","wrapConstructorWithKey","$8691005ce78b9c39$var$u8to16","$8691005ce78b9c39$var$Poly1305","t6","t7","isLast","r0","r1","r2","r3","r4","r5","r6","r7","r8","r9","h0","h1","h2","h3","h4","h5","h6","h7","h8","h9","d4","d5","d6","d7","d8","d9","finalize","opos","$8691005ce78b9c39$var$wrapConstructorWithKey","sigma","$618f00ce983d19db$var$_utf8ToBytes","$618f00ce983d19db$var$sigma16","$618f00ce983d19db$var$sigma32","$618f00ce983d19db$var$sigma16_32","$618f00ce983d19db$var$sigma32_32","$618f00ce983d19db$var$isAligned32","$618f00ce983d19db$var$MAX_COUNTER","$618f00ce983d19db$var$U32_EMPTY","core","toClean","nonceNcLen","nc","$618f00ce983d19db$var$runCipher","isAligned","pos32","posj","pop","hkdf","$7db5c28b27589b25$var$extract","ikm","salt","$7db5c28b27589b25$var$HKDF_COUNTER","$7db5c28b27589b25$var$EMPTY_BUFFER","$7db5c28b27589b25$var$expand","prk","okm","HMACTmp","T","$51b6b372898f65c0$var$HMAC","$d5f3a4ad9113e89a$export$ba5f874f962e090e","$d5f3a4ad9113e89a$export$ebeb97171ba8142c","$d5f3a4ad9113e89a$export$c32e8ef196152e59","$d5f3a4ad9113e89a$var$n","$d5f3a4ad9113e89a$var$o","utf8","$d5f3a4ad9113e89a$var$i","$d5f3a4ad9113e89a$var$e","stringToBytes","bytesToString","bech32m","base58check","base58xmr","base58xrp","base58flickr","base58","base64url","base32crockford","base32hex","base32","base16","assertNumber","chain","checksum","radix","radix2","$d5f3a4ad9113e89a$var$t","$d5f3a4ad9113e89a$var$s","pubKeyHash","scriptHash","validWitnessVersions","$d5f3a4ad9113e89a$var$a","$d5f3a4ad9113e89a$var$c","$d5f3a4ad9113e89a$var$u","$d5f3a4ad9113e89a$var$h","$d5f3a4ad9113e89a$var$l","$d5f3a4ad9113e89a$var$f","$d5f3a4ad9113e89a$var$d","$d5f3a4ad9113e89a$var$p","$d5f3a4ad9113e89a$var$m","payment_secret","description","payee","description_hash","expiry","min_final_cltv_expiry","fallback_address","route_hint","feature_bits","$d5f3a4ad9113e89a$var$y","$d5f3a4ad9113e89a$var$w","$d5f3a4ad9113e89a$var$v","short_channel_id","fee_base_msat","fee_proportional_millionths","cltv_expiry_delta","extra_bits","start_bit","has_required","$d5f3a4ad9113e89a$export$299d8670b6d2c8e","U","N","MAX_SAFE_INTEGER","letters","$d5f3a4ad9113e89a$var$g","tagCode","paymentRequest","sections","route_hints","paymentHash","satoshi","timestamp","$d5f3a4ad9113e89a$var$x","$d5f3a4ad9113e89a$var$A","$d5f3a4ad9113e89a$var$k","$d5f3a4ad9113e89a$var$_","$d5f3a4ad9113e89a$var$U","$d5f3a4ad9113e89a$var$L","$d5f3a4ad9113e89a$var$D","$d5f3a4ad9113e89a$var$I","$d5f3a4ad9113e89a$var$j","$d5f3a4ad9113e89a$var$S","$d5f3a4ad9113e89a$var$R","$d5f3a4ad9113e89a$var$$","$d5f3a4ad9113e89a$var$T","$d5f3a4ad9113e89a$var$W","$d5f3a4ad9113e89a$var$N","createdDate","expiryDate","successAction","pr","isPaid","validatePreimage","verifyPayment","statusText","settled","hasExpired","$d5f3a4ad9113e89a$export$1890c02602d63c","nostr","$d5f3a4ad9113e89a$export$d32d86987f616a9e","$d5f3a4ad9113e89a$export$d08d852dd562b1ce","$d5f3a4ad9113e89a$export$3e6ee22e431c91ae","customData","customKey","customValue","destination","$d5f3a4ad9113e89a$var$q","$d5f3a4ad9113e89a$export$8304a22d431f958","$d5f3a4ad9113e89a$export$3c93f2a0ff50284a","$d5f3a4ad9113e89a$export$178fe3191ba1e804","minSendable","maxSendable","payerData","fixed","metadataHash","email","image","commentAllowed","rawData","$d5f3a4ad9113e89a$var$J","$d5f3a4ad9113e89a$export$b35bd30dfac2a74b","boost","webln","keysend","value_msat","customRecords","enable","$d5f3a4ad9113e89a$export$9437aa3703bd4b0c","address","lnurlpData","keysendData","nostrData","nostrRelays","proxy","exec","getWebLN","fetchWithProxy","fetchWithoutProxy","ln","parseLnUrlPayResponse","lnurlp","parseKeysendResponse","parseNostrResponse","fetchLnurlData","fetchKeysendData","fetchNostrData","lnurlpUrl","keysendUrl","nostrUrl","generateInvoice","search","requestInvoice","payerdata","zapInvoice","sendPayment","$d5f3a4ad9113e89a$export$dfa27062c7281cab","storage","getItem","setItem","rate_float","$d5f3a4ad9113e89a$export$cbdbadc5090a1f57","currency","getFiatBtcRate","getFiatValue","getSatoshiValue","getFormattedFiatValue","locale","toLocaleString","style","$9BsJg","$a77da6ceca5d66da$export$d9a919bae0329c9a","wallets","isConnected","nwcClient","connectionData","transactionsSupported","saveNWCString","walletId","nwcUrl","localStorage","log","loadNWCString","clearNWCString","removeItem","logElement","getElementById","toLocaleTimeString","textContent","scrollTop","scrollHeight","updateConnectionStatus","statusElement","className","toggleConnectionVisibility","textarea","toggleBtn","webkitTextSecurity","connectWallet","alert","nwc","disabled","alias","dispatchEvent","CustomEvent","disconnectWallet","getWalletInfo","displayBalance","balance_sats","balance_millisats","createInvoice","prompt","unpaid","fallbackError","saveConnectionString","clearConnectionString","loadSavedConnectionStrings","savedUrl","clearLog","$6a2e34ea2fddba81$export$1a7dcbc42b6f58b1","priceUpdateInterval","priceChart","PRICE_STORAGE_KEY","MAX_PRICE_HISTORY","PRICE_CHANGE_THRESHOLD","savePriceHistory","priceData","history","getPriceHistory","lastPoint","timeDiff","shouldSave","oldPrice","prices","newPrice","changePercent","hoursPassed","stored","getFilteredPriceHistory","timeRange","timeWindow","cutoffTime","clearPriceHistory","clearAndReloadPriceData","labels","datasets","dataset","fetchHistoricalPrices","response","sortedHistory","convertedHistory","time","USD","EUR","GBP","CHF","CAD","JPY","AUD","updatePriceChart","existingHistory","fetchBitcoinPrice","updatePriceDisplay","updateLivePriceInChart","currencies","priceEl","satsEl","updatedEl","selectedRange","querySelector","liveHistory","filteredHistory","filterHistoryByRange","dataPoints","usd","symbol","unit","eur","gbp","chf","cad","jpy","priceElement","satsElement","formattedValue","minimumFractionDigits","maximumFractionDigits","formattedSats","satoshisPerUnit","timeString","startPriceUpdates","stopPriceUpdates","initializePriceChart","ctx","getContext","Chart","borderColor","backgroundColor","borderWidth","tension","pointRadius","yAxisID","responsive","maintainAspectRatio","interaction","mode","intersect","plugins","legend","display","position","onClick","legendItem","datasetIndex","chart","isVisible","isDatasetVisible","setDatasetVisibility","tooltip","callbacks","context","parsed","scales","grid","color","ticks","date","hour","minute","maxTicksLimit","beginAtZero","drawOnChartArea","$d0c67cc6a727cdb2$export$3d022597fb56d1f4","walletManager","stabilizationData","active","initialBalance","targetValue","initialPrice","checkInterval","threshold","lastRebalanceTime","rebalanceMinInterval","errorCount","maxErrors","startStabilization","balanceResponse","currentBalance","currentPrice","updateStabilizationUI","checkRebalancing","toFixed","stopStabilization","requiredBalance","difference","updateStabilizationStatus","updateWalletStabilizationDisplay","timeSinceLastRebalance","currentThreshold","performRebalancing","waitTime","timeoutPromise","invoicePromise","race","paymentPromise","currencySelect","startBtn","stopBtn","thresholdInput","currentValue","infoElement","innerHTML","updateSingleWalletDisplay","updateWalletTransactions","balanceSats","priceResponse","currencyDisplays","stabilizationStatus","targetCurrency","transactionsElement","transactionResponse","fallbackResponse","sortedTransactions","transactionHtml","tx","amountSats","txType","isIncoming","colorClass","typeText","memo","day","month","priceManager","stabilizationManager","setupEventListeners","makeGlobalFunctions","initialize"],"version":3,"file":"nwc.36942d46.js.map"}